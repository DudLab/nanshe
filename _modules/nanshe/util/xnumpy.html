

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nanshe.util.xnumpy &mdash; nanshe 0.1.0a18 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.0a18',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../../_static/cloud.js"></script>
    <link rel="top" title="nanshe 0.1.0a18 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body role="document">
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../../index.html">nanshe 0.1.0a18 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nanshe.util.xnumpy</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The module ``xnumpy`` provides useful functions in combination with ``numpy``.</span>

<span class="sd">===============================================================================</span>
<span class="sd">Overview</span>
<span class="sd">===============================================================================</span>
<span class="sd">The module ``xnumpy`` provides some addition useful functions that are useful</span>
<span class="sd">in conjunction with  |numpy|_. The functions provided vary from handling view,</span>
<span class="sd">adding calculations, combining arrays in interesting ways, handling masks, etc.</span>

<span class="sd">.. |numpy| replace:: ``numpy``</span>
<span class="sd">.. _numpy: http://www.numpy.org/</span>

<span class="sd">===============================================================================</span>
<span class="sd">API</span>
<span class="sd">===============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;John Kirkham &lt;kirkhamj@janelia.hhmi.org&gt;&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s">&quot;$May 20, 2014 09:46:45 EDT$&quot;</span>


<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="kn">import</span> <span class="nn">scipy.misc</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage.morphology</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>
<span class="kn">import</span> <span class="nn">scipy.stats.mstats</span>

<span class="kn">import</span> <span class="nn">bottleneck</span>

<span class="kn">import</span> <span class="nn">vigra</span>


<span class="kn">import</span> <span class="nn">iters</span>


<span class="c"># Need in order to have logging information no matter what.</span>
<span class="kn">import</span> <span class="nn">prof</span>


<span class="c"># Get the logger</span>
<span class="n">trace_logger</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">getTraceLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="to_ctype"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.to_ctype">[docs]</a><span class="k">def</span> <span class="nf">to_ctype</span><span class="p">(</span><span class="n">a_type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a numpy.dtype or any type that can be converted to a numpy.dtype</span>
<span class="sd">        and returns its equivalent ctype.</span>

<span class="sd">        Args:</span>
<span class="sd">            a_type(type):      the type to find an equivalent ctype to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (ctype):           the ctype equivalent to the dtype provided.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; to_ctype(float)</span>
<span class="sd">            &lt;class &#39;ctypes.c_double&#39;&gt;</span>

<span class="sd">            &gt;&gt;&gt; to_ctype(numpy.float64)</span>
<span class="sd">            &lt;class &#39;ctypes.c_double&#39;&gt;</span>

<span class="sd">            &gt;&gt;&gt; to_ctype(numpy.float32)</span>
<span class="sd">            &lt;class &#39;ctypes.c_float&#39;&gt;</span>

<span class="sd">            &gt;&gt;&gt; to_ctype(numpy.dtype(numpy.float32))</span>
<span class="sd">            &lt;class &#39;ctypes.c_float&#39;&gt;</span>

<span class="sd">            &gt;&gt;&gt; to_ctype(int)</span>
<span class="sd">            &lt;class &#39;ctypes.c_long&#39;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ctypeslib</span><span class="o">.</span><span class="n">as_ctypes</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a_type</span><span class="p">))))</span>


</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="renumber_label_image"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.renumber_label_image">[docs]</a><span class="k">def</span> <span class="nf">renumber_label_image</span><span class="p">(</span><span class="n">new_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a label image with non-consecutive numbering and renumbers it to</span>
<span class="sd">        be consecutive. Returns the relabeled image, a mapping from the old</span>
<span class="sd">        labels (by index) to the new ones, and a mapping from the new labels</span>
<span class="sd">        back to the old labels.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):                               the label</span>
<span class="sd">                                                                    image.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray, numpy.ndarray, numpy.ndarray):          the</span>
<span class="sd">                                                                    relabeled</span>
<span class="sd">                                                                    label</span>
<span class="sd">                                                                    image,</span>
<span class="sd">                                                                    the</span>
<span class="sd">                                                                    forward</span>
<span class="sd">                                                                    label</span>
<span class="sd">                                                                    mapping and</span>
<span class="sd">                                                                    the reverse</span>
<span class="sd">                                                                    label</span>
<span class="sd">                                                                    mapping</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; renumber_label_image(numpy.array([1, 2, 3]))</span>
<span class="sd">            (array([1, 2, 3]), array([0, 1, 2, 3]), array([0, 1, 2, 3]))</span>

<span class="sd">            &gt;&gt;&gt; renumber_label_image(numpy.array([1, 2, 4]))</span>
<span class="sd">            (array([1, 2, 3]), array([0, 1, 2, 0, 3]), array([0, 1, 2, 4]))</span>

<span class="sd">            &gt;&gt;&gt; renumber_label_image(numpy.array([0, 1, 2, 3]))</span>
<span class="sd">            (array([0, 1, 2, 3]), array([0, 1, 2, 3]), array([0, 1, 2, 3]))</span>

<span class="sd">            &gt;&gt;&gt; renumber_label_image(numpy.array([0, 1, 2, 4]))</span>
<span class="sd">            (array([0, 1, 2, 3]), array([0, 1, 2, 0, 3]), array([0, 1, 2, 4]))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Get the set of reverse label mapping</span>
    <span class="c"># (ensure the background is always included)</span>
    <span class="n">reverse_label_mapping</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">new_array</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="p">)</span>

    <span class="c"># Get the set of old labels excluding background</span>
    <span class="n">old_labels</span> <span class="o">=</span> <span class="n">reverse_label_mapping</span><span class="p">[</span><span class="n">reverse_label_mapping</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c"># Get the set of new labels in order</span>
    <span class="n">new_labels</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Get the forward label mapping (ensure the background is included)</span>
    <span class="n">forward_label_mapping</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">reverse_label_mapping</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_array</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="n">forward_label_mapping</span><span class="p">[</span><span class="n">old_labels</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_labels</span>

    <span class="c"># Get masks for each old label</span>
    <span class="n">new_array_label_masks</span> <span class="o">=</span> <span class="n">all_permutations_equal</span><span class="p">(</span><span class="n">old_labels</span><span class="p">,</span> <span class="n">new_array</span><span class="p">)</span>

    <span class="c"># Create tiled where each label is expanded to the size of the new_array</span>
    <span class="n">new_labels_tiled_view</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span><span class="n">new_labels</span><span class="p">,</span> <span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c"># Take every mask and make sure it has the appropriate sequential label</span>
    <span class="c"># Then combine each of these parts of the label image together into a new</span>
    <span class="c"># sequential label image</span>
    <span class="n">new_array_relabeled</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">new_array_label_masks</span> <span class="o">*</span> <span class="n">new_labels_tiled_view</span>
    <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span><span class="p">((</span><span class="n">new_array_relabeled</span><span class="p">,</span> <span class="n">forward_label_mapping</span><span class="p">,</span> <span class="n">reverse_label_mapping</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="index_axis_at_pos"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.index_axis_at_pos">[docs]</a><span class="k">def</span> <span class="nf">index_axis_at_pos</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indexes an arbitrary axis to the given position, which may be an index,</span>
<span class="sd">        a slice, or any other NumPy allowed indexing type. This will return a</span>
<span class="sd">        view.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to add the singleton</span>
<span class="sd">                                                 axis to.</span>

<span class="sd">            axis(int):                           position for the axis to be in</span>
<span class="sd">                                                 the final array.</span>
<span class="sd">            pos(int or slice):                   how to index at the given</span>
<span class="sd">                                                 axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a numpy array view of the</span>
<span class="sd">                                                 original array.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; index_axis_at_pos(a, 0, 0).shape</span>
<span class="sd">            (2, 3, 4)</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; index_axis_at_pos(a, 1, 0).shape</span>
<span class="sd">            (1, 3, 4)</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; index_axis_at_pos(a, 2, 0).shape</span>
<span class="sd">            (1, 2, 4)</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; index_axis_at_pos(a, 3, 0).shape</span>
<span class="sd">            (1, 2, 3)</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; (index_axis_at_pos(a, 3, 0) == a[:,:,:,0]).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; (index_axis_at_pos(a, -1, 0) == a[:,:,:,0]).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; (index_axis_at_pos(a, -1, 2) == a[:,:,:,2]).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; (index_axis_at_pos(a, 1, 1) == a[:,1,:,:]).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; (index_axis_at_pos(a, 2, slice(None,None,2)) == a[:,:,::2,:]).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape((1,2,3,4))</span>
<span class="sd">            &gt;&gt;&gt; index_axis_at_pos(a, 2, 2)[0, 1, 3] = 19; a[0, 1, 2, 3] == 19</span>
<span class="sd">            True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Rescale axis inside the bounds</span>
    <span class="n">axis</span> <span class="o">%=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">ndim</span>

    <span class="c"># Swaps the first with the desired axis (returns a view)</span>
    <span class="n">new_array_swapped</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="c"># Index to pos at the given axis</span>
    <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">new_array_swapped</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>

    <span class="c"># Check to see if the chosen axis still exists (if pos were a slice)</span>
    <span class="k">if</span> <span class="n">new_subarray</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">new_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="c"># Transpose our selection to that ordering.</span>
        <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">new_subarray</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">new_subarray</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">new_subarray</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">new_subarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">new_subarray</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_subarray</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="add_singleton_axis_pos"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.add_singleton_axis_pos">[docs]</a><span class="k">def</span> <span class="nf">add_singleton_axis_pos</span><span class="p">(</span><span class="n">a_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a singleton axis to the given position.</span>

<span class="sd">        Allows negative values for axis. Also, automatically bounds axis in an</span>
<span class="sd">        acceptable regime if it is not already.</span>

<span class="sd">        Args:</span>
<span class="sd">            a_array(numpy.ndarray):            array to add the singleton axis</span>
<span class="sd">                                               to.</span>
<span class="sd">            axis(int):                         position for the axis to be in</span>
<span class="sd">                                               the final array (defaults to</span>
<span class="sd">                                               zero).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                   a numpy array with the singleton</span>
<span class="sd">                                               axis added (should be a view).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6))).shape</span>
<span class="sd">            (1, 7, 9, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6)), 0).shape</span>
<span class="sd">            (1, 7, 9, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6)), axis = 0).shape</span>
<span class="sd">            (1, 7, 9, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6)), 1).shape</span>
<span class="sd">            (7, 1, 9, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6)), 2).shape</span>
<span class="sd">            (7, 9, 1, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6)), 3).shape</span>
<span class="sd">            (7, 9, 6, 1)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6)), -1).shape</span>
<span class="sd">            (7, 9, 6, 1)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_pos(numpy.ones((7,9,6)), -2).shape</span>
<span class="sd">            (7, 9, 1, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Clean up axis to be within the allowable range.</span>
    <span class="n">axis</span> <span class="o">%=</span> <span class="p">(</span><span class="n">a_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Constructing the current ordering of axis and the singleton dime</span>
    <span class="n">new_array_shape</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">new_array_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">new_array_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_array_shape</span><span class="p">)</span>

    <span class="c"># Adds singleton dimension at front.</span>
    <span class="c"># Then changes the order so it is elsewhere.</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">a_array</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">new_array_shape</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_array</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="add_singleton_axis_beginning"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.add_singleton_axis_beginning">[docs]</a><span class="k">def</span> <span class="nf">add_singleton_axis_beginning</span><span class="p">(</span><span class="n">new_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a singleton axis to the beginning of the array.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to add the singleton</span>
<span class="sd">                                                 axis to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a numpy array with the</span>
<span class="sd">                                                 singleton axis added at the</span>
<span class="sd">                                                 end (should be view)</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; add_singleton_axis_beginning(numpy.ones((7,9,6))).shape</span>
<span class="sd">            (1, 7, 9, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_beginning(numpy.eye(3)).shape</span>
<span class="sd">            (1, 3, 3)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># return( new_array[None] )</span>
    <span class="k">return</span><span class="p">(</span><span class="n">add_singleton_axis_pos</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="add_singleton_axis_end"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.add_singleton_axis_end">[docs]</a><span class="k">def</span> <span class="nf">add_singleton_axis_end</span><span class="p">(</span><span class="n">new_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a singleton axis to the end of the array.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to add the singleton</span>
<span class="sd">                                                 axis to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a numpy array with the</span>
<span class="sd">                                                 singleton axis added at the</span>
<span class="sd">                                                 end (should be view)</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; add_singleton_axis_end(numpy.ones((7,9,6))).shape</span>
<span class="sd">            (7, 9, 6, 1)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_axis_end(numpy.eye(3)).shape</span>
<span class="sd">            (3, 3, 1)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># return( numpy.rollaxis(new_array[None], 0, new_array.ndim + 1) )</span>
    <span class="k">return</span><span class="p">(</span><span class="n">add_singleton_axis_pos</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">new_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="squish"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.squish">[docs]</a><span class="k">def</span> <span class="nf">squish</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the given axes to the last dimensions of the array and then</span>
<span class="sd">        squishes them into one dimension.</span>

<span class="sd">        Note:</span>
<span class="sd">            Returns a view if possible. However, if the axes provided are not</span>
<span class="sd">            consecutive integers when placed in the range [0, new_array.ndim),</span>
<span class="sd">            due to reshaping, the returned array will be a copy.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):           array to find the max (subject</span>
<span class="sd">                                                to the absolute value).</span>

<span class="sd">            axis(int or collection of ints):    desired axes to squish.</span>
<span class="sd">            keepdims(bool):                     ensure the number of dimensions</span>
<span class="sd">                                                is the same plus one by</span>
<span class="sd">                                                inserting singleton dimensions</span>
<span class="sd">                                                at all the axes squished.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                    an array with one dimension at</span>
<span class="sd">                                                the end containing all the</span>
<span class="sd">                                                given axes.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape(2,3,4).copy(); a</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; a.base is None</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a); b</span>
<span class="sd">            array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,</span>
<span class="sd">                   17, 18, 19, 20, 21, 22, 23])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=0); b</span>
<span class="sd">            array([[[ 0, 12],</span>
<span class="sd">                    [ 1, 13],</span>
<span class="sd">                    [ 2, 14],</span>
<span class="sd">                    [ 3, 15]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[ 4, 16],</span>
<span class="sd">                    [ 5, 17],</span>
<span class="sd">                    [ 6, 18],</span>
<span class="sd">                    [ 7, 19]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[ 8, 20],</span>
<span class="sd">                    [ 9, 21],</span>
<span class="sd">                    [10, 22],</span>
<span class="sd">                    [11, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=2); b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=-1); b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=(0,1)); b</span>
<span class="sd">            array([[ 0,  4,  8, 12, 16, 20],</span>
<span class="sd">                   [ 1,  5,  9, 13, 17, 21],</span>
<span class="sd">                   [ 2,  6, 10, 14, 18, 22],</span>
<span class="sd">                   [ 3,  7, 11, 15, 19, 23]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=(1, 0)); b</span>
<span class="sd">            array([[ 0, 12,  4, 16,  8, 20],</span>
<span class="sd">                   [ 1, 13,  5, 17,  9, 21],</span>
<span class="sd">                   [ 2, 14,  6, 18, 10, 22],</span>
<span class="sd">                   [ 3, 15,  7, 19, 11, 23]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            False</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=(0, 2)); b</span>
<span class="sd">            array([[ 0,  1,  2,  3, 12, 13, 14, 15],</span>
<span class="sd">                   [ 4,  5,  6,  7, 16, 17, 18, 19],</span>
<span class="sd">                   [ 8,  9, 10, 11, 20, 21, 22, 23]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            False</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=(0, 2), keepdims=True); b</span>
<span class="sd">            array([[[[ 0,  1,  2,  3, 12, 13, 14, 15]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 4,  5,  6,  7, 16, 17, 18, 19]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 8,  9, 10, 11, 20, 21, 22, 23]]]])</span>

<span class="sd">            &gt;&gt;&gt; b = squish(a, axis=(1, 0), keepdims=True); b</span>
<span class="sd">            array([[[[ 0, 12,  4, 16,  8, 20],</span>
<span class="sd">                     [ 1, 13,  5, 17,  9, 21],</span>
<span class="sd">                     [ 2, 14,  6, 18, 10, 22],</span>
<span class="sd">                     [ 3, 15,  7, 19, 11, 23]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Convert the axes into a standard format that we can work with.</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">new_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># If axes is some kind of iterable, convert it to a list.</span>
        <span class="c"># If not assume, it is a single value.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>

        <span class="c"># Correct axes to be within the range [0, new_array.ndim).</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

    <span class="c"># Put all axes not part of the group in front and</span>
    <span class="c"># stuff the rest at the back.</span>
    <span class="n">axis_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">iters</span><span class="o">.</span><span class="n">xrange_with_skip</span><span class="p">(</span><span class="n">new_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">to_skip</span><span class="o">=</span><span class="n">axes</span><span class="p">))</span> <span class="o">+</span> <span class="n">axes</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span>

    <span class="c"># Squash the axes at the end into one dimension.</span>
    <span class="c"># If the axes aren&#39;t consecutive, this will force a copy.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">result_shape</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span>

    <span class="c"># Add back singleton dimensions as needed.</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="c"># Need to sort or they won&#39;t be at the right place.</span>
        <span class="n">sorted_axes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="c"># Add in singleton dimensions</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sorted_axes</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">add_singleton_axis_pos</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="unsquish"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.unsquish">[docs]</a><span class="k">def</span> <span class="nf">unsquish</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverts the squish operation given the shape and the axis/axes to</span>
<span class="sd">        extract from the last dimension.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):           array to find the max (subject</span>
<span class="sd">                                                to the absolute value).</span>

<span class="sd">            shape(collection of ints):          should be the shape of the</span>
<span class="sd">                                                result array (or the array</span>
<span class="sd">                                                before squishing).</span>

<span class="sd">            axis(int or collection of ints):    desired axes to remove from the</span>
<span class="sd">                                                last axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                    an array with the shape</span>
<span class="sd">                                                provided and the axes removed</span>
<span class="sd">                                                from the end.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.arange(24).reshape(2,3,4).copy(); a</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; a.base is None</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a.reshape(-1)</span>
<span class="sd">            array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,</span>
<span class="sd">                   17, 18, 19, 20, 21, 22, 23])</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(a.reshape(-1), (2,3,4)); b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a.transpose(1,2,0)</span>
<span class="sd">            array([[[ 0, 12],</span>
<span class="sd">                    [ 1, 13],</span>
<span class="sd">                    [ 2, 14],</span>
<span class="sd">                    [ 3, 15]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[ 4, 16],</span>
<span class="sd">                    [ 5, 17],</span>
<span class="sd">                    [ 6, 18],</span>
<span class="sd">                    [ 7, 19]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[ 8, 20],</span>
<span class="sd">                    [ 9, 21],</span>
<span class="sd">                    [10, 22],</span>
<span class="sd">                    [11, 23]]])</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(a.transpose(1,2,0), (2,3,4), axis=0); b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(a, (2,3,4), axis=2); b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(a, (2,3,4), axis=-1); b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a.transpose(2,0,1).reshape(a.shape[2], -1)</span>
<span class="sd">            array([[ 0,  4,  8, 12, 16, 20],</span>
<span class="sd">                   [ 1,  5,  9, 13, 17, 21],</span>
<span class="sd">                   [ 2,  6, 10, 14, 18, 22],</span>
<span class="sd">                   [ 3,  7, 11, 15, 19, 23]])</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(</span>
<span class="sd">            ...     a.transpose(2,0,1).reshape(a.shape[2], -1),</span>
<span class="sd">            ...     (2,3,4),</span>
<span class="sd">            ...     axis=(0,1)</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; a.transpose(2, 1, 0).reshape(a.shape[2], -1)</span>
<span class="sd">            array([[ 0, 12,  4, 16,  8, 20],</span>
<span class="sd">                   [ 1, 13,  5, 17,  9, 21],</span>
<span class="sd">                   [ 2, 14,  6, 18, 10, 22],</span>
<span class="sd">                   [ 3, 15,  7, 19, 11, 23]])</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(</span>
<span class="sd">            ...     a.transpose(2, 1, 0).reshape(a.shape[2], -1),</span>
<span class="sd">            ...     (2,3,4),</span>
<span class="sd">            ...     axis=(1,0)</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            False</span>

<span class="sd">            &gt;&gt;&gt; a.transpose(1, 0, 2).reshape(a.shape[1], -1)</span>
<span class="sd">            array([[ 0,  1,  2,  3, 12, 13, 14, 15],</span>
<span class="sd">                   [ 4,  5,  6,  7, 16, 17, 18, 19],</span>
<span class="sd">                   [ 8,  9, 10, 11, 20, 21, 22, 23]])</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(</span>
<span class="sd">            ...     a.transpose(1, 0, 2).reshape(a.shape[1], -1),</span>
<span class="sd">            ...     (2,3,4),</span>
<span class="sd">            ...     axis=(0,2)</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">            &gt;&gt;&gt; b.base is a</span>
<span class="sd">            False</span>

<span class="sd">            &gt;&gt;&gt; a.transpose(1, 0, 2).reshape(a.shape[1], -1)[None]</span>
<span class="sd">            array([[[ 0,  1,  2,  3, 12, 13, 14, 15],</span>
<span class="sd">                    [ 4,  5,  6,  7, 16, 17, 18, 19],</span>
<span class="sd">                    [ 8,  9, 10, 11, 20, 21, 22, 23]]])</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(</span>
<span class="sd">            ...     a.transpose(1, 0, 2).reshape(a.shape[1], -1)[None],</span>
<span class="sd">            ...     (2,3,4),</span>
<span class="sd">            ...     axis=(0,2)</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>

<span class="sd">            &gt;&gt;&gt; a.transpose(2, 1, 0).reshape(a.shape[2], -1)[None, None]</span>
<span class="sd">            array([[[[ 0, 12,  4, 16,  8, 20],</span>
<span class="sd">                     [ 1, 13,  5, 17,  9, 21],</span>
<span class="sd">                     [ 2, 14,  6, 18, 10, 22],</span>
<span class="sd">                     [ 3, 15,  7, 19, 11, 23]]]])</span>

<span class="sd">            &gt;&gt;&gt; b = unsquish(</span>
<span class="sd">            ...     a.transpose(2, 1, 0).reshape(a.shape[2], -1)[None, None],</span>
<span class="sd">            ...     (2,3,4),</span>
<span class="sd">            ...     axis=(1,0)</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[[ 0,  1,  2,  3],</span>
<span class="sd">                    [ 4,  5,  6,  7],</span>
<span class="sd">                    [ 8,  9, 10, 11]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[12, 13, 14, 15],</span>
<span class="sd">                    [16, 17, 18, 19],</span>
<span class="sd">                    [20, 21, 22, 23]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Ensure shape is a tuple.</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="c"># Convert the axes into a standard format that we can work with.</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># If axes is some kind of iterable, convert it to a list.</span>
        <span class="c"># If not assume, it is a single value.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">axes</span><span class="p">]</span>

        <span class="c"># Correct axes to be within the range [0, len(shape)).</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)):</span>
            <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">new_array</span>

    <span class="c"># Reshape the array to get the original shape (wrong axis order).</span>
    <span class="c"># This will also eliminate singleton axes</span>
    <span class="c"># that weren&#39;t part of the original shape (i.e. squish keepdim=True).</span>
    <span class="n">shape_transposed</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
    <span class="c"># Get how the axis order was changed</span>
    <span class="n">old_axis_order_iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
        <span class="n">iters</span><span class="o">.</span><span class="n">xrange_with_skip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">to_skip</span><span class="o">=</span><span class="n">axes</span><span class="p">),</span> <span class="n">axes</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">old_axis_order_iter</span><span class="p">:</span>
        <span class="n">shape_transposed</span> <span class="o">+=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape_transposed</span><span class="p">)</span>

    <span class="c"># Find out how the axes will need to be transposed</span>
    <span class="c"># to return to the original order.</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Get how the axis order was changed</span>
        <span class="n">old_axis_order_iter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="n">iters</span><span class="o">.</span><span class="n">xrange_with_skip</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">to_skip</span><span class="o">=</span><span class="n">axes</span><span class="p">),</span> <span class="n">axes</span>
        <span class="p">)</span>
        <span class="c"># Get the current axis order (i.e. in order)</span>
        <span class="n">current_axis_order_iter</span> <span class="o">=</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>

        <span class="c"># Find how the old order relates to the new one</span>
        <span class="n">axis_order_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span><span class="n">old_axis_order_iter</span><span class="p">,</span> <span class="n">current_axis_order_iter</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c"># Export how the new order will be changed</span>
        <span class="c"># (as the old axis order will be how to transform the axes).</span>
        <span class="n">axis_order</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">axis_order_map</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())</span>

        <span class="c"># Put all axes not part of the group in front and</span>
        <span class="c"># stuff the rest at the back.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axis_order</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="add_singleton_op"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.add_singleton_op">[docs]</a><span class="k">def</span> <span class="nf">add_singleton_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs an operation on the given array on the specified axis, which</span>
<span class="sd">        otherwise would have eliminated the axis in question. This function</span>
<span class="sd">        will instead ensure that the given axis remains after the operation as</span>
<span class="sd">        a singleton.</span>

<span class="sd">        Note:</span>
<span class="sd">            The operation must be able to take only two arguments where the</span>
<span class="sd">            first is the array and the second is the axis to apply the</span>
<span class="sd">            operation along.</span>

<span class="sd">        Args:</span>
<span class="sd">            op(callable):                 callable that takes a numpy.ndarray</span>
<span class="sd">                                          and an int in order.</span>

<span class="sd">            new_array(numpy.ndarray):     array to perform operation on and add</span>
<span class="sd">                                          singleton axis too.</span>

<span class="sd">            axis(int):                    the axis to apply the operation along</span>
<span class="sd">                                          and turn into a singleton.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):              the array with the operation</span>
<span class="sd">                                          performed.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; add_singleton_op(numpy.max, numpy.ones((7,9,6)), 0).shape</span>
<span class="sd">            (1, 9, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_op(numpy.max, numpy.ones((7,9,6)), -1).shape</span>
<span class="sd">            (7, 9, 1)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_op(numpy.min, numpy.ones((7,9,6)), 1).shape</span>
<span class="sd">            (7, 1, 6)</span>

<span class="sd">            &gt;&gt;&gt; add_singleton_op(numpy.mean, numpy.ones((7,9,6)), 1).shape</span>
<span class="sd">            (7, 1, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">add_singleton_axis_pos</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="roll"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.roll">[docs]</a><span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">to_mask</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like numpy.roll, but generalizes to include a roll for each axis of</span>
<span class="sd">        new_array.</span>

<span class="sd">        Note:</span>
<span class="sd">            Right shift occurs with a positive and left occurs with a negative.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):     array to roll axes of.</span>
<span class="sd">            shift(container of ints):     some sort of container (list, tuple,</span>
<span class="sd">                                          array) of ints specifying how much to</span>
<span class="sd">                                          roll each axis.</span>

<span class="sd">            out(numpy.ndarray):           array to store the results in.</span>

<span class="sd">            to_mask(bool):                Makes the result a masked array with</span>
<span class="sd">                                          the portion that rolled off masked.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):           result of the roll.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([0]))</span>
<span class="sd">            array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,</span>
<span class="sd">                   17, 18, 19])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([1]))</span>
<span class="sd">            array([19,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,</span>
<span class="sd">                   16, 17, 18])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([2]))</span>
<span class="sd">            array([18, 19,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,</span>
<span class="sd">                   15, 16, 17])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([3]))</span>
<span class="sd">            array([17, 18, 19,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13,</span>
<span class="sd">                   14, 15, 16])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([4]))</span>
<span class="sd">            array([16, 17, 18, 19,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12,</span>
<span class="sd">                   13, 14, 15])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([5]))</span>
<span class="sd">            array([15, 16, 17, 18, 19,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,</span>
<span class="sd">                   12, 13, 14])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([6]))</span>
<span class="sd">            array([14, 15, 16, 17, 18, 19,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10,</span>
<span class="sd">                   11, 12, 13])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([8]))</span>
<span class="sd">            array([12, 13, 14, 15, 16, 17, 18, 19,  0,  1,  2,  3,  4,  5,  6,  7,  8,</span>
<span class="sd">                    9, 10, 11])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(20), numpy.array([-1]))</span>
<span class="sd">            array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,</span>
<span class="sd">                   18, 19,  0])</span>

<span class="sd">            &gt;&gt;&gt; roll(</span>
<span class="sd">            ...     numpy.arange(10).reshape(2,5),</span>
<span class="sd">            ...     numpy.ones((2,), dtype=int)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[9, 5, 6, 7, 8],</span>
<span class="sd">                   [4, 0, 1, 2, 3]])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(10).reshape(2,5), numpy.arange(2))</span>
<span class="sd">            array([[4, 0, 1, 2, 3],</span>
<span class="sd">                   [9, 5, 6, 7, 8]])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(10).reshape(2,5), numpy.arange(1, 3))</span>
<span class="sd">            array([[8, 9, 5, 6, 7],</span>
<span class="sd">                   [3, 4, 0, 1, 2]])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(10).reshape(2,5), numpy.array([2, 5]))</span>
<span class="sd">            array([[0, 1, 2, 3, 4],</span>
<span class="sd">                   [5, 6, 7, 8, 9]])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(10).reshape(2,5), numpy.array([5, 3]))</span>
<span class="sd">            array([[7, 8, 9, 5, 6],</span>
<span class="sd">                   [2, 3, 4, 0, 1]])</span>

<span class="sd">            &gt;&gt;&gt; roll(numpy.arange(10).reshape(2,5), numpy.array([-1, -1]))</span>
<span class="sd">            array([[6, 7, 8, 9, 5],</span>
<span class="sd">                   [1, 2, 3, 4, 0]])</span>

<span class="sd">            &gt;&gt;&gt; roll(</span>
<span class="sd">            ...     numpy.arange(10).reshape(2,5),</span>
<span class="sd">            ...     numpy.array([1, -1]),</span>
<span class="sd">            ...     to_mask=True</span>
<span class="sd">            ... )</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[-- -- -- -- --]</span>
<span class="sd">             [1 2 3 4 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[ True  True  True  True  True]</span>
<span class="sd">             [False False False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; roll(</span>
<span class="sd">            ...     numpy.arange(10).reshape(2,5),</span>
<span class="sd">            ...     numpy.array([0, -1]),</span>
<span class="sd">            ...     to_mask=True</span>
<span class="sd">            ... )</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[1 2 3 4 --]</span>
<span class="sd">             [6 7 8 9 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False False False  True]</span>
<span class="sd">             [False False False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.ma.arange(10).reshape(2,5).copy()</span>
<span class="sd">            &gt;&gt;&gt; roll(a, numpy.array([0, -1]), to_mask=True, out=a)</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[1 2 3 4 --]</span>
<span class="sd">             [6 7 8 9 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False False False  True]</span>
<span class="sd">             [False False False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[1 2 3 4 --]</span>
<span class="sd">             [6 7 8 9 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False False False  True]</span>
<span class="sd">             [False False False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.ma.arange(10).reshape(2,5).copy(); b = a[:, 1:-1]</span>
<span class="sd">            &gt;&gt;&gt; roll(b, numpy.array([0, -1]), to_mask=True, out=b)</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[2 3 --]</span>
<span class="sd">             [7 8 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False  True]</span>
<span class="sd">             [False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[2 3 --]</span>
<span class="sd">             [7 8 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False  True]</span>
<span class="sd">             [False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &gt;&gt;&gt; a # this should work, but it doesn&#39;t. # doctest: +SKIP</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[0 2 3 -- 4]</span>
<span class="sd">             [5 7 8 -- 9]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False False  True False]</span>
<span class="sd">             [False False False  True False]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.ma.arange(10).reshape(2,5).copy(); b = a[:, 1:-1]</span>
<span class="sd">            &gt;&gt;&gt; roll(b, numpy.array([0, -1]), to_mask=True, out=b)</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[2 3 --]</span>
<span class="sd">             [7 8 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False  True]</span>
<span class="sd">             [False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[2 3 --]</span>
<span class="sd">             [7 8 --]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False  True]</span>
<span class="sd">             [False False  True]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &gt;&gt;&gt; a.mask = numpy.ma.getmaskarray(a); a[:, 1:-1] = b; a</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[0 2 3 -- 4]</span>
<span class="sd">             [5 7 8 -- 9]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[False False False  True False]</span>
<span class="sd">             [False False False  True False]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(10).reshape(2,5)</span>
<span class="sd">            &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">            &gt;&gt;&gt; roll(a, numpy.arange(1, 3), b)</span>
<span class="sd">            array([[8, 9, 5, 6, 7],</span>
<span class="sd">                   [3, 4, 0, 1, 2]])</span>
<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            array([[0, 1, 2, 3, 4],</span>
<span class="sd">                   [5, 6, 7, 8, 9]])</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[8, 9, 5, 6, 7],</span>
<span class="sd">                   [3, 4, 0, 1, 2]])</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(10).reshape(2,5); a</span>
<span class="sd">            array([[0, 1, 2, 3, 4],</span>
<span class="sd">                   [5, 6, 7, 8, 9]])</span>
<span class="sd">            &gt;&gt;&gt; roll(a, numpy.arange(1, 3), a)</span>
<span class="sd">            array([[8, 9, 5, 6, 7],</span>
<span class="sd">                   [3, 4, 0, 1, 2]])</span>
<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            array([[8, 9, 5, 6, 7],</span>
<span class="sd">                   [3, 4, 0, 1, 2]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">shift</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">==</span> <span class="n">new_array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">shift</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">to_mask</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">new_array</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_array</span>

        <span class="k">if</span> <span class="n">to_mask</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&quot;Provided an array for `out` that is not a MaskedArray &quot;</span> <span class="o">+</span>
                    <span class="s">&quot; when requesting to mask the result. A view of `out` &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;will be used so all changes are propagated to `out`. &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;However, the mask may not be available &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;(i.e. if the array is a view). To get the mask, &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;either provide a MaskedArray as input or simply use &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;the returned result.&quot;</span><span class="p">,</span>
                    <span class="ne">RuntimeWarning</span>
                <span class="p">)</span>

                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&quot;Provided an array for `out` that is a MaskedArray, &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;but has a trivial mask (i.e. nomask). A nontrivial &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;mask will generated for `out` so that masking of `out` &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;will work properly. However, the mask will not be &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;available through the array provided. To get the mask, &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;either provide a MaskedArray with a nontrivial mask as &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;input or simply use the returned result.&quot;</span><span class="p">,</span>
                    <span class="ne">RuntimeWarning</span>
                <span class="p">)</span>

                <span class="n">out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">to_mask</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&quot;Provided an array for `new_array`/`out` that is not a &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;MaskedArray when requesting to mask the result. A view &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;of `new_array`/`out` will be used so all changes are &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;propagated to `new_array`/`out`. However, the mask may &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;not be available (i.e. if the array is a view). To get &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;the mask, either provide a MaskedArray as input or &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;simply use the returned result.&quot;</span><span class="p">,</span>
                    <span class="ne">RuntimeWarning</span>
                <span class="p">)</span>

                <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&quot;Provided an array for `new_array`/`out` that is a &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;MaskedArray, but has a trivial mask (i.e. nomask). &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;A nontrivial mask will generated for `new_array`/`out` &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;so that masking of `new_array`/`out` will work &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;properly. However, the mask will not be available &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;through the array provided. To get the mask, either &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;provide a MaskedArray with a nontrivial mask as input &quot;</span> <span class="o">+</span>
                    <span class="s">&quot;or simply use the returned result.&quot;</span><span class="p">,</span>
                    <span class="ne">RuntimeWarning</span>
                <span class="p">)</span>

                <span class="n">out</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shift</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

            <span class="c"># If fill is specified, fill the portion that rolled over.</span>
            <span class="k">if</span> <span class="n">to_mask</span><span class="p">:</span>
                <span class="n">slice_start</span> <span class="o">=</span> <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">None</span>
                <span class="n">slice_end</span> <span class="o">=</span> <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">shift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">None</span>
                <span class="n">shift_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">slice_start</span><span class="p">,</span> <span class="n">slice_end</span><span class="p">)</span>

                <span class="n">index_axis_at_pos</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">shift_slice</span><span class="p">)[:]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="contains"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.contains">[docs]</a><span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">to_contain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a mask array that is true every time something from to_contain</span>
<span class="sd">        appears in new_array.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to check for matches.</span>
<span class="sd">            to_contain(array_like):              desired matches to find.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a mask for new_array that</span>
<span class="sd">                                                 selects values from</span>
<span class="sd">                                                 ``to_contain``.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; contains(numpy.zeros((2,2)), 0)</span>
<span class="sd">            array([[ True,  True],</span>
<span class="sd">                   [ True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; contains(numpy.zeros((2,2)), 1)</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; contains(numpy.zeros((2,2)), [1])</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; contains(numpy.zeros((2,2)), numpy.array([1]))</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; contains(numpy.arange(4).reshape((2,2)), numpy.array([0]))</span>
<span class="sd">            array([[ True, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; contains(numpy.arange(4).reshape((2,2)), numpy.array([1]))</span>
<span class="sd">            array([[False,  True],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; contains(numpy.arange(4).reshape((2,2)), numpy.array([2]))</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [ True, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; contains(numpy.arange(4).reshape((2,2)), numpy.array([3]))</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False,  True]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">to_contain</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="min_abs"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.min_abs">[docs]</a><span class="k">def</span> <span class="nf">min_abs</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the min of the given array subject to the absolute value</span>
<span class="sd">        (magnitude for complex numbers).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to find the min (subject</span>
<span class="sd">                                                 to the absolute value).</span>

<span class="sd">            axis(int):                           desired matches to find.</span>

<span class="sd">            keepdims(bool):                      ensure the number of</span>
<span class="sd">                                                 dimensions is the same by</span>
<span class="sd">                                                 inserting singleton dimensions</span>
<span class="sd">                                                 at all the axes squished</span>
<span class="sd">                                                 (excepting the last one).</span>

<span class="sd">            return_indices(bool):                whether to return the indices</span>
<span class="sd">                                                 of the mins in addition to the</span>
<span class="sd">                                                 mins.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple of numpy.ndarray):            an array or value that is the</span>
<span class="sd">                                                 smallest (subject to the</span>
<span class="sd">                                                 absolute value) or if</span>
<span class="sd">                                                 ``return_indices`` the indices</span>
<span class="sd">                                                 corresponding to the smallest</span>
<span class="sd">                                                 value(s), as well.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(10))</span>
<span class="sd">            0</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(10).reshape(2,5))</span>
<span class="sd">            0</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(10).reshape(2,5), axis=0)</span>
<span class="sd">            array([0, 1, 2, 3, 4])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(10).reshape(2,5), axis=1)</span>
<span class="sd">            array([0, 5])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(10).reshape(2,5), axis=-1)</span>
<span class="sd">            array([0, 5])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(10).reshape(2,5), axis=-1, keepdims=True)</span>
<span class="sd">            array([[0],</span>
<span class="sd">                   [5]])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]))</span>
<span class="sd">            0j</span>

<span class="sd">            &gt;&gt;&gt; min_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=0</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 0.+0.j,  0.+1.j,  2.+1.j])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 1.+0.j,  0.+0.j])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(24).reshape(2,3,4), axis=(1,2))</span>
<span class="sd">            array([ 0, 12])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(24).reshape(2,3,4), axis=(0,2))</span>
<span class="sd">            array([0, 4, 8])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(0,2),</span>
<span class="sd">            ...     keepdims=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[0],</span>
<span class="sd">                    [4],</span>
<span class="sd">                    [8]]])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.arange(24).reshape(2,3,4), axis=(2,0))</span>
<span class="sd">            array([0, 4, 8])</span>

<span class="sd">            &gt;&gt;&gt; min_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(2,0),</span>
<span class="sd">            ...     return_indices=True</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([0, 4, 8]), (array([0, 0, 0]), array([0, 1, 2]), array([0, 0, 0])))</span>

<span class="sd">            &gt;&gt;&gt; min_abs(numpy.array([numpy.nan, -2, 3]))</span>
<span class="sd">            nan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Squish array to ensure all axes to be operated on</span>
    <span class="c"># are at the end in one axis.</span>
    <span class="n">new_array_refolded</span> <span class="o">=</span> <span class="n">squish</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="c"># Add singleton dimensions at the end</span>
    <span class="c"># where the axes to be operated on now is.</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="c"># Get indices for the result and strip off the singleton axis (last dim).</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c"># Get the indices that correspond to argmin for the given axis.</span>
    <span class="n">result_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Make into index array.</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_indices</span><span class="p">)</span>

    <span class="c"># Slice out relevant results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Create a mask.</span>
        <span class="c"># This is required to remap the indices to the old array.</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">result_mask</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">unsquish</span><span class="p">(</span><span class="n">result_mask</span><span class="p">,</span> <span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">result_indices</span> <span class="o">=</span> <span class="n">result_mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result_indices</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="nanmin_abs"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.nanmin_abs">[docs]</a><span class="k">def</span> <span class="nf">nanmin_abs</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the min of the given array subject to the absolute value</span>
<span class="sd">        (magnitude for complex numbers).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to find the min (subject</span>
<span class="sd">                                                 to the absolute value).</span>

<span class="sd">            axis(int):                           desired matches to find.</span>
<span class="sd">            keepdims(bool):                      ensure the number of</span>
<span class="sd">                                                 dimensions is the same by</span>
<span class="sd">                                                 inserting singleton dimensions</span>
<span class="sd">                                                 at all the axes squished</span>
<span class="sd">                                                 (excepting the last one).</span>

<span class="sd">            return_indices(bool):                whether to return the indices</span>
<span class="sd">                                                 of the mins in addition to the</span>
<span class="sd">                                                 mins.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple of numpy.ndarray):            an array or value that is the</span>
<span class="sd">                                                 smallest (subject to the</span>
<span class="sd">                                                 absolute value) or if</span>
<span class="sd">                                                 ``return_indices`` the indices</span>
<span class="sd">                                                 corresponding to the smallest</span>
<span class="sd">                                                 value(s), as well.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.arange(10))</span>
<span class="sd">            0</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.arange(10).reshape(2,5))</span>
<span class="sd">            0</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.arange(10).reshape(2,5), axis=0)</span>
<span class="sd">            array([0, 1, 2, 3, 4])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.arange(10).reshape(2,5), axis=1)</span>
<span class="sd">            array([0, 5])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.arange(10).reshape(2,5), axis=-1)</span>
<span class="sd">            array([0, 5])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(</span>
<span class="sd">            ...     numpy.arange(10).reshape(2,5),</span>
<span class="sd">            ...     axis=-1,</span>
<span class="sd">            ...     keepdims=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0],</span>
<span class="sd">                   [5]])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            0j</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=0</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 0.+0.j,  0.+1.j,  2.+1.j])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 1.+0.j,  0.+0.j])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.arange(24).reshape(2,3,4), axis=(1,2))</span>
<span class="sd">            array([ 0, 12])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.arange(24).reshape(2,3,4), axis=(0,2))</span>
<span class="sd">            array([0, 4, 8])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(0,2),</span>
<span class="sd">            ...     keepdims=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[0],</span>
<span class="sd">                    [4],</span>
<span class="sd">                    [8]]])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(2,0)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([0, 4, 8])</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(2,0),</span>
<span class="sd">            ...     return_indices=True</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([0, 4, 8]), (array([0, 0, 0]), array([0, 1, 2]), array([0, 0, 0])))</span>

<span class="sd">            &gt;&gt;&gt; nanmin_abs(numpy.array([numpy.nan, -2, 3]))</span>
<span class="sd">            -2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Squish array to ensure all axes to be operated on</span>
    <span class="c"># are at the end in one axis.</span>
    <span class="n">new_array_refolded</span> <span class="o">=</span> <span class="n">squish</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="c"># Add singleton dimensions at the end</span>
    <span class="c"># where the axes to be operated on now is.</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="c"># Get indices for the result and strip off the singleton axis (last dim).</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c"># Get the indices that correspond to argmin (ignoring nan)</span>
    <span class="c"># for the given axis.</span>
    <span class="n">result_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bottleneck</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="c"># Make into index array.</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_indices</span><span class="p">)</span>

    <span class="c"># Slice out relevant results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Create a mask.</span>
        <span class="c"># This is required to remap the indices to the old array.</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">result_mask</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">unsquish</span><span class="p">(</span><span class="n">result_mask</span><span class="p">,</span> <span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">result_indices</span> <span class="o">=</span> <span class="n">result_mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result_indices</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="max_abs"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.max_abs">[docs]</a><span class="k">def</span> <span class="nf">max_abs</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the max of the given array subject to the absolute value</span>
<span class="sd">        (magnitude for complex numbers).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to find the max (subject</span>
<span class="sd">                                                 to the absolute value).</span>

<span class="sd">            axis(int):                           desired matches to find.</span>

<span class="sd">            keepdims(bool):                      ensure the number of</span>
<span class="sd">                                                 dimensions is the same by</span>
<span class="sd">                                                 inserting singleton</span>
<span class="sd">                                                 dimensions at all the axes</span>
<span class="sd">                                                 squished (excepting the last</span>
<span class="sd">                                                 one).</span>

<span class="sd">            return_indices(bool):                whether to return the indices</span>
<span class="sd">                                                 of the maxes in addition to</span>
<span class="sd">                                                 the maxes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple of numpy.ndarray):            an array or value that is the</span>
<span class="sd">                                                 largest (subject to the</span>
<span class="sd">                                                 absolute value) or if</span>
<span class="sd">                                                 ``return_indices`` the indices</span>
<span class="sd">                                                 corresponding to the largest</span>
<span class="sd">                                                 value(s), as well.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(10))</span>
<span class="sd">            9</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(10).reshape(2,5))</span>
<span class="sd">            9</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(10).reshape(2,5), axis=0)</span>
<span class="sd">            array([5, 6, 7, 8, 9])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(10).reshape(2,5), axis=1)</span>
<span class="sd">            array([4, 9])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(10).reshape(2,5), axis=-1)</span>
<span class="sd">            array([4, 9])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(10).reshape(2,5), axis=-1, keepdims=True)</span>
<span class="sd">            array([[4],</span>
<span class="sd">                   [9]])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]))</span>
<span class="sd">            (1+3j)</span>

<span class="sd">            &gt;&gt;&gt; max_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=0</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 1.+0.j,  1.+1.j,  1.+3.j])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 2.+1.j,  1.+3.j])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(24).reshape(2,3,4), axis=(1,2))</span>
<span class="sd">            array([11, 23])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(24).reshape(2,3,4), axis=(0,2))</span>
<span class="sd">            array([15, 19, 23])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(0,2),</span>
<span class="sd">            ...     keepdims=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[15],</span>
<span class="sd">                    [19],</span>
<span class="sd">                    [23]]])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.arange(24).reshape(2,3,4), axis=(2,0))</span>
<span class="sd">            array([15, 19, 23])</span>

<span class="sd">            &gt;&gt;&gt; max_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(2,0),</span>
<span class="sd">            ...     return_indices=True</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([15, 19, 23]), (array([1, 1, 1]), array([0, 1, 2]), array([3, 3, 3])))</span>

<span class="sd">            &gt;&gt;&gt; max_abs(numpy.array([numpy.nan, -2, 3]))</span>
<span class="sd">            nan</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Squish array to ensure all axes to be operated on</span>
    <span class="c"># are at the end in one axis.</span>
    <span class="n">new_array_refolded</span> <span class="o">=</span> <span class="n">squish</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="c"># Add singleton dimensions at the end</span>
    <span class="c"># where the axes to be operated on now is.</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="c"># Get indices for the result and strip off the singleton axis (last dim).</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c"># Get the indices that correspond to argmax for the given axis.</span>
    <span class="n">result_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># Make into index array.</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_indices</span><span class="p">)</span>

    <span class="c"># Slice out relevant results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Create a mask.</span>
        <span class="c"># This is required to remap the indices to the old array.</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">result_mask</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">unsquish</span><span class="p">(</span><span class="n">result_mask</span><span class="p">,</span> <span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">result_indices</span> <span class="o">=</span> <span class="n">result_mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result_indices</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="nanmax_abs"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.nanmax_abs">[docs]</a><span class="k">def</span> <span class="nf">nanmax_abs</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_indices</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the max of the given array subject to the absolute value</span>
<span class="sd">        (magnitude for complex numbers).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to find the max (subject</span>
<span class="sd">                                                 to the absolute value).</span>

<span class="sd">            axis(int):                           desired matches to find.</span>

<span class="sd">            keepdims(bool):                      ensure the number of</span>
<span class="sd">                                                 dimensions is the same by</span>
<span class="sd">                                                 inserting singleton dimensions</span>
<span class="sd">                                                 at all the axes squished</span>
<span class="sd">                                                 (excepting the last one).</span>

<span class="sd">            return_indices(bool):                whether to return the indices</span>
<span class="sd">                                                 of the maxes in addition to</span>
<span class="sd">                                                 the maxes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple of numpy.ndarray):            an array or value that is the</span>
<span class="sd">                                                 largest (subject to the</span>
<span class="sd">                                                 absolute value) or if</span>
<span class="sd">                                                 ``return_indices`` the indices</span>
<span class="sd">                                                 corresponding to the largest</span>
<span class="sd">                                                 value(s), as well.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(10))</span>
<span class="sd">            9</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(10).reshape(2,5))</span>
<span class="sd">            9</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(10).reshape(2,5), axis=0)</span>
<span class="sd">            array([5, 6, 7, 8, 9])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(10).reshape(2,5), axis=1)</span>
<span class="sd">            array([4, 9])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(10).reshape(2,5), axis=-1)</span>
<span class="sd">            array([4, 9])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(</span>
<span class="sd">            ...     numpy.arange(10).reshape(2,5),</span>
<span class="sd">            ...     axis=-1,</span>
<span class="sd">            ...     keepdims=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[4],</span>
<span class="sd">                   [9]])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]])</span>
<span class="sd">            ... )</span>
<span class="sd">            (1+3j)</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=0,</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 1.+0.j,  1.+1.j,  1.+3.j])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(</span>
<span class="sd">            ...     numpy.array([[1+0j, 0+1j, 2+1j], [0+0j, 1+1j, 1+3j]]),</span>
<span class="sd">            ...     axis=1,</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 2.+1.j,  1.+3.j])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(24).reshape(2,3,4), axis=(1,2))</span>
<span class="sd">            array([11, 23])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(24).reshape(2,3,4), axis=(0,2))</span>
<span class="sd">            array([15, 19, 23])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(0,2),</span>
<span class="sd">            ...     keepdims=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[15],</span>
<span class="sd">                    [19],</span>
<span class="sd">                    [23]]])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.arange(24).reshape(2,3,4), axis=(2,0))</span>
<span class="sd">            array([15, 19, 23])</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(</span>
<span class="sd">            ...     numpy.arange(24).reshape(2,3,4),</span>
<span class="sd">            ...     axis=(2,0),</span>
<span class="sd">            ...     return_indices=True</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([15, 19, 23]), (array([1, 1, 1]), array([0, 1, 2]), array([3, 3, 3])))</span>

<span class="sd">            &gt;&gt;&gt; nanmax_abs(numpy.array([numpy.nan, -2, 3]))</span>
<span class="sd">            3.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Squish array to ensure all axes to be operated on</span>
    <span class="c"># are at the end in one axis.</span>
    <span class="n">new_array_refolded</span> <span class="o">=</span> <span class="n">squish</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="c"># Add singleton dimensions at the end</span>
    <span class="c"># where the axes to be operated on now is.</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

    <span class="c"># Get indices for the result and strip off the singleton axis (last dim).</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="c"># Get the indices that correspond to argmax</span>
    <span class="c"># (ignoring nan) for the given axis.</span>
    <span class="n">result_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bottleneck</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="c"># Make into index array.</span>
    <span class="n">result_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_indices</span><span class="p">)</span>

    <span class="c"># Slice out relevant results</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">new_array_refolded</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_indices</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Create a mask.</span>
        <span class="c"># This is required to remap the indices to the old array.</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_array_refolded</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">result_mask</span><span class="p">[</span><span class="n">result_indices</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">result_mask</span> <span class="o">=</span> <span class="n">unsquish</span><span class="p">(</span><span class="n">result_mask</span><span class="p">,</span> <span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">result_indices</span> <span class="o">=</span> <span class="n">result_mask</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result_indices</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="array_to_matrix"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.array_to_matrix">[docs]</a><span class="k">def</span> <span class="nf">array_to_matrix</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flattens an array so that the row is the only original shape kept.</span>

<span class="sd">        Args:</span>
<span class="sd">            a(numpy.ndarray):                The array to flatten, partially.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                 The matrix version of the array</span>
<span class="sd">                                             after flattening.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; array_to_matrix(numpy.eye(3))</span>
<span class="sd">            array([[ 1.,  0.,  0.],</span>
<span class="sd">                   [ 0.,  1.,  0.],</span>
<span class="sd">                   [ 0.,  0.,  1.]])</span>

<span class="sd">            &gt;&gt;&gt; array_to_matrix(numpy.arange(24).reshape(4, 3, 2))</span>
<span class="sd">            array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="sd">                   [ 6,  7,  8,  9, 10, 11],</span>
<span class="sd">                   [12, 13, 14, 15, 16, 17],</span>
<span class="sd">                   [18, 19, 20, 21, 22, 23]])</span>

<span class="sd">            &gt;&gt;&gt; array_to_matrix(numpy.arange(24).reshape(4, 6))</span>
<span class="sd">            array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="sd">                   [ 6,  7,  8,  9, 10, 11],</span>
<span class="sd">                   [12, 13, 14, 15, 16, 17],</span>
<span class="sd">                   [18, 19, 20, 21, 22, 23]])</span>

<span class="sd">            &gt;&gt;&gt; array_to_matrix(numpy.zeros((0, 4, 3, 2)))</span>
<span class="sd">            array([], shape=(0, 24), dtype=float64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="index_array_to_bool_array"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.index_array_to_bool_array">[docs]</a><span class="k">def</span> <span class="nf">index_array_to_bool_array</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a bool array mask that has each value from the index array as</span>
<span class="sd">        True. All other values are False. Requires a shape be specified to</span>
<span class="sd">        create the bool array.</span>

<span class="sd">        Args:</span>
<span class="sd">            index_array(numpy.ndarray of ints):     The index array with the</span>
<span class="sd">                                                    indices to use.</span>

<span class="sd">            shape(tuple of ints):                   The shape to give the bool</span>
<span class="sd">                                                    array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                        The bool array with</span>
<span class="sd">                                                    selected indices as True</span>
<span class="sd">                                                    and the rest are False.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; index_array_to_bool_array((numpy.arange(5),), (5,))</span>
<span class="sd">            array([ True,  True,  True,  True,  True], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; index_array_to_bool_array((numpy.arange(1, 4),), (5,))</span>
<span class="sd">            array([False,  True,  True,  True, False], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; index_array_to_bool_array(</span>
<span class="sd">            ...     (numpy.arange(3), numpy.arange(3)), (3, 3)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True, False, False],</span>
<span class="sd">                   [False,  True, False],</span>
<span class="sd">                   [False, False,  True]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bool_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">bool_array</span><span class="p">[</span><span class="n">index_array</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span><span class="p">(</span><span class="n">bool_array</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="expand_view"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.expand_view">[docs]</a><span class="k">def</span> <span class="nf">expand_view</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">reps_after</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(),</span> <span class="n">reps_before</span><span class="o">=</span><span class="nb">tuple</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Behaves like NumPy tile except that it always returns a view and not a</span>
<span class="sd">        copy. Though, it differs in that additional dimensions are added for</span>
<span class="sd">        repetition as opposed to repeating in the same one. Also, it allows</span>
<span class="sd">        repetitions to be specified before or after unlike tile. Though, will</span>
<span class="sd">        behave identical to tile if the keyword is not specified.</span>

<span class="sd">        Uses strides to trick NumPy into providing a view.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to tile.</span>

<span class="sd">            reps_after(tuple):                   repetitions dimension size to</span>
<span class="sd">                                                 add before (if int will turn</span>
<span class="sd">                                                 into tuple).</span>

<span class="sd">            reps_before(tuple):                  repetitions dimension size to</span>
<span class="sd">                                                 add after (if int will turn</span>
<span class="sd">                                                 into tuple).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a view of a numpy array with</span>
<span class="sd">                                                 tiling in various dimension.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; numpy.arange(6).reshape(2,3)</span>
<span class="sd">            array([[0, 1, 2],</span>
<span class="sd">                   [3, 4, 5]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape(2,3))</span>
<span class="sd">            array([[0, 1, 2],</span>
<span class="sd">                   [3, 4, 5]])</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(6).reshape(2,3); a is expand_view(a)</span>
<span class="sd">            False</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape(2,3), 1)</span>
<span class="sd">            array([[[0],</span>
<span class="sd">                    [1],</span>
<span class="sd">                    [2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[3],</span>
<span class="sd">                    [4],</span>
<span class="sd">                    [5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape(2,3), (1,))</span>
<span class="sd">            array([[[0],</span>
<span class="sd">                    [1],</span>
<span class="sd">                    [2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[3],</span>
<span class="sd">                    [4],</span>
<span class="sd">                    [5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape((2,3)), reps_after=1)</span>
<span class="sd">            array([[[0],</span>
<span class="sd">                    [1],</span>
<span class="sd">                    [2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[3],</span>
<span class="sd">                    [4],</span>
<span class="sd">                    [5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape((2,3)), reps_after=(1,))</span>
<span class="sd">            array([[[0],</span>
<span class="sd">                    [1],</span>
<span class="sd">                    [2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[3],</span>
<span class="sd">                    [4],</span>
<span class="sd">                    [5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape((2,3)), reps_before=1)</span>
<span class="sd">            array([[[0, 1, 2],</span>
<span class="sd">                    [3, 4, 5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape((2,3)), reps_before=(1,))</span>
<span class="sd">            array([[[0, 1, 2],</span>
<span class="sd">                    [3, 4, 5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape((2,3)), reps_before=(3,))</span>
<span class="sd">            array([[[0, 1, 2],</span>
<span class="sd">                    [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[0, 1, 2],</span>
<span class="sd">                    [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[0, 1, 2],</span>
<span class="sd">                    [3, 4, 5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape((2,3)), reps_after=(4,))</span>
<span class="sd">            array([[[0, 0, 0, 0],</span>
<span class="sd">                    [1, 1, 1, 1],</span>
<span class="sd">                    [2, 2, 2, 2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[3, 3, 3, 3],</span>
<span class="sd">                    [4, 4, 4, 4],</span>
<span class="sd">                    [5, 5, 5, 5]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(</span>
<span class="sd">            ...     numpy.arange(6).reshape((2,3)),</span>
<span class="sd">            ...     reps_before=(3,),</span>
<span class="sd">            ...     reps_after=(4,)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[0, 0, 0, 0],</span>
<span class="sd">                     [1, 1, 1, 1],</span>
<span class="sd">                     [2, 2, 2, 2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[3, 3, 3, 3],</span>
<span class="sd">                     [4, 4, 4, 4],</span>
<span class="sd">                     [5, 5, 5, 5]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[0, 0, 0, 0],</span>
<span class="sd">                     [1, 1, 1, 1],</span>
<span class="sd">                     [2, 2, 2, 2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[3, 3, 3, 3],</span>
<span class="sd">                     [4, 4, 4, 4],</span>
<span class="sd">                     [5, 5, 5, 5]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[0, 0, 0, 0],</span>
<span class="sd">                     [1, 1, 1, 1],</span>
<span class="sd">                     [2, 2, 2, 2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[3, 3, 3, 3],</span>
<span class="sd">                     [4, 4, 4, 4],</span>
<span class="sd">                     [5, 5, 5, 5]]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(numpy.arange(6).reshape((2,3)), reps_after = (4,3))</span>
<span class="sd">            array([[[[0, 0, 0],</span>
<span class="sd">                     [0, 0, 0],</span>
<span class="sd">                     [0, 0, 0],</span>
<span class="sd">                     [0, 0, 0]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[1, 1, 1],</span>
<span class="sd">                     [1, 1, 1],</span>
<span class="sd">                     [1, 1, 1],</span>
<span class="sd">                     [1, 1, 1]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[2, 2, 2],</span>
<span class="sd">                     [2, 2, 2],</span>
<span class="sd">                     [2, 2, 2],</span>
<span class="sd">                     [2, 2, 2]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[3, 3, 3],</span>
<span class="sd">                     [3, 3, 3],</span>
<span class="sd">                     [3, 3, 3],</span>
<span class="sd">                     [3, 3, 3]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[4, 4, 4],</span>
<span class="sd">                     [4, 4, 4],</span>
<span class="sd">                     [4, 4, 4],</span>
<span class="sd">                     [4, 4, 4]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[5, 5, 5],</span>
<span class="sd">                     [5, 5, 5],</span>
<span class="sd">                     [5, 5, 5],</span>
<span class="sd">                     [5, 5, 5]]]])</span>

<span class="sd">            &gt;&gt;&gt; expand_view(</span>
<span class="sd">            ...     numpy.arange(6).reshape((2,3)),</span>
<span class="sd">            ...     reps_before=(4,3),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[0, 1, 2],</span>
<span class="sd">                     [3, 4, 5]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reps_after</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">reps_after</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps_after</span><span class="p">,)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reps_before</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">reps_before</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps_before</span><span class="p">,)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">stride_tricks</span><span class="o">.</span><span class="n">as_strided</span><span class="p">(</span>
        <span class="n">new_array</span><span class="p">,</span>
        <span class="n">reps_before</span> <span class="o">+</span> <span class="n">new_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">reps_after</span><span class="p">,</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">reps_before</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">new_array</span><span class="o">.</span><span class="n">strides</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">reps_after</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
    <span class="p">))</span>

</div>
<div class="viewcode-block" id="expand_arange"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.expand_arange">[docs]</a><span class="k">def</span> <span class="nf">expand_arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span>
                  <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
                  <span class="n">reps_before</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(),</span>
                  <span class="n">reps_after</span><span class="o">=</span><span class="nb">tuple</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Much like ``numpy.arange`` except that it applies expand_view</span>
<span class="sd">        afterwards to get a view of the same range in a larger hyperrectangle.</span>

<span class="sd">        This is very useful for situations where broadcasting is desired.</span>

<span class="sd">        Args:</span>
<span class="sd">            start(int):                          starting point (or stopping</span>
<span class="sd">                                                 point if only one is</span>
<span class="sd">                                                 specified).</span>

<span class="sd">            stop(int):                           stopping point (if the</span>
<span class="sd">                                                 starting point is specified)</span>
<span class="sd">                                                 (0 by default).</span>

<span class="sd">            step(int):                           size of steps to take between</span>
<span class="sd">                                                 value (1 by default).</span>

<span class="sd">            reps_after(tuple):                   repetitions dimension size to</span>
<span class="sd">                                                 add before (if int will turn</span>
<span class="sd">                                                 into tuple).</span>

<span class="sd">            reps_before(tuple):                  repetitions dimension size to</span>
<span class="sd">                                                 add after (if int will turn</span>
<span class="sd">                                                 into tuple).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a view of a numpy arange with</span>
<span class="sd">                                                 tiling in various dimension.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; expand_arange(3, reps_before=3)</span>
<span class="sd">            array([[0, 1, 2],</span>
<span class="sd">                   [0, 1, 2],</span>
<span class="sd">                   [0, 1, 2]])</span>

<span class="sd">            &gt;&gt;&gt; expand_arange(3, reps_after=3)</span>
<span class="sd">            array([[0, 0, 0],</span>
<span class="sd">                   [1, 1, 1],</span>
<span class="sd">                   [2, 2, 2]])</span>

<span class="sd">            &gt;&gt;&gt; expand_arange(4, reps_before=3)</span>
<span class="sd">            array([[0, 1, 2, 3],</span>
<span class="sd">                   [0, 1, 2, 3],</span>
<span class="sd">                   [0, 1, 2, 3]])</span>

<span class="sd">            &gt;&gt;&gt; expand_arange(4, reps_after=3)</span>
<span class="sd">            array([[0, 0, 0],</span>
<span class="sd">                   [1, 1, 1],</span>
<span class="sd">                   [2, 2, 2],</span>
<span class="sd">                   [3, 3, 3]])</span>

<span class="sd">            &gt;&gt;&gt; expand_arange(4, reps_before=3, reps_after=2)</span>
<span class="sd">            array([[[0, 0],</span>
<span class="sd">                    [1, 1],</span>
<span class="sd">                    [2, 2],</span>
<span class="sd">                    [3, 3]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[0, 0],</span>
<span class="sd">                    [1, 1],</span>
<span class="sd">                    [2, 2],</span>
<span class="sd">                    [3, 3]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[0, 0],</span>
<span class="sd">                    [1, 1],</span>
<span class="sd">                    [2, 2],</span>
<span class="sd">                    [3, 3]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">an_arange</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">an_arange</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span>
        <span class="n">an_arange</span><span class="p">,</span> <span class="n">reps_before</span><span class="o">=</span><span class="n">reps_before</span><span class="p">,</span> <span class="n">reps_after</span><span class="o">=</span><span class="n">reps_after</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">an_arange</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="expand_enumerate"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.expand_enumerate">[docs]</a><span class="k">def</span> <span class="nf">expand_enumerate</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds on expand_arange, which has the same shape as the original</span>
<span class="sd">        array. Specifies the increments to occur along the given axis, which by</span>
<span class="sd">        default is the zeroth axis.</span>

<span class="sd">        Provides mechanisms for changing the starting value and also the</span>
<span class="sd">        increment.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to enumerate</span>

<span class="sd">            axis(int):                           axis to enumerate along (0 by</span>
<span class="sd">                                                 default).</span>
<span class="sd">            start(int):                          starting point (0 by default).</span>

<span class="sd">            step(int):                           size of steps to take between</span>
<span class="sd">                                                 value (1 by default).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a view of a numpy arange with</span>
<span class="sd">                                                 tiling in various dimension.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; expand_enumerate(numpy.ones((4,5)))</span>
<span class="sd">            array([[0, 0, 0, 0, 0],</span>
<span class="sd">                   [1, 1, 1, 1, 1],</span>
<span class="sd">                   [2, 2, 2, 2, 2],</span>
<span class="sd">                   [3, 3, 3, 3, 3]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; expand_enumerate(numpy.ones((4,5)), axis=0)</span>
<span class="sd">            array([[0, 0, 0, 0, 0],</span>
<span class="sd">                   [1, 1, 1, 1, 1],</span>
<span class="sd">                   [2, 2, 2, 2, 2],</span>
<span class="sd">                   [3, 3, 3, 3, 3]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; expand_enumerate(numpy.ones((4,5)), axis=0, start=1)</span>
<span class="sd">            array([[1, 1, 1, 1, 1],</span>
<span class="sd">                   [2, 2, 2, 2, 2],</span>
<span class="sd">                   [3, 3, 3, 3, 3],</span>
<span class="sd">                   [4, 4, 4, 4, 4]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; expand_enumerate(numpy.ones((4,5)), axis=0, start=1, step=2)</span>
<span class="sd">            array([[1, 1, 1, 1, 1],</span>
<span class="sd">                   [3, 3, 3, 3, 3],</span>
<span class="sd">                   [5, 5, 5, 5, 5],</span>
<span class="sd">                   [7, 7, 7, 7, 7]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; expand_enumerate(numpy.ones((4,5)), axis=1)</span>
<span class="sd">            array([[0, 1, 2, 3, 4],</span>
<span class="sd">                   [0, 1, 2, 3, 4],</span>
<span class="sd">                   [0, 1, 2, 3, 4],</span>
<span class="sd">                   [0, 1, 2, 3, 4]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; expand_enumerate(numpy.ones((4,5)), axis=1, start=1)</span>
<span class="sd">            array([[1, 2, 3, 4, 5],</span>
<span class="sd">                   [1, 2, 3, 4, 5],</span>
<span class="sd">                   [1, 2, 3, 4, 5],</span>
<span class="sd">                   [1, 2, 3, 4, 5]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; expand_enumerate(numpy.ones((4,5)), axis=1, start=1, step=2)</span>
<span class="sd">            array([[1, 3, 5, 7, 9],</span>
<span class="sd">                   [1, 3, 5, 7, 9],</span>
<span class="sd">                   [1, 3, 5, 7, 9],</span>
<span class="sd">                   [1, 3, 5, 7, 9]], dtype=uint64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">an_enumeration</span> <span class="o">=</span> <span class="n">expand_arange</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">start</span> <span class="o">+</span> <span class="n">step</span> <span class="o">*</span> <span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span>
        <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">,</span>
        <span class="n">reps_before</span><span class="o">=</span><span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">],</span>
        <span class="n">reps_after</span><span class="o">=</span><span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[(</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">):]</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">an_enumeration</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="enumerate_masks"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.enumerate_masks">[docs]</a><span class="k">def</span> <span class="nf">enumerate_masks</span><span class="p">(</span><span class="n">new_masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a mask stack and replaces them by an enumerated stack. In other</span>
<span class="sd">        words, each mask is replaced by a consecutive integer (starts with 1</span>
<span class="sd">        and proceeds to the length of the given axis (0 by default)).</span>

<span class="sd">        Note:</span>
<span class="sd">            The masks could be recreated by finding the values not equal to</span>
<span class="sd">            zero.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_masks(numpy.ndarray):            masks to enumerate</span>
<span class="sd">            axis(int):                           axis to enumerate along (0 by</span>
<span class="sd">                                                 default).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     an enumerated stack.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; enumerate_masks(numpy.ones((3,3,3), dtype=bool))</span>
<span class="sd">            array([[[1, 1, 1],</span>
<span class="sd">                    [1, 1, 1],</span>
<span class="sd">                    [1, 1, 1]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[2, 2, 2],</span>
<span class="sd">                    [2, 2, 2],</span>
<span class="sd">                    [2, 2, 2]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[3, 3, 3],</span>
<span class="sd">                    [3, 3, 3],</span>
<span class="sd">                    [3, 3, 3]]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; enumerate_masks(</span>
<span class="sd">            ...     numpy.array([[[ True, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False]],</span>
<span class="sd">            ...</span>
<span class="sd">            ...                  [[False, False, False, False],</span>
<span class="sd">            ...                   [False,  True, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False]],</span>
<span class="sd">            ...</span>
<span class="sd">            ...                  [[False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False,  True, False],</span>
<span class="sd">            ...                   [False, False, False, False]],</span>
<span class="sd">            ...</span>
<span class="sd">            ...                  [[False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False,  True]]], dtype=bool)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[1, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[0, 0, 0, 0],</span>
<span class="sd">                    [0, 2, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 3, 0],</span>
<span class="sd">                    [0, 0, 0, 0]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 0],</span>
<span class="sd">                    [0, 0, 0, 4]]], dtype=uint64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_enumerated_masks</span> <span class="o">=</span> <span class="n">new_masks</span> <span class="o">*</span> <span class="n">expand_enumerate</span><span class="p">(</span>
        <span class="n">new_masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_enumerated_masks</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="enumerate_masks_max"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.enumerate_masks_max">[docs]</a><span class="k">def</span> <span class="nf">enumerate_masks_max</span><span class="p">(</span><span class="n">new_masks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a mask stack and replaces them by the max of an enumerated stack.</span>
<span class="sd">        In other words, each mask is replaced by a consecutive integer (starts</span>
<span class="sd">        with 1 and proceeds to the length of the given axis (0 by default)).</span>
<span class="sd">        Afterwards, the max is taken along the given axis. However, a singleton</span>
<span class="sd">        dimension is left on the original axis.</span>

<span class="sd">        Note:</span>
<span class="sd">            The masks could be recreated by finding the values not equal to</span>
<span class="sd">            zero.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_masks(numpy.ndarray):            masks to enumerate</span>

<span class="sd">            axis(int):                           axis to enumerate along (0 by</span>
<span class="sd">                                                 default).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     an enumerated stack.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; enumerate_masks_max(numpy.ones((3,3,3), dtype=bool))</span>
<span class="sd">            array([[[3, 3, 3],</span>
<span class="sd">                    [3, 3, 3],</span>
<span class="sd">                    [3, 3, 3]]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; enumerate_masks_max(</span>
<span class="sd">            ...     numpy.array([[[ True, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False]],</span>
<span class="sd">            ...</span>
<span class="sd">            ...                  [[False, False, False, False],</span>
<span class="sd">            ...                   [False,  True, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False]],</span>
<span class="sd">            ...</span>
<span class="sd">            ...                  [[False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False,  True, False],</span>
<span class="sd">            ...                   [False, False, False, False]],</span>
<span class="sd">            ...</span>
<span class="sd">            ...                  [[False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False, False],</span>
<span class="sd">            ...                   [False, False, False,  True]]], dtype=bool)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[1, 0, 0, 0],</span>
<span class="sd">                    [0, 2, 0, 0],</span>
<span class="sd">                    [0, 0, 3, 0],</span>
<span class="sd">                    [0, 0, 0, 4]]], dtype=uint64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">axis</span> <span class="o">%=</span> <span class="n">new_masks</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">new_enumerated_masks_max</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="n">new_masks</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">new_masks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">new_masks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span>
            <span class="n">new_enumerated_masks_max</span><span class="p">,</span>
            <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">add_singleton_axis_pos</span><span class="p">(</span>
                        <span class="n">index_axis_at_pos</span><span class="p">(</span><span class="n">new_masks</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span>
                        <span class="n">axis</span>
                    <span class="p">),</span>
            <span class="n">out</span><span class="o">=</span><span class="n">new_enumerated_masks_max</span>
        <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_enumerated_masks_max</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="cartesian_product"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.cartesian_product">[docs]</a><span class="k">def</span> <span class="nf">cartesian_product</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes the cartesian product between the elements in each array.</span>

<span class="sd">        Args:</span>
<span class="sd">            arrays(collections.Sequence of numpy.ndarrays):     A sequence of</span>
<span class="sd">                                                                1-D arrays or a</span>
<span class="sd">                                                                2-D array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                                    an array</span>
<span class="sd">                                                                containing the</span>
<span class="sd">                                                                result of the</span>
<span class="sd">                                                                cartesian</span>
<span class="sd">                                                                product of each</span>
<span class="sd">                                                                array.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; cartesian_product([numpy.arange(2), numpy.arange(3)])</span>
<span class="sd">            array([[0, 0],</span>
<span class="sd">                   [0, 1],</span>
<span class="sd">                   [0, 2],</span>
<span class="sd">                   [1, 0],</span>
<span class="sd">                   [1, 1],</span>
<span class="sd">                   [1, 2]])</span>

<span class="sd">            &gt;&gt;&gt; cartesian_product([</span>
<span class="sd">            ...     numpy.arange(2, dtype=float),</span>
<span class="sd">            ...     numpy.arange(3)</span>
<span class="sd">            ... ])</span>
<span class="sd">            array([[ 0.,  0.],</span>
<span class="sd">                   [ 0.,  1.],</span>
<span class="sd">                   [ 0.,  2.],</span>
<span class="sd">                   [ 1.,  0.],</span>
<span class="sd">                   [ 1.,  1.],</span>
<span class="sd">                   [ 1.,  2.]])</span>

<span class="sd">            &gt;&gt;&gt; cartesian_product([</span>
<span class="sd">            ...     numpy.arange(2),</span>
<span class="sd">            ...     numpy.arange(3),</span>
<span class="sd">            ...     numpy.arange(4)</span>
<span class="sd">            ... ])</span>
<span class="sd">            array([[0, 0, 0],</span>
<span class="sd">                   [0, 0, 1],</span>
<span class="sd">                   [0, 0, 2],</span>
<span class="sd">                   [0, 0, 3],</span>
<span class="sd">                   [0, 1, 0],</span>
<span class="sd">                   [0, 1, 1],</span>
<span class="sd">                   [0, 1, 2],</span>
<span class="sd">                   [0, 1, 3],</span>
<span class="sd">                   [0, 2, 0],</span>
<span class="sd">                   [0, 2, 1],</span>
<span class="sd">                   [0, 2, 2],</span>
<span class="sd">                   [0, 2, 3],</span>
<span class="sd">                   [1, 0, 0],</span>
<span class="sd">                   [1, 0, 1],</span>
<span class="sd">                   [1, 0, 2],</span>
<span class="sd">                   [1, 0, 3],</span>
<span class="sd">                   [1, 1, 0],</span>
<span class="sd">                   [1, 1, 1],</span>
<span class="sd">                   [1, 1, 2],</span>
<span class="sd">                   [1, 1, 3],</span>
<span class="sd">                   [1, 2, 0],</span>
<span class="sd">                   [1, 2, 1],</span>
<span class="sd">                   [1, 2, 2],</span>
<span class="sd">                   [1, 2, 3]])</span>

<span class="sd">            &gt;&gt;&gt; cartesian_product(numpy.diag((1, 2, 3)))</span>
<span class="sd">            array([[1, 0, 0],</span>
<span class="sd">                   [1, 0, 0],</span>
<span class="sd">                   [1, 0, 3],</span>
<span class="sd">                   [1, 2, 0],</span>
<span class="sd">                   [1, 2, 0],</span>
<span class="sd">                   [1, 2, 3],</span>
<span class="sd">                   [1, 0, 0],</span>
<span class="sd">                   [1, 0, 0],</span>
<span class="sd">                   [1, 0, 3],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 3],</span>
<span class="sd">                   [0, 2, 0],</span>
<span class="sd">                   [0, 2, 0],</span>
<span class="sd">                   [0, 2, 3],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 3],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 3],</span>
<span class="sd">                   [0, 2, 0],</span>
<span class="sd">                   [0, 2, 0],</span>
<span class="sd">                   [0, 2, 3],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [0, 0, 3]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">arrays</span><span class="p">[</span>
                <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s">&quot;Must provide only 1D arrays to this function or a single 2D array.&quot;</span>

    <span class="n">array_shapes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)))</span>

    <span class="n">result_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">result_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">array_shapes</span><span class="p">)</span>
    <span class="n">result_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result_shape</span><span class="p">)</span>

    <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">(</span>
        <span class="p">[</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">result_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])],</span> <span class="p">[]</span>
    <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">result_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">repeated_array_i</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span>
            <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">reps_before</span><span class="o">=</span><span class="n">array_shapes</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span>
            <span class="n">reps_after</span><span class="o">=</span><span class="n">array_shapes</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">repeated_array_i_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">repeated_array_i</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">repeated_array_i_j</span>

    <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="truncate_masked_frames"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.truncate_masked_frames">[docs]</a><span class="k">def</span> <span class="nf">truncate_masked_frames</span><span class="p">(</span><span class="n">shifted_frames</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes frames that have been shifted and truncates out the portion,</span>
<span class="sd">        which is an intact rectangular shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            shifted_frames(numpy.ma.masked_array):      Image stack to register</span>
<span class="sd">                                                        (time is the first</span>
<span class="sd">                                                        dimension uses C-order</span>
<span class="sd">                                                        tyx or tzyx).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                            an array containing a</span>
<span class="sd">                                                        subsection of the stack</span>
<span class="sd">                                                        that has no mask.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.arange(60).reshape(3,5,4)</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.ma.masked_array(</span>
<span class="sd">            ...     a, mask=numpy.zeros(a.shape, dtype=bool), shrink=False</span>
<span class="sd">            ... )</span>
<span class="sd">            &gt;&gt;&gt; a[0, :1, :] = numpy.ma.masked; a[0, :, -1:] = numpy.ma.masked</span>
<span class="sd">            &gt;&gt;&gt; a[1, :2, :] = numpy.ma.masked; a[1, :, :0] = numpy.ma.masked</span>
<span class="sd">            &gt;&gt;&gt; a[2, :0, :] = numpy.ma.masked; a[2, :, :1] = numpy.ma.masked</span>
<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[[-- -- -- --]</span>
<span class="sd">              [4 5 6 --]</span>
<span class="sd">              [8 9 10 --]</span>
<span class="sd">              [12 13 14 --]</span>
<span class="sd">              [16 17 18 --]]</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [[-- -- -- --]</span>
<span class="sd">              [-- -- -- --]</span>
<span class="sd">              [28 29 30 31]</span>
<span class="sd">              [32 33 34 35]</span>
<span class="sd">              [36 37 38 39]]</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [[-- 41 42 43]</span>
<span class="sd">              [-- 45 46 47]</span>
<span class="sd">              [-- 49 50 51]</span>
<span class="sd">              [-- 53 54 55]</span>
<span class="sd">              [-- 57 58 59]]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             [[[ True  True  True  True]</span>
<span class="sd">              [False False False  True]</span>
<span class="sd">              [False False False  True]</span>
<span class="sd">              [False False False  True]</span>
<span class="sd">              [False False False  True]]</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [[ True  True  True  True]</span>
<span class="sd">              [ True  True  True  True]</span>
<span class="sd">              [False False False False]</span>
<span class="sd">              [False False False False]</span>
<span class="sd">              [False False False False]]</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [[ True False False False]</span>
<span class="sd">              [ True False False False]</span>
<span class="sd">              [ True False False False]</span>
<span class="sd">              [ True False False False]</span>
<span class="sd">              [ True False False False]]],</span>
<span class="sd">                   fill_value = 999999)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; truncate_masked_frames(a)</span>
<span class="sd">            array([[[ 9, 10],</span>
<span class="sd">                    [13, 14],</span>
<span class="sd">                    [17, 18]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[29, 30],</span>
<span class="sd">                    [33, 34],</span>
<span class="sd">                    [37, 38]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[49, 50],</span>
<span class="sd">                    [53, 54],</span>
<span class="sd">                    [57, 58]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Find the mask to slice out the relevant data from all frames</span>
    <span class="n">shifted_frames_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">shifted_frames</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c"># Find the shape</span>
    <span class="n">shifted_frames_mask_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shifted_frames_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">_i</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">shifted_frames_mask</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">shifted_frames_mask_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shifted_frames</span><span class="p">),)</span> <span class="o">+</span> <span class="n">shifted_frames_mask_shape</span>

    <span class="c"># Assert that this is an acceptable mask</span>
    <span class="c">#shifted_frames_mask_upper_offset = tuple(</span>
    <span class="c">#    (shifted_frames_mask.sum(axis=_i) != 0).argmax() for _i in reversed(xrange(shifted_frames_mask.ndim))</span>
    <span class="c">#)</span>
    <span class="c">#shifted_frames_mask_lower_offset = tuple(</span>
    <span class="c">#    numpy.array(shifted_frames_mask.shape) - \</span>
    <span class="c">#    numpy.array(shifted_frames_mask_shape[1:]) - \</span>
    <span class="c">#    numpy.array(shifted_frames_mask_upper_offset)</span>
    <span class="c">#)</span>
    <span class="c">#</span>
    <span class="c">#shifted_frames_mask_reconstructed = numpy.pad(</span>
    <span class="c">#    numpy.ones(shifted_frames_mask_shape[1:], dtype=bool),</span>
    <span class="c">#    [(_d, _e) for _d, _e in itertools.izip(shifted_frames_mask_upper_offset, shifted_frames_mask_lower_offset)],</span>
    <span class="c">#    &quot;constant&quot;</span>
    <span class="c">#)</span>
    <span class="c">#assert(</span>
    <span class="c">#    (shifted_frames_mask_reconstructed == shifted_frames_mask).all(),</span>
    <span class="c">#    &quot;The masked array provide has a mask that does not reduce to a square when max projected.&quot;</span>
    <span class="c">#)</span>

    <span class="c"># Slice out the relevant data from the frames</span>
    <span class="n">truncated_shifted_frames</span> <span class="o">=</span> <span class="n">shifted_frames</span><span class="p">[:,</span> <span class="n">shifted_frames_mask</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">shifted_frames_mask_shape</span>
    <span class="p">)</span>
    <span class="n">truncated_shifted_frames</span> <span class="o">=</span> <span class="n">truncated_shifted_frames</span><span class="o">.</span><span class="n">data</span>

    <span class="k">return</span><span class="p">(</span><span class="n">truncated_shifted_frames</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="all_permutations_operation"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.all_permutations_operation">[docs]</a><span class="k">def</span> <span class="nf">all_permutations_operation</span><span class="p">(</span><span class="n">new_op</span><span class="p">,</span> <span class="n">new_array_1</span><span class="p">,</span> <span class="n">new_array_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes two arrays and constructs a new array that contains the result</span>
<span class="sd">        of new_op on every permutation of elements in each array (like</span>
<span class="sd">        broadcasting).</span>

<span class="sd">        Suppose that new_result contained the result, then one would find that</span>
<span class="sd">        the result of the following operation on the specific indices.</span>

<span class="sd">        new_op( new_array_1[ i_1_1, i_1_2, ... ],</span>
<span class="sd">        new_array_2[ i_2_1, i_2_2, ... ] )</span>

<span class="sd">        would be found in new_result as shown</span>

<span class="sd">        new_result[ i_1_1, i_1_2, ..., i_2_1, i_2_2, ... ]</span>


<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to add the singleton</span>
<span class="sd">                                                 axis to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a numpy array with the</span>
<span class="sd">                                                 singleton axis added at the</span>
<span class="sd">                                                 end.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; all_permutations_operation(</span>
<span class="sd">            ...     operator.add, numpy.ones((1,3)), numpy.eye(2)</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (1, 3, 2, 2)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_operation(</span>
<span class="sd">            ...     operator.add, numpy.ones((2,2)), numpy.eye(2)</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (2, 2, 2, 2)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_operation(</span>
<span class="sd">            ...     operator.add, numpy.ones((2,2)), numpy.eye(2)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[ 2.,  1.],</span>
<span class="sd">                     [ 1.,  2.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 2.,  1.],</span>
<span class="sd">                     [ 1.,  2.]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[ 2.,  1.],</span>
<span class="sd">                     [ 1.,  2.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 2.,  1.],</span>
<span class="sd">                     [ 1.,  2.]]]])</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_operation(</span>
<span class="sd">            ...     operator.sub, numpy.ones((2,2)), numpy.eye(2)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[ 0.,  1.],</span>
<span class="sd">                     [ 1.,  0.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 0.,  1.],</span>
<span class="sd">                     [ 1.,  0.]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[ 0.,  1.],</span>
<span class="sd">                     [ 1.,  0.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 0.,  1.],</span>
<span class="sd">                     [ 1.,  0.]]]])</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_operation(</span>
<span class="sd">            ...     operator.sub, numpy.ones((2,2)), numpy.fliplr(numpy.eye(2))</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[ 1.,  0.],</span>
<span class="sd">                     [ 0.,  1.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 1.,  0.],</span>
<span class="sd">                     [ 0.,  1.]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[ 1.,  0.],</span>
<span class="sd">                     [ 0.,  1.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ 1.,  0.],</span>
<span class="sd">                     [ 0.,  1.]]]])</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_operation(</span>
<span class="sd">            ...     operator.sub, numpy.zeros((2,2)), numpy.eye(2)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[-1.,  0.],</span>
<span class="sd">                     [ 0., -1.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[-1.,  0.],</span>
<span class="sd">                     [ 0., -1.]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[-1.,  0.],</span>
<span class="sd">                     [ 0., -1.]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[-1.,  0.],</span>
<span class="sd">                     [ 0., -1.]]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_array_1_tiled</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span><span class="n">new_array_1</span><span class="p">,</span> <span class="n">reps_after</span><span class="o">=</span><span class="n">new_array_2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">new_array_2_tiled</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span><span class="n">new_array_2</span><span class="p">,</span> <span class="n">reps_before</span><span class="o">=</span><span class="n">new_array_1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_op</span><span class="p">(</span><span class="n">new_array_1_tiled</span><span class="p">,</span> <span class="n">new_array_2_tiled</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="all_permutations_equal"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.all_permutations_equal">[docs]</a><span class="k">def</span> <span class="nf">all_permutations_equal</span><span class="p">(</span><span class="n">new_array_1</span><span class="p">,</span> <span class="n">new_array_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes two arrays and constructs a new array that contains the result</span>
<span class="sd">        of equality comparison on every permutation of elements in each array</span>
<span class="sd">        (like broadcasting).</span>

<span class="sd">        Suppose that new_result contained the result, then one would find that</span>
<span class="sd">        the result of the following operation on the specific indices</span>

<span class="sd">        new_op( new_array_1[ i_1_1, i_1_2, ... ],</span>
<span class="sd">        new_array_2[ i_2_1, i_2_2, ... ] )</span>

<span class="sd">        would be found in new_result as shown</span>

<span class="sd">        new_result[ i_1_1, i_1_2, ..., i_2_1, i_2_2, ... ]</span>


<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):            array to add the singleton</span>
<span class="sd">                                                 axis to.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                     a numpy array with the</span>
<span class="sd">                                                 singleton axis added at the</span>
<span class="sd">                                                 end.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; all_permutations_equal(numpy.ones((1,3)), numpy.eye(2)).shape</span>
<span class="sd">            (1, 3, 2, 2)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_equal(numpy.ones((2,2)), numpy.eye(2)).shape</span>
<span class="sd">            (2, 2, 2, 2)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_equal(numpy.ones((2,2)), numpy.eye(2))</span>
<span class="sd">            array([[[[ True, False],</span>
<span class="sd">                     [False,  True]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ True, False],</span>
<span class="sd">                     [False,  True]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[ True, False],</span>
<span class="sd">                     [False,  True]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[ True, False],</span>
<span class="sd">                     [False,  True]]]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_equal(</span>
<span class="sd">            ...     numpy.ones((2,2)), numpy.fliplr(numpy.eye(2))</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[False,  True],</span>
<span class="sd">                     [ True, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False,  True],</span>
<span class="sd">                     [ True, False]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[False,  True],</span>
<span class="sd">                     [ True, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False,  True],</span>
<span class="sd">                     [ True, False]]]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_equal(numpy.zeros((2,2)), numpy.eye(2))</span>
<span class="sd">            array([[[[False,  True],</span>
<span class="sd">                     [ True, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False,  True],</span>
<span class="sd">                     [ True, False]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[False,  True],</span>
<span class="sd">                     [ True, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False,  True],</span>
<span class="sd">                     [ True, False]]]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_equal(numpy.zeros((2,2)), numpy.eye(3))</span>
<span class="sd">            array([[[[False,  True,  True],</span>
<span class="sd">                     [ True, False,  True],</span>
<span class="sd">                     [ True,  True, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False,  True,  True],</span>
<span class="sd">                     [ True, False,  True],</span>
<span class="sd">                     [ True,  True, False]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[False,  True,  True],</span>
<span class="sd">                     [ True, False,  True],</span>
<span class="sd">                     [ True,  True, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False,  True,  True],</span>
<span class="sd">                     [ True, False,  True],</span>
<span class="sd">                     [ True,  True, False]]]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; all_permutations_equal(</span>
<span class="sd">            ...     numpy.arange(4).reshape((2,2)),</span>
<span class="sd">            ...     numpy.arange(2,6).reshape((2,2))</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[[False, False],</span>
<span class="sd">                     [False, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False, False],</span>
<span class="sd">                     [False, False]]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[[ True, False],</span>
<span class="sd">                     [False, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                    [[False,  True],</span>
<span class="sd">                     [False, False]]]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">all_permutations_operation</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="n">new_array_1</span><span class="p">,</span> <span class="n">new_array_2</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="NotNumPyStructuredArrayType"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.NotNumPyStructuredArrayType">[docs]</a><span class="k">class</span> <span class="nc">NotNumPyStructuredArrayType</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Designed for being thrown if a NumPy Structured Array is received.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="numpy_structured_array_dtype_generator"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.numpy_structured_array_dtype_generator">[docs]</a><span class="k">def</span> <span class="nf">numpy_structured_array_dtype_generator</span><span class="p">(</span><span class="n">new_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a NumPy structured array and returns a generator that goes over</span>
<span class="sd">        each name in the structured array and yields the name, type, and shape</span>
<span class="sd">        (for the given name).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):       the array to get the info dtype</span>
<span class="sd">                                            from.</span>

<span class="sd">        Raises:</span>
<span class="sd">            (NotNumPyStructuredArrayType):  if it is a normal NumPy array.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (iterator):                     An iterator yielding tuples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Test to see if this is a NumPy Structured Array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">new_array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span> <span class="k">raise</span> <span class="n">NotNumPyStructuredArrayType</span><span class="p">(</span>
        <span class="s">&quot;Not a NumPy structured array.&quot;</span>
    <span class="p">)</span>

    <span class="c"># Go through each name</span>
    <span class="k">for</span> <span class="n">each_name</span> <span class="ow">in</span> <span class="n">new_array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="c"># Get the type (want the actual type, not a str or dtype object)</span>
        <span class="n">each_dtype</span> <span class="o">=</span> <span class="n">new_array</span><span class="p">[</span><span class="n">each_name</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
        <span class="c"># Get the shape (will be an empty tuple if no shape, which numpy.dtype</span>
        <span class="c"># accepts)</span>
        <span class="n">each_shape</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">each_name</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">yield</span> <span class="p">((</span><span class="n">each_name</span><span class="p">,</span> <span class="n">each_dtype</span><span class="p">,</span> <span class="n">each_shape</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="numpy_structured_array_dtype_list"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.numpy_structured_array_dtype_list">[docs]</a><span class="k">def</span> <span class="nf">numpy_structured_array_dtype_list</span><span class="p">(</span><span class="n">new_array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes any NumPy array and returns either a list for a NumPy structured</span>
<span class="sd">        array via numpy_structured_array_dtype_generator or if it is a normal</span>
<span class="sd">        NumPy array it returns the type used.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):       the array to get the dtype info</span>
<span class="sd">                                            from.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (list or type):                 something that can be given to</span>
<span class="sd">                                            numpy.dtype to obtain the</span>
<span class="sd">                                            new_array.dtype, but is more</span>
<span class="sd">                                            malleable than a numpy.dtype.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">numpy_structured_array_dtype_generator</span><span class="p">(</span><span class="n">new_array</span><span class="p">)))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="blocks_split"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.blocks_split">[docs]</a><span class="k">def</span> <span class="nf">blocks_split</span><span class="p">(</span><span class="n">space_shape</span><span class="p">,</span> <span class="n">block_shape</span><span class="p">,</span> <span class="n">block_halo</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of slicings to cut each block out of an array or other.</span>

<span class="sd">        Takes an array with ``space_shape`` and ``block_shape`` for every</span>
<span class="sd">        dimension and a ``block_halo`` to extend each block on each side. From</span>
<span class="sd">        this, it can compute slicings to use for cutting each block out from</span>
<span class="sd">        the original array, HDF5 dataset or other.</span>

<span class="sd">        Note:</span>
<span class="sd">            Blocks on the boundary that cannot extend the full range will</span>
<span class="sd">            be truncated to the largest block that will fit. This will raise</span>
<span class="sd">            a warning, which can be converted to an exception, if needed.</span>

<span class="sd">        Args:</span>
<span class="sd">            space_shape(numpy.ndarray):    Shape of array to slice</span>
<span class="sd">            block_shape(numpy.ndarray):    Size of each block to take</span>
<span class="sd">            block_halo(numpy.ndarray):     Halo to tack on to each block</span>

<span class="sd">        Returns:</span>
<span class="sd">            collections.Sequence of \</span>
<span class="sd">            tuples of slices:              Provides tuples of slices for \</span>
<span class="sd">                                           retrieving blocks.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; blocks_split(</span>
<span class="sd">            ...     (2,), (1,)</span>
<span class="sd">            ... )  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            ([(slice(0, 1, 1),), (slice(1, 2, 1),)],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 1, 1),), (slice(1, 2, 1),)],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 1, 1),), (slice(0, 1, 1),)])</span>

<span class="sd">            &gt;&gt;&gt; blocks_split(</span>
<span class="sd">            ...     (2, 3,), (1, 1,)</span>
<span class="sd">            ... )  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            ([(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(2, 3, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(2, 3, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(2, 3, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(2, 3, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1))])</span>

<span class="sd">            &gt;&gt;&gt; blocks_split(</span>
<span class="sd">            ...     (2, 3,), (1, 1,), (0, 0,)</span>
<span class="sd">            ... )  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            ([(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(2, 3, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(2, 3, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(2, 3, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(2, 3, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(0, 1, 1))])</span>

<span class="sd">            &gt;&gt;&gt; blocks_split(</span>
<span class="sd">            ...     (2, 3,), (1, 1,), (1, 1,)</span>
<span class="sd">            ... )  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            ([(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(2, 3, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(2, 3, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 2, 1), slice(0, 2, 1)),</span>
<span class="sd">              (slice(0, 2, 1), slice(0, 3, 1)),</span>
<span class="sd">              (slice(0, 2, 1), slice(1, 3, 1)),</span>
<span class="sd">              (slice(0, 2, 1), slice(0, 2, 1)),</span>
<span class="sd">              (slice(0, 2, 1), slice(0, 3, 1)),</span>
<span class="sd">              (slice(0, 2, 1), slice(1, 3, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 1, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(0, 1, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(0, 1, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(1, 2, 1)),</span>
<span class="sd">              (slice(1, 2, 1), slice(1, 2, 1))])</span>


<span class="sd">            &gt;&gt;&gt; blocks_split(</span>
<span class="sd">            ...     (10, 12,), (3, 2,), (4, 3,)</span>
<span class="sd">            ... )  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            ([(slice(0, 3, 1), slice(0, 2, 1)),</span>
<span class="sd">              (slice(0, 3, 1), slice(2, 4, 1)),</span>
<span class="sd">              (slice(0, 3, 1), slice(4, 6, 1)),</span>
<span class="sd">              (slice(0, 3, 1), slice(6, 8, 1)),</span>
<span class="sd">              (slice(0, 3, 1), slice(8, 10, 1)),</span>
<span class="sd">              (slice(0, 3, 1), slice(10, 12, 1)),</span>
<span class="sd">              (slice(3, 6, 1), slice(0, 2, 1)),</span>
<span class="sd">              (slice(3, 6, 1), slice(2, 4, 1)),</span>
<span class="sd">              (slice(3, 6, 1), slice(4, 6, 1)),</span>
<span class="sd">              (slice(3, 6, 1), slice(6, 8, 1)),</span>
<span class="sd">              (slice(3, 6, 1), slice(8, 10, 1)),</span>
<span class="sd">              (slice(3, 6, 1), slice(10, 12, 1)),</span>
<span class="sd">              (slice(6, 9, 1), slice(0, 2, 1)),</span>
<span class="sd">              (slice(6, 9, 1), slice(2, 4, 1)),</span>
<span class="sd">              (slice(6, 9, 1), slice(4, 6, 1)),</span>
<span class="sd">              (slice(6, 9, 1), slice(6, 8, 1)),</span>
<span class="sd">              (slice(6, 9, 1), slice(8, 10, 1)),</span>
<span class="sd">              (slice(6, 9, 1), slice(10, 12, 1)),</span>
<span class="sd">              (slice(9, 12, 1), slice(0, 2, 1)),</span>
<span class="sd">              (slice(9, 12, 1), slice(2, 4, 1)),</span>
<span class="sd">              (slice(9, 12, 1), slice(4, 6, 1)),</span>
<span class="sd">              (slice(9, 12, 1), slice(6, 8, 1)),</span>
<span class="sd">              (slice(9, 12, 1), slice(8, 10, 1)),</span>
<span class="sd">              (slice(9, 12, 1), slice(10, 12, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">             [(slice(0, 7, 1), slice(0, 5, 1)),</span>
<span class="sd">              (slice(0, 7, 1), slice(0, 7, 1)),</span>
<span class="sd">              (slice(0, 7, 1), slice(1, 9, 1)),</span>
<span class="sd">              (slice(0, 7, 1), slice(3, 11, 1)),</span>
<span class="sd">              (slice(0, 7, 1), slice(5, 12, 1)),</span>
<span class="sd">              (slice(0, 7, 1), slice(7, 12, 1)),</span>
<span class="sd">              (slice(0, 10, 1), slice(0, 5, 1)),</span>
<span class="sd">              (slice(0, 10, 1), slice(0, 7, 1)),</span>
<span class="sd">              (slice(0, 10, 1), slice(1, 9, 1)),</span>
<span class="sd">              (slice(0, 10, 1), slice(3, 11, 1)),</span>
<span class="sd">              (slice(0, 10, 1), slice(5, 12, 1)),</span>
<span class="sd">              (slice(0, 10, 1), slice(7, 12, 1)),</span>
<span class="sd">              (slice(2, 10, 1), slice(0, 5, 1)),</span>
<span class="sd">              (slice(2, 10, 1), slice(0, 7, 1)),</span>
<span class="sd">              (slice(2, 10, 1), slice(1, 9, 1)),</span>
<span class="sd">              (slice(2, 10, 1), slice(3, 11, 1)),</span>
<span class="sd">              (slice(2, 10, 1), slice(5, 12, 1)),</span>
<span class="sd">              (slice(2, 10, 1), slice(7, 12, 1)),</span>
<span class="sd">              (slice(5, 10, 1), slice(0, 5, 1)),</span>
<span class="sd">              (slice(5, 10, 1), slice(0, 7, 1)),</span>
<span class="sd">              (slice(5, 10, 1), slice(1, 9, 1)),</span>
<span class="sd">              (slice(5, 10, 1), slice(3, 11, 1)),</span>
<span class="sd">              (slice(5, 10, 1), slice(5, 12, 1)),</span>
<span class="sd">              (slice(5, 10, 1), slice(7, 12, 1))],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">              [(slice(0, 3, 1), slice(0, 2, 1)),</span>
<span class="sd">               (slice(0, 3, 1), slice(2, 4, 1)),</span>
<span class="sd">               (slice(0, 3, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(0, 3, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(0, 3, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(0, 3, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(3, 6, 1), slice(0, 2, 1)),</span>
<span class="sd">               (slice(3, 6, 1), slice(2, 4, 1)),</span>
<span class="sd">               (slice(3, 6, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(3, 6, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(3, 6, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(3, 6, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(0, 2, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(2, 4, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(0, 2, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(2, 4, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1)),</span>
<span class="sd">               (slice(4, 7, 1), slice(3, 5, 1))])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">space_shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">space_shape</span><span class="p">)</span>
    <span class="n">block_shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">block_halo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">block_halo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">block_halo</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span><span class="n">space_shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">block_shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">block_halo</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>\
            <span class="s">&quot;There should be no more than 1 dimension for &quot;</span> <span class="o">+</span> \
            <span class="s">&quot;`space_shape`, `block_shape`, and `block_halo`.&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_halo</span><span class="p">)),</span> \
            <span class="s">&quot;The dimensions of `space_shape`, `block_shape`, and &quot;</span> <span class="o">+</span> \
            <span class="s">&quot;`block_halo` should be the same.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">space_shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">block_shape</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> \
            <span class="s">&quot;There should be no more than 1 dimension for &quot;</span> <span class="o">+</span> \
            <span class="s">&quot;`space_shape` and `block_shape`.&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_shape</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">block_shape</span><span class="p">)),</span> \
            <span class="s">&quot;The dimensions of `space_shape` and `block_shape` &quot;</span> <span class="o">+</span> \
            <span class="s">&quot;should be the same.&quot;</span>

        <span class="n">block_halo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">space_shape</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">uneven_block_division</span> <span class="o">=</span> <span class="p">(</span><span class="n">space_shape</span> <span class="o">%</span> <span class="n">block_shape</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">uneven_block_division</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">uneven_block_division_str</span> <span class="o">=</span> <span class="n">uneven_block_division</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">uneven_block_division_str</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">uneven_block_division_str</span><span class="p">]</span>
        <span class="n">uneven_block_division_str</span> <span class="o">=</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">uneven_block_division_str</span><span class="p">)</span>

        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s">&quot;Blocks will not evenly divide the array.&quot;</span> <span class="o">+</span>
            <span class="s">&quot; The following dimensions will be unevenly divided: </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">%</span>
            <span class="n">uneven_block_division_str</span><span class="p">,</span>
            <span class="ne">RuntimeWarning</span>
        <span class="p">)</span>

    <span class="n">ranges_per_dim</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">haloed_ranges_per_dim</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">trimmed_halos_per_dim</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">each_dim</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">space_shape</span><span class="p">)):</span>
        <span class="c"># Construct each block using the block size given. Allow to spill over.</span>
        <span class="n">a_range</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">space_shape</span><span class="p">[</span><span class="n">each_dim</span><span class="p">],</span> <span class="n">block_shape</span><span class="p">[</span><span class="n">each_dim</span><span class="p">])</span>
        <span class="n">a_range</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span><span class="n">a_range</span><span class="p">,</span> <span class="n">reps_before</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">a_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">block_shape</span><span class="p">[</span><span class="n">each_dim</span><span class="p">]</span>

        <span class="c"># Add the halo to each block on both sides</span>
        <span class="n">a_range_haloed</span> <span class="o">=</span> <span class="n">a_range</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">a_range_haloed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">block_halo</span><span class="p">[</span><span class="n">each_dim</span><span class="p">]</span>
        <span class="n">a_range_haloed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">block_halo</span><span class="p">[</span><span class="n">each_dim</span><span class="p">]</span>
        <span class="n">a_range_haloed</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">space_shape</span><span class="p">[</span><span class="n">each_dim</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">a_range_haloed</span><span class="p">)</span>

        <span class="c"># Clip each block to the boundaries</span>
        <span class="n">a_trimmed_halo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a_range</span><span class="p">)</span>
        <span class="n">a_trimmed_halo</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">a_range</span> <span class="o">-</span> <span class="n">a_range_haloed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># Transpose to allow for iteration over each block&#39;s dimension</span>
        <span class="n">a_range</span> <span class="o">=</span> <span class="n">a_range</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">a_range_haloed</span> <span class="o">=</span> <span class="n">a_range_haloed</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">a_trimmed_halo</span> <span class="o">=</span> <span class="n">a_trimmed_halo</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c"># Convert all ranges to slices for easier use.</span>
        <span class="n">a_range</span> <span class="o">=</span> <span class="n">iters</span><span class="o">.</span><span class="n">reformat_slices</span><span class="p">([</span>
            <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">a_range</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_range</span><span class="p">))</span>
        <span class="p">])</span>
        <span class="n">a_range_haloed</span> <span class="o">=</span> <span class="n">iters</span><span class="o">.</span><span class="n">reformat_slices</span><span class="p">([</span>
            <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">a_range_haloed</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_range_haloed</span><span class="p">))</span>
        <span class="p">])</span>
        <span class="n">a_trimmed_halo</span> <span class="o">=</span> <span class="n">iters</span><span class="o">.</span><span class="n">reformat_slices</span><span class="p">([</span>
            <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">a_trimmed_halo</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_trimmed_halo</span><span class="p">))</span>
        <span class="p">])</span>

        <span class="c"># Collect all blocks</span>
        <span class="n">ranges_per_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_range</span><span class="p">)</span>
        <span class="n">haloed_ranges_per_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_range_haloed</span><span class="p">)</span>
        <span class="n">trimmed_halos_per_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a_trimmed_halo</span><span class="p">)</span>

    <span class="c"># Take all combinations of all ranges to get blocks.</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">ranges_per_dim</span><span class="p">))</span>
    <span class="n">haloed_blocks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">haloed_ranges_per_dim</span><span class="p">))</span>
    <span class="n">trimmed_halos</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">trimmed_halos_per_dim</span><span class="p">))</span>

    <span class="k">return</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="n">haloed_blocks</span><span class="p">,</span> <span class="n">trimmed_halos</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="dot_product"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.dot_product">[docs]</a><span class="k">def</span> <span class="nf">dot_product</span><span class="p">(</span><span class="n">new_vector_set_1</span><span class="p">,</span> <span class="n">new_vector_set_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the dot product between the two pairs of vectors from each</span>
<span class="sd">        set.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set_1(numpy.ndarray):      first set of vectors.</span>
<span class="sd">            new_vector_set_2(numpy.ndarray):      second set of vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the distances</span>
<span class="sd">                                                  between each pair of vectors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; (dot_product(numpy.eye(2), numpy.eye(2)) == numpy.eye(2)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; (dot_product(numpy.eye(10), numpy.eye(10)) == numpy.eye(10)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; dot_product(numpy.array([[ 1,  0]]), numpy.array([[ 1,  0]]))</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product(numpy.array([[ 1,  0]]), numpy.array([[ 0,  1]]))</span>
<span class="sd">            array([[ 0.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product(numpy.array([[ 1,  0]]), numpy.array([[-1,  0]]))</span>
<span class="sd">            array([[-1.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product(numpy.array([[ 1,  0]]), numpy.array([[ 0, -1]]))</span>
<span class="sd">            array([[ 0.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product(numpy.array([[ 1,  0]]), numpy.array([[ 1,  1]]))</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product(</span>
<span class="sd">            ...     numpy.array([[ True,  False]]),</span>
<span class="sd">            ...     numpy.array([[ True,  True]])</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_vector_set_1_float</span> <span class="o">=</span> <span class="n">new_vector_set_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">new_vector_set_2_float</span> <span class="o">=</span> <span class="n">new_vector_set_2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c"># Measure the dot product between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_dot_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">new_vector_set_1_float</span><span class="p">,</span> <span class="n">new_vector_set_2_float</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">vector_pairs_dot_product</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="pair_dot_product"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.pair_dot_product">[docs]</a><span class="k">def</span> <span class="nf">pair_dot_product</span><span class="p">(</span><span class="n">new_vector_set</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the dot product between the vectors in the set.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set(numpy.ndarray):        set of vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the distances</span>
<span class="sd">                                                  between each pair of vectors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; (pair_dot_product(numpy.eye(2)) == numpy.eye(2)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; (pair_dot_product(numpy.eye(10)) == numpy.eye(10)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product(numpy.array([[ 1,  0]]))</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product(numpy.array([[ 1.,  0.]]))</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product(numpy.array([[-1,  0]]))</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product(numpy.array([[ 0,  1]]))</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product(numpy.array([[ 1,  1]]))</span>
<span class="sd">            array([[ 2.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product(numpy.array([[ True,  False]]))</span>
<span class="sd">            array([[ 1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">dot_product</span><span class="p">(</span><span class="n">new_vector_set</span><span class="p">,</span> <span class="n">new_vector_set</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">new_vector_set</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the norm of a vector or a set of vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set(numpy.ndarray):        either a single vector or a</span>
<span class="sd">                                                  set of vectors (matrix).</span>

<span class="sd">            ord(optional):                        basically the same arguments</span>
<span class="sd">                                                  as numpy.linalg.norm</span>
<span class="sd">                                                  (though some are redundant</span>
<span class="sd">                                                  here).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the norms of</span>
<span class="sd">                                                  all vectors in the set.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; norm(numpy.array([ 1,  0]), 2).ndim</span>
<span class="sd">            0</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ 1,  0]]), 2).ndim</span>
<span class="sd">            1</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([ 1,  0]), 2)</span>
<span class="sd">            array(1.0)</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([ 1,  0]), 1)</span>
<span class="sd">            array(1.0)</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ 1,  0]]), 2)</span>
<span class="sd">            array([ 1.])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ 1,  1]]), 1)</span>
<span class="sd">            array([ 2.])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ 1,  1]]), 2)</span>
<span class="sd">            array([ 1.41421356])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ True,  False]]), 1)</span>
<span class="sd">            array([ 1.])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ True,  False]]), 2)</span>
<span class="sd">            array([ 1.])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ True,  True]]), 1)</span>
<span class="sd">            array([ 2.])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ True,  True]]), 2)</span>
<span class="sd">            array([ 1.41421356])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ 1,  1,  1], [ 1,  0,  1]]), 1)</span>
<span class="sd">            array([ 3.,  2.])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([[ 1,  1,  1], [ 1,  0,  1]]), 2)</span>
<span class="sd">            array([ 1.73205081,  1.41421356])</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.array([ 0,  1,  2]))</span>
<span class="sd">            array(2.23606797749979)</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.zeros((0, 2,)))</span>
<span class="sd">            array([], shape=(0, 2), dtype=float64)</span>

<span class="sd">            &gt;&gt;&gt; norm(numpy.zeros((2, 0,)))</span>
<span class="sd">            array([], shape=(2, 0), dtype=float64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Needs to have at least one vector</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">new_vector_set</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">new_vector_set_float</span> <span class="o">=</span> <span class="n">new_vector_set</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c"># Wrap the order parameter so as to avoid passing through</span>
    <span class="c"># numpy.apply_along_axis and risk having it break. Also, makes sure the</span>
    <span class="c"># same function can be used in the two cases.</span>
    <span class="n">wrapped_norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a_vector_set</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
        <span class="n">a_vector_set</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c"># Return a scalar NumPy array in the case of a single vector</span>
    <span class="c"># Always return type float as the result.</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">new_vector_set</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">new_vector_set_float</span>
    <span class="k">elif</span> <span class="n">new_vector_set</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">wrapped_norm</span><span class="p">(</span><span class="n">new_vector_set_float</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span>
            <span class="n">wrapped_norm</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_vector_set_float</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="threshold_array"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.threshold_array">[docs]</a><span class="k">def</span> <span class="nf">threshold_array</span><span class="p">(</span><span class="n">an_array</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">include_below</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">is_closed</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a threshold, this function compares the given array to it to see</span>
<span class="sd">        which entries match.</span>

<span class="sd">        Args:</span>
<span class="sd">            an_array(numpy.ndarray):                          an array to</span>
<span class="sd">                                                              threshold.</span>

<span class="sd">            threshold(int or float or numpy.ndarray):         something to</span>
<span class="sd">                                                              compare to.</span>

<span class="sd">            include_below(bool):                              whether values</span>
<span class="sd">                                                              below the</span>
<span class="sd">                                                              threshold count</span>
<span class="sd">                                                              or ones above it.</span>

<span class="sd">            is_closed(bool):                                  whether to</span>
<span class="sd">                                                              include values</span>
<span class="sd">                                                              equal to the</span>
<span class="sd">                                                              threshold</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):                               a mask of entries</span>
<span class="sd">                                                              reflecting the</span>
<span class="sd">                                                              threshold.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=False,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True,  True,  True],</span>
<span class="sd">                   [ True,  True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=False,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False,  True,  True],</span>
<span class="sd">                   [ True,  True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     5,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True,  True,  True],</span>
<span class="sd">                   [ True,  True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     6,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True,  True,  True],</span>
<span class="sd">                   [ True,  True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     2*numpy.ones((2,3)),</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True,  True,  True],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3) % 2,</span>
<span class="sd">            ...     1,</span>
<span class="sd">            ...     include_below=False,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False,  True, False],</span>
<span class="sd">                   [ True, False,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_array(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3) % 2,</span>
<span class="sd">            ...     1,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True, False,  True],</span>
<span class="sd">                   [False,  True, False]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">accepted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">an_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">include_below</span> <span class="ow">and</span> <span class="n">is_closed</span><span class="p">:</span>
        <span class="n">accepted</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">an_array</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">include_below</span> <span class="ow">and</span> <span class="n">is_closed</span><span class="p">:</span>
        <span class="n">accepted</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">an_array</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">include_below</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_closed</span><span class="p">:</span>
        <span class="n">accepted</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">an_array</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">accepted</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">an_array</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">accepted</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="unique_mapping"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.unique_mapping">[docs]</a><span class="k">def</span> <span class="nf">unique_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take a binary mapping between two sets and excludes portions of the</span>
<span class="sd">        mapping that are not one-to-one.</span>

<span class="sd">        Args:</span>
<span class="sd">            mapping(numpy.ndarray):      bool array mapping between to sets.</span>
<span class="sd">            out(numpy.ndarray):          where to store the results.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):          the results returned.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; unique_mapping(numpy.zeros((2,2), dtype=bool))</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; unique_mapping(numpy.ones((2,2), dtype=bool))</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; unique_mapping(numpy.eye(2, dtype=bool))</span>
<span class="sd">            array([[ True, False],</span>
<span class="sd">                   [False,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; unique_mapping(</span>
<span class="sd">            ...     numpy.array([[ True,  True],</span>
<span class="sd">            ...                  [ True, False]], dtype=bool)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; unique_mapping(</span>
<span class="sd">            ...     numpy.array([[ True, False],</span>
<span class="sd">            ...                  [False, False]], dtype=bool)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.ones((2,2), dtype=bool); b = a.copy(); a</span>
<span class="sd">            array([[ True,  True],</span>
<span class="sd">                   [ True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; unique_mapping(a, out=b)</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; unique_mapping(a, out=a)</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">mapping</span>

    <span class="n">injective_into</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">injective_into_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">add_singleton_op</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">injective_into</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">injective_into_i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">*=</span> <span class="n">injective_into</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="threshold_metric"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.threshold_metric">[docs]</a><span class="k">def</span> <span class="nf">threshold_metric</span><span class="p">(</span><span class="n">a_metric</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">include_below</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">is_closed</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a threshold, this function finds which entries uniquely match</span>
<span class="sd">        given the threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            a_metric(numpy.ndarray):                          an array to</span>
<span class="sd">                                                              threshold.</span>

<span class="sd">            threshold(int or float or numpy.ndarray):         something to</span>
<span class="sd">                                                              compare to.</span>

<span class="sd">            include_below(bool):                              whether values</span>
<span class="sd">                                                              below the</span>
<span class="sd">                                                              threshold count</span>
<span class="sd">                                                              or ones above it.</span>

<span class="sd">            is_closed(bool):                                  whether to</span>
<span class="sd">                                                              include values</span>
<span class="sd">                                                              equal to the</span>
<span class="sd">                                                              threshold</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):                               a mapping of</span>
<span class="sd">                                                              unique matches.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ True, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=False,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     0,</span>
<span class="sd">            ...     include_below=False,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     5,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     6,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     2*numpy.ones((2,3)),</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     numpy.arange(0, 12, 2).reshape(2,3),</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=True</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; threshold_metric(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3) % 2,</span>
<span class="sd">            ...     1,</span>
<span class="sd">            ...     include_below=True,</span>
<span class="sd">            ...     is_closed=False</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False,  True, False]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">a_metric</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">accepted</span> <span class="o">=</span> <span class="n">unique_mapping</span><span class="p">(</span><span class="n">threshold_array</span><span class="p">(</span>
        <span class="n">a_metric</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">include_below</span><span class="o">=</span><span class="n">include_below</span><span class="p">,</span> <span class="n">is_closed</span><span class="o">=</span><span class="n">is_closed</span><span class="p">))</span>

    <span class="k">return</span><span class="p">(</span><span class="n">accepted</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="compute_mapping_matches"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.compute_mapping_matches">[docs]</a><span class="k">def</span> <span class="nf">compute_mapping_matches</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a mapping this function computes number of matches and mismatches</span>
<span class="sd">        found.</span>

<span class="sd">        In the array returned, first value is the number of true positives (or</span>
<span class="sd">        matches) and then mismatches along each dimension of the mapping in</span>
<span class="sd">        order.</span>

<span class="sd">        If axis 0 is the ground truth, then the second and third values are the</span>
<span class="sd">        number of false negatives (or misses) and false positives (or false</span>
<span class="sd">        alarm)</span>

<span class="sd">        Args:</span>
<span class="sd">            mapping(numpy.ndarray):                           a 2D bool array</span>
<span class="sd">                                                              mapping</span>
<span class="sd">                                                              intersections</span>
<span class="sd">                                                              between 2 groups.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):                               Counts of the</span>
<span class="sd">                                                              number of matches</span>
<span class="sd">                                                              and mismatches.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; compute_mapping_matches(numpy.arange(6).reshape(2,3) &lt; 0)</span>
<span class="sd">            array([0, 2, 3], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_matches(numpy.arange(6).reshape(2,3) &lt;= 0)</span>
<span class="sd">            array([1, 1, 2], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_matches(</span>
<span class="sd">            ...     (numpy.arange(6).reshape(2,3) % 2) == 1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([1, 1, 2], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_matches(numpy.eye(2, dtype=bool))</span>
<span class="sd">            array([2, 0, 0], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_matches(numpy.fliplr(numpy.eye(2, dtype=bool)))</span>
<span class="sd">            array([2, 0, 0], dtype=uint64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">stats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

    <span class="n">stats</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">unique_mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">mapping_shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
    <span class="n">stats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">mapping_shape</span> <span class="o">-</span> <span class="n">stats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="k">return</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="compute_mapping_relevance"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.compute_mapping_relevance">[docs]</a><span class="k">def</span> <span class="nf">compute_mapping_relevance</span><span class="p">(</span><span class="n">mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a mapping this function computes the recall and precision.</span>

<span class="sd">        If axis 0 is the ground truth, then the returned values are the recall</span>
<span class="sd">        and precision in order. If axis 1 is the ground truth, then they are</span>
<span class="sd">        flipped.</span>

<span class="sd">        Args:</span>
<span class="sd">            mapping(numpy.ndarray):            a 2D bool array mapping</span>
<span class="sd">                                               intersections between 2 groups.</span>

<span class="sd">        Returns:</span>
<span class="sd">            relevance(tuple of floats):        relevance - a combination of</span>
<span class="sd">                                                           recall and precision</span>
<span class="sd">                                                   recall    - the ratio of</span>
<span class="sd">                                                               relevant</span>
<span class="sd">                                                               predicted</span>
<span class="sd">                                                               positives out of</span>
<span class="sd">                                                               all relevant</span>
<span class="sd">                                                               positives.</span>
<span class="sd">                                                   precision - the ratio of</span>
<span class="sd">                                                               relevant</span>
<span class="sd">                                                               predicted</span>
<span class="sd">                                                               positives out of</span>
<span class="sd">                                                               all predicted</span>
<span class="sd">                                                               positives.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; compute_mapping_relevance(numpy.arange(6).reshape(2,3) &lt; 0)</span>
<span class="sd">            array([ 0.,  0.])</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_relevance(numpy.arange(6).reshape(2,3) &lt;= 0)</span>
<span class="sd">            array([ 0.5       ,  0.33333333])</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_relevance(</span>
<span class="sd">            ...     (numpy.arange(6).reshape(2,3) % 2) == 1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 0.5       ,  0.33333333])</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_relevance(numpy.eye(2, dtype=bool))</span>
<span class="sd">            array([ 1.,  1.])</span>

<span class="sd">            &gt;&gt;&gt; compute_mapping_relevance(</span>
<span class="sd">            ...     numpy.fliplr(numpy.eye(2, dtype=bool))</span>
<span class="sd">            ... )</span>
<span class="sd">            array([ 1.,  1.])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">matches</span> <span class="o">=</span> <span class="n">compute_mapping_matches</span><span class="p">(</span><span class="n">mapping</span><span class="p">)</span>
    <span class="n">mapping_shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">relevance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">relevance</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">relevance</span> <span class="o">/=</span> <span class="n">mapping_shape</span>

    <span class="k">return</span><span class="p">(</span><span class="n">relevance</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="find_relative_offsets"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.find_relative_offsets">[docs]</a><span class="k">def</span> <span class="nf">find_relative_offsets</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a series of points, find the relative points from the mean.</span>

<span class="sd">        Args:</span>
<span class="sd">            points(numpy.ndarray):       a set of integer points (NxD) where N</span>
<span class="sd">                                         is the number of points and D is the</span>
<span class="sd">                                         dimensionality, in which they lay.</span>

<span class="sd">            center(numpy.ndarray):       an integer point (D) where D is the</span>
<span class="sd">                                         dimensionality, in which they lay.</span>
<span class="sd">                                         Defaults to the mean of the points.</span>

<span class="sd">            out(numpy.ndarray):          another set of points relative to</span>
<span class="sd">                                         their mean.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):          the results returned.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; find_relative_offsets(numpy.zeros((3,2), dtype=int))</span>
<span class="sd">            array([[0, 0],</span>
<span class="sd">                   [0, 0],</span>
<span class="sd">                   [0, 0]])</span>

<span class="sd">            &gt;&gt;&gt; find_relative_offsets(numpy.ones((3,2), dtype=int))</span>
<span class="sd">            array([[0, 0],</span>
<span class="sd">                   [0, 0],</span>
<span class="sd">                   [0, 0]])</span>

<span class="sd">            &gt;&gt;&gt; find_relative_offsets(</span>
<span class="sd">            ...     numpy.ones((3,2), dtype=int), -numpy.ones((2,), dtype=int)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[2, 2],</span>
<span class="sd">                   [2, 2],</span>
<span class="sd">                   [2, 2]])</span>

<span class="sd">            &gt;&gt;&gt; find_relative_offsets(numpy.arange(6).reshape(2,3).T % 2)</span>
<span class="sd">            array([[ 0,  0],</span>
<span class="sd">                   [ 1, -1],</span>
<span class="sd">                   [ 0,  0]])</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(6).reshape(2,3).T % 2; b = numpy.zeros_like(a)</span>
<span class="sd">            &gt;&gt;&gt; find_relative_offsets(a, out=b)</span>
<span class="sd">            array([[ 0,  0],</span>
<span class="sd">                   [ 1, -1],</span>
<span class="sd">                   [ 0,  0]])</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[ 0,  0],</span>
<span class="sd">                   [ 1, -1],</span>
<span class="sd">                   [ 0,  0]])</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.arange(6).reshape(2,3).T % 2</span>
<span class="sd">            &gt;&gt;&gt; find_relative_offsets(a, out=a)</span>
<span class="sd">            array([[ 0,  0],</span>
<span class="sd">                   [ 1, -1],</span>
<span class="sd">                   [ 0,  0]])</span>
<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            array([[ 0,  0],</span>
<span class="sd">                   [ 1, -1],</span>
<span class="sd">                   [ 0,  0]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">points</span>

    <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
            <span class="n">out</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">-=</span> <span class="n">center</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="find_shortest_wraparound"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.find_shortest_wraparound">[docs]</a><span class="k">def</span> <span class="nf">find_shortest_wraparound</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the smallest values for the points given periodic boundary</span>
<span class="sd">        conditions.</span>

<span class="sd">        Args:</span>
<span class="sd">            points(numpy.ndarray):       a set of integer points (NxD) where N</span>
<span class="sd">                                         is the number of points and D is the</span>
<span class="sd">                                         dimensionality, in which they lay.</span>

<span class="sd">            shape(numpy.ndarray):        the shape to use for wrapping (D).</span>

<span class="sd">            out(numpy.ndarray):          another set of points relative to</span>
<span class="sd">                                         their mean.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):          the results returned.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     numpy.zeros((3, 2), dtype=int),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0, 0],</span>
<span class="sd">                   [0, 0],</span>
<span class="sd">                   [0, 0]])</span>

<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     numpy.ones((3, 2), dtype=int),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[1, 1],</span>
<span class="sd">                   [1, 1],</span>
<span class="sd">                   [1, 1]])</span>

<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     4 * numpy.ones((3, 2), dtype=int),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0, 4],</span>
<span class="sd">                   [0, 4],</span>
<span class="sd">                   [0, 4]])</span>

<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     8 * (numpy.arange(6).reshape(3, 2) % 2),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0, 0],</span>
<span class="sd">                   [0, 0],</span>
<span class="sd">                   [0, 0]])</span>

<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     7 * (numpy.arange(6).reshape(3, 2) % 2),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0, -1],</span>
<span class="sd">                   [ 0, -1],</span>
<span class="sd">                   [ 0, -1]])</span>

<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     -numpy.ones((3, 2), dtype=int),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[-1, -1],</span>
<span class="sd">                   [-1, -1],</span>
<span class="sd">                   [-1, -1]])</span>

<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     -4 * numpy.ones((3, 2), dtype=int),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0, -4],</span>
<span class="sd">                   [ 0, -4],</span>
<span class="sd">                   [ 0, -4]])</span>

<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     -7 * (numpy.arange(6).reshape(3, 2) % 2),</span>
<span class="sd">            ...     (4, 8)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0, 1],</span>
<span class="sd">                   [0, 1],</span>
<span class="sd">                   [0, 1]])</span>

<span class="sd">            &gt;&gt;&gt; a = -7 * (numpy.arange(6).reshape(3, 2) % 2)</span>
<span class="sd">            &gt;&gt;&gt; b = numpy.zeros_like(a)</span>
<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     a,</span>
<span class="sd">            ...     (4, 8),</span>
<span class="sd">            ...     out=b</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0, 1],</span>
<span class="sd">                   [0, 1],</span>
<span class="sd">                   [0, 1]])</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[0, 1],</span>
<span class="sd">                   [0, 1],</span>
<span class="sd">                   [0, 1]])</span>

<span class="sd">            &gt;&gt;&gt; a = -7 * (numpy.arange(6).reshape(3, 2) % 2)</span>
<span class="sd">            &gt;&gt;&gt; find_shortest_wraparound(</span>
<span class="sd">            ...     a,</span>
<span class="sd">            ...     (4, 8),</span>
<span class="sd">            ...     out=a</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0, 1],</span>
<span class="sd">                   [0, 1],</span>
<span class="sd">                   [0, 1]])</span>
<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            array([[0, 1],</span>
<span class="sd">                   [0, 1],</span>
<span class="sd">                   [0, 1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">points</span>

    <span class="n">shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">half_shape</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">shape</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="n">points_mask_above</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">out</span> <span class="o">&gt;</span> <span class="n">half_shape</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">points_mask_above</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">out</span> <span class="o">-=</span> <span class="n">points_mask_above</span> <span class="o">*</span> <span class="n">shape</span>
    <span class="n">points_mask_below</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">out</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">half_shape</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">points_mask_below</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">points_mask_below</span> <span class="o">*</span> <span class="n">shape</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="matrix_reduced_op"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.matrix_reduced_op">[docs]</a><span class="k">def</span> <span class="nf">matrix_reduced_op</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort of like numpy.dot. However, it will use the first axis with both</span>
<span class="sd">        arrays. This means they may not need to be matrices. However, they must</span>
<span class="sd">        have the same number of dimensions. Generally, though not explicitly</span>
<span class="sd">        required, the operator will likely expect every dimension other than</span>
<span class="sd">        the first to be the same shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            a(numpy.ndarray):      first array.</span>
<span class="sd">            b(numpy.ndarray):      second array.</span>
<span class="sd">            op(callable):          an operator that will take a[i] and b[j] as</span>
<span class="sd">                                   arguments and return a scalar.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):    an array (matrix) with the shape (len(a),</span>
<span class="sd">                                   len(b)) with each element out[i, j] the</span>
<span class="sd">                                   result of op(a[i], b[j]).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     numpy.arange(0,12,2).reshape(2,3),</span>
<span class="sd">            ...     op=numpy.dot</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 10,  28],</span>
<span class="sd">                   [ 28, 100]])</span>

<span class="sd">            &gt;&gt;&gt; numpy.dot(</span>
<span class="sd">            ...     numpy.arange(6).reshape(2,3),</span>
<span class="sd">            ...     numpy.arange(0,12,2).reshape(2,3).T,</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 10,  28],</span>
<span class="sd">                   [ 28, 100]])</span>

<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(</span>
<span class="sd">            ...     numpy.arange(8).reshape(2,4),</span>
<span class="sd">            ...     numpy.arange(0,16,2).reshape(2,4),</span>
<span class="sd">            ...     op=numpy.dot</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 28,  76],</span>
<span class="sd">                   [ 76, 252]])</span>

<span class="sd">            &gt;&gt;&gt; numpy.dot(</span>
<span class="sd">            ...     numpy.arange(8).reshape(2,4),</span>
<span class="sd">            ...     numpy.arange(0,16,2).reshape(2,4).T,</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 28,  76],</span>
<span class="sd">                   [ 76, 252]])</span>

<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                   numpy.ones((2,2), dtype=bool),</span>
<span class="sd">            ...                   op=lambda _a, _b: (_a &amp; _b).sum())</span>
<span class="sd">            array([[ True,  True],</span>
<span class="sd">                   [ True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                   numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                   op=lambda _a, _b: (_a &amp; _b).sum())</span>
<span class="sd">            array([[ True],</span>
<span class="sd">                   [ True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                   numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                   op=lambda _a, _b: (_a &amp; _b).sum())</span>
<span class="sd">            array([[ True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                    numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                    op=lambda _a, _b: (_a &amp; _b).sum())</span>
<span class="sd">            array([[ True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                   numpy.zeros((2,2), dtype=bool),</span>
<span class="sd">            ...                   op=lambda _a, _b: (_a &amp; _b).sum())</span>
<span class="sd">            array([[False, False],</span>
<span class="sd">                   [False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; matrix_reduced_op(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                   numpy.zeros((2,2), dtype=bool),</span>
<span class="sd">            ...                   op=lambda _a, _b: (_a | _b).sum())</span>
<span class="sd">            array([[ True,  True],</span>
<span class="sd">                   [ True,  True]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">promote_types</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="masks_intersection"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.masks_intersection">[docs]</a><span class="k">def</span> <span class="nf">masks_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a mask that contains the points share by both masks.</span>

<span class="sd">        Args:</span>
<span class="sd">            a(numpy.ndarray):      first mask.</span>
<span class="sd">            b(numpy.ndarray):      second mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):    a mask that is only True where both masks</span>
<span class="sd">                                   are.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; masks_intersection(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                    numpy.ones((2,2), dtype=bool))</span>
<span class="sd">            array([[1, 1],</span>
<span class="sd">                   [1, 1]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_intersection(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                    numpy.ones((2,), dtype=bool))</span>
<span class="sd">            array([[1],</span>
<span class="sd">                   [1]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_intersection(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                    numpy.eye(2).astype(bool))</span>
<span class="sd">            array([[1, 1]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_intersection(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                    numpy.ones((2,), dtype=bool))</span>
<span class="sd">            array([[2]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_intersection(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                    numpy.zeros((2,2), dtype=bool))</span>
<span class="sd">            array([[0, 0],</span>
<span class="sd">                   [0, 0]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; (numpy.arange(6).reshape(2,3) % 2).astype(bool)</span>
<span class="sd">            array([[False,  True, False],</span>
<span class="sd">                   [ True, False,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; numpy.arange(6).reshape(2,3) == 4</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False,  True, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; masks_intersection(</span>
<span class="sd">            ...     (numpy.arange(6).reshape(2,3) % 2).astype(bool),</span>
<span class="sd">            ...     (numpy.arange(6).reshape(2,3) == 4)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[0, 1],</span>
<span class="sd">                   [0, 0]], dtype=uint64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="masks_union"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.masks_union">[docs]</a><span class="k">def</span> <span class="nf">masks_union</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A mask that contains point contained in either mask.</span>

<span class="sd">        Args:</span>
<span class="sd">            a(numpy.ndarray):      first mask.</span>
<span class="sd">            b(numpy.ndarray):      second mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):    a mask that is True where either mask is.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; masks_union(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...             numpy.ones((2,2), dtype=bool))</span>
<span class="sd">            array([[2, 2],</span>
<span class="sd">                   [2, 2]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_union(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...             numpy.ones((2,), dtype=bool))</span>
<span class="sd">            array([[2],</span>
<span class="sd">                   [2]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_union(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...             numpy.eye(2).astype(bool))</span>
<span class="sd">            array([[2, 2]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_union(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...             numpy.ones((2,), dtype=bool))</span>
<span class="sd">            array([[2]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; masks_union(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...             numpy.zeros((2,2), dtype=bool))</span>
<span class="sd">            array([[1, 1],</span>
<span class="sd">                   [1, 1]], dtype=uint64)</span>

<span class="sd">            &gt;&gt;&gt; (numpy.arange(6).reshape(2,3) % 2).astype(bool)</span>
<span class="sd">            array([[False,  True, False],</span>
<span class="sd">                   [ True, False,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; numpy.arange(6).reshape(2,3) == 4</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False,  True, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; masks_union((numpy.arange(6).reshape(2,3) % 2).astype(bool),</span>
<span class="sd">            ...             (numpy.arange(6).reshape(2,3) == 4))</span>
<span class="sd">            array([[1, 1],</span>
<span class="sd">                   [2, 3]], dtype=uint64)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">|</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="masks_overlap_normalized"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.masks_overlap_normalized">[docs]</a><span class="k">def</span> <span class="nf">masks_overlap_normalized</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The area of intersection of the masks divided by the area of their</span>
<span class="sd">        union.</span>

<span class="sd">        Args:</span>
<span class="sd">            a(numpy.ndarray):      first mask.</span>
<span class="sd">            b(numpy.ndarray):      second mask.</span>

<span class="sd">        Returns:</span>
<span class="sd">            out(numpy.ndarray):    ratio of the areas of the masks&#39;</span>
<span class="sd">                                   intersection and union.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; masks_overlap_normalized(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                          numpy.ones((2,2), dtype=bool))</span>
<span class="sd">            array([[ 0.5,  0.5],</span>
<span class="sd">                   [ 0.5,  0.5]])</span>

<span class="sd">            &gt;&gt;&gt; masks_overlap_normalized(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                          numpy.ones((2,), dtype=bool))</span>
<span class="sd">            array([[ 0.5],</span>
<span class="sd">                   [ 0.5]])</span>

<span class="sd">            &gt;&gt;&gt; masks_overlap_normalized(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                          numpy.eye(2).astype(bool))</span>
<span class="sd">            array([[ 0.5,  0.5]])</span>

<span class="sd">            &gt;&gt;&gt; masks_overlap_normalized(numpy.ones((2,), dtype=bool),</span>
<span class="sd">            ...                          numpy.ones((2,), dtype=bool))</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; masks_overlap_normalized(numpy.eye(2).astype(bool),</span>
<span class="sd">            ...                          numpy.zeros((2,2), dtype=bool))</span>
<span class="sd">            array([[ 0.,  0.],</span>
<span class="sd">                   [ 0.,  0.]])</span>

<span class="sd">            &gt;&gt;&gt; masks_overlap_normalized(numpy.zeros((2,2), dtype=bool),</span>
<span class="sd">            ...                          numpy.zeros((2,2), dtype=bool))</span>
<span class="sd">            array([[ 0.,  0.],</span>
<span class="sd">                   [ 0.,  0.]])</span>

<span class="sd">            &gt;&gt;&gt; (numpy.arange(6).reshape(2,3) % 2).astype(bool)</span>
<span class="sd">            array([[False,  True, False],</span>
<span class="sd">                   [ True, False,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; numpy.arange(6).reshape(2,3) == 4</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False,  True, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; masks_overlap_normalized(</span>
<span class="sd">            ...     (numpy.arange(6).reshape(2,3) % 2).astype(bool),</span>
<span class="sd">            ...     (numpy.arange(6).reshape(2,3) == 4)</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.,  1.],</span>
<span class="sd">                   [ 0.,  0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">masks_intersection</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">/=</span> <span class="n">masks_union</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">out</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="dot_product_partially_normalized"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.dot_product_partially_normalized">[docs]</a><span class="k">def</span> <span class="nf">dot_product_partially_normalized</span><span class="p">(</span><span class="n">new_vector_set_1</span><span class="p">,</span>
                                     <span class="n">new_vector_set_2</span><span class="p">,</span>
                                     <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the dot product between the two pairs of vectors from each</span>
<span class="sd">        set and creates a tuple with the dot product divided by one norm or the</span>
<span class="sd">        other.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set_1(numpy.ndarray):      first set of vectors.</span>

<span class="sd">            new_vector_set_2(numpy.ndarray):      second set of vectors.</span>

<span class="sd">            ord(optional):                        basically the same arguments</span>
<span class="sd">                                                  as numpy.linalg.norm</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the normalized</span>
<span class="sd">                                                  distances between each pair</span>
<span class="sd">                                                  of vectors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; (numpy.array(dot_product_partially_normalized(numpy.eye(2), numpy.eye(2), 2)) == numpy.array((numpy.eye(2), numpy.eye(2),))).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; (numpy.array(dot_product_partially_normalized(numpy.eye(10), numpy.eye(10), 2)) == numpy.array((numpy.eye(10), numpy.eye(10),))).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[ 1.]]), array([[ 1.]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 0,  1]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[ 0.]]), array([[ 0.]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[-1,  0]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[-1.]]), array([[-1.]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 0, -1]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[ 0.]]), array([[ 0.]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[ 1.]]), array([[ 0.70710678]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ...     1</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[ 1.]]), array([[ 0.5]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ True,  False]]),</span>
<span class="sd">            ...     numpy.array([[ True,  True]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[ 1.]]), array([[ 0.70710678]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ True,  False]]),</span>
<span class="sd">            ...     numpy.array([[ True,  True]]),</span>
<span class="sd">            ...     1</span>
<span class="sd">            ... )</span>
<span class="sd">            (array([[ 1.]]), array([[ 0.5]]))</span>

<span class="sd">            &gt;&gt;&gt; dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.arange(6).reshape((2,3)),</span>
<span class="sd">            ...     numpy.arange(5, 17).reshape((4,3)),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            (array([[  8.94427191,  12.96919427,  16.99411663,  21.01903899],</span>
<span class="sd">                    [ 10.46518036,  15.55634919,  20.64751801,  25.73868684]]),</span>
<span class="sd">             array([[ 1.90692518,  1.85274204,  1.82405837,  1.80635674],</span>
<span class="sd">                    [ 7.05562316,  7.02764221,  7.00822427,  6.99482822]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_vector_set_1_float</span> <span class="o">=</span> <span class="n">new_vector_set_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">new_vector_set_2_float</span> <span class="o">=</span> <span class="n">new_vector_set_2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c"># Gets all of the norms</span>
    <span class="n">new_vector_set_1_norms</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">new_vector_set_1_float</span><span class="p">,</span> <span class="nb">ord</span><span class="p">)</span>
    <span class="n">new_vector_set_2_norms</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">new_vector_set_2_float</span><span class="p">,</span> <span class="nb">ord</span><span class="p">)</span>

    <span class="c"># Expand the norms to have a shape equivalent to vector_pairs_dot_product</span>
    <span class="n">new_vector_set_1_norms_expanded</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span>
        <span class="n">new_vector_set_1_norms</span><span class="p">,</span> <span class="n">reps_after</span><span class="o">=</span><span class="n">new_vector_set_2_float</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">new_vector_set_2_norms_expanded</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span>
        <span class="n">new_vector_set_2_norms</span><span class="p">,</span> <span class="n">reps_before</span><span class="o">=</span><span class="n">new_vector_set_1_float</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c"># Measure the dot product between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_dot_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">new_vector_set_1_float</span><span class="p">,</span> <span class="n">new_vector_set_2_float</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">vector_pairs_dot_product_1_normalized</span> <span class="o">=</span> <span class="n">vector_pairs_dot_product</span> <span class="o">/</span> \
        <span class="n">new_vector_set_1_norms_expanded</span>
    <span class="n">vector_pairs_dot_product_2_normalized</span> <span class="o">=</span> <span class="n">vector_pairs_dot_product</span> <span class="o">/</span> \
        <span class="n">new_vector_set_2_norms_expanded</span>

    <span class="k">return</span><span class="p">(</span>
        <span class="p">(</span><span class="n">vector_pairs_dot_product_1_normalized</span><span class="p">,</span>
         <span class="n">vector_pairs_dot_product_2_normalized</span><span class="p">)</span>
    <span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="pair_dot_product_partially_normalized"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.pair_dot_product_partially_normalized">[docs]</a><span class="k">def</span> <span class="nf">pair_dot_product_partially_normalized</span><span class="p">(</span><span class="n">new_vector_set</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the dot product between the two pairs of vectors from each</span>
<span class="sd">        set and creates a tuple with the dot product divided by one norm or the</span>
<span class="sd">        other.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set(numpy.ndarray):        set of vectors.</span>

<span class="sd">            ord(optional):                        basically the same argument</span>
<span class="sd">                                                  as numpy.linalg.norm</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the normalized</span>
<span class="sd">                                                  distances between each pair</span>
<span class="sd">                                                  of vectors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; (pair_dot_product_partially_normalized(numpy.eye(2), 2) == numpy.eye(2)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; (pair_dot_product_partially_normalized(numpy.eye(10), 2) == numpy.eye(10)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[-1,  0]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.41421356]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ...     1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ True,  False]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_partially_normalized(</span>
<span class="sd">            ...     numpy.array([[ True,  True]]),</span>
<span class="sd">            ...     1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            # &gt;&gt;&gt; pair_dot_product_partially_normalized( numpy.arange(6).reshape((2,3)), numpy.arange(5, 17).reshape((4,3)), 2 )  #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            # (array([[  8.94427191,  12.96919427,  16.99411663,  21.01903899],</span>
<span class="sd">            #        [ 10.46518036,  15.55634919,  20.64751801,  25.73868684]]),</span>
<span class="sd">            #  array([[ 1.90692518,  1.85274204,  1.82405837,  1.80635674],</span>
<span class="sd">            #        [ 7.05562316,  7.02764221,  7.00822427,  6.99482822]]))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_vector_set_float</span> <span class="o">=</span> <span class="n">new_vector_set</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c"># Gets all of the norms</span>
    <span class="n">new_vector_set_norms</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">new_vector_set_float</span><span class="p">,</span> <span class="nb">ord</span><span class="p">)</span>

    <span class="c"># Expand the norms to have a shape equivalent to vector_pairs_dot_product</span>
    <span class="n">new_vector_set_norms_expanded</span> <span class="o">=</span> <span class="n">expand_view</span><span class="p">(</span>
        <span class="n">new_vector_set_norms</span><span class="p">,</span> <span class="n">reps_after</span><span class="o">=</span><span class="n">new_vector_set_float</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c"># Measure the dot product between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_dot_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">new_vector_set_float</span><span class="p">,</span> <span class="n">new_vector_set_float</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>

    <span class="n">vector_pairs_dot_product_normalized</span> <span class="o">=</span> <span class="n">vector_pairs_dot_product</span> <span class="o">/</span> <span class="n">new_vector_set_norms_expanded</span>

    <span class="k">return</span><span class="p">((</span><span class="n">vector_pairs_dot_product_normalized</span><span class="p">))</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="dot_product_normalized"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.dot_product_normalized">[docs]</a><span class="k">def</span> <span class="nf">dot_product_normalized</span><span class="p">(</span><span class="n">new_vector_set_1</span><span class="p">,</span> <span class="n">new_vector_set_2</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the dot product between a pair of vectors from each set and</span>
<span class="sd">        divides them by the norm of the two.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set_1(numpy.ndarray):      first set of vectors.</span>

<span class="sd">            new_vector_set_2(numpy.ndarray):      second set of vectors.</span>

<span class="sd">            ord(optional):                        basically the same arguments</span>
<span class="sd">                                                  as numpy.linalg.norm.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the normalized</span>
<span class="sd">                                                  distances between each pair</span>
<span class="sd">                                                  of vectors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; (dot_product_normalized(numpy.eye(2), numpy.eye(2), 2) == numpy.eye(2)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; (dot_product_normalized(numpy.eye(10), numpy.eye(10), 2) == numpy.eye(10)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 0,  1]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[-1,  0]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[-1.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 0, -1]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.70710678]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ...     1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.5]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ True,  False]]),</span>
<span class="sd">            ...     numpy.array([[ True,   True]]),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.70710678]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ True, False]]),</span>
<span class="sd">            ...     numpy.array([[ True,  True]]),</span>
<span class="sd">            ...     1</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.5]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_normalized(</span>
<span class="sd">            ...     numpy.arange(6).reshape((2,3)),</span>
<span class="sd">            ...     numpy.arange(5, 17).reshape((4,3)),</span>
<span class="sd">            ...     2</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.85280287,  0.82857143,  0.8157437 ,  0.80782729],</span>
<span class="sd">                   [ 0.9978158 ,  0.99385869,  0.99111258,  0.98921809]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_vector_set_1_float</span> <span class="o">=</span> <span class="n">new_vector_set_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">new_vector_set_2_float</span> <span class="o">=</span> <span class="n">new_vector_set_2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c"># Gets all of the norms</span>
    <span class="n">new_vector_set_1_norms</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">new_vector_set_1_float</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">)</span>
    <span class="n">new_vector_set_2_norms</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">new_vector_set_2_float</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">)</span>

    <span class="c"># Finds the product of each combination for normalization</span>
    <span class="n">norm_products</span> <span class="o">=</span> <span class="n">all_permutations_operation</span><span class="p">(</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">new_vector_set_1_norms</span><span class="p">,</span> <span class="n">new_vector_set_2_norms</span>
    <span class="p">)</span>

    <span class="c"># Measure the dot product between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_dot_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">new_vector_set_1_float</span><span class="p">,</span> <span class="n">new_vector_set_2_float</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>

    <span class="c"># Measure the dot product between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_dot_product_normalized</span> <span class="o">=</span> <span class="n">vector_pairs_dot_product</span> <span class="o">/</span> <span class="n">norm_products</span>

    <span class="k">return</span><span class="p">(</span><span class="n">vector_pairs_dot_product_normalized</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="pair_dot_product_normalized"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.pair_dot_product_normalized">[docs]</a><span class="k">def</span> <span class="nf">pair_dot_product_normalized</span><span class="p">(</span><span class="n">new_vector_set</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the dot product between a pair of vectors from each set and</span>
<span class="sd">        divides them by the norm of the two.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set(numpy.ndarray):        set of vectors.</span>

<span class="sd">            ord(optional):                        basically the same arguments</span>
<span class="sd">                                                  as numpy.linalg.norm.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the normalized</span>
<span class="sd">                                                  distances between each pair</span>
<span class="sd">                                                  of vectors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; (pair_dot_product_normalized(numpy.eye(2)) == numpy.eye(2)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; (pair_dot_product_normalized(numpy.eye(10)) == numpy.eye(10)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]])</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1.,  0.]])</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[-1,  0]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 0,  1]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; pair_dot_product_normalized(</span>
<span class="sd">            ...     numpy.array([[ True,  False]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_vector_set_float</span> <span class="o">=</span> <span class="n">new_vector_set</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c"># Gets all of the norms</span>
    <span class="n">new_vector_set_norms</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">new_vector_set_float</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">)</span>

    <span class="c"># Finds the product of each combination for normalization</span>
    <span class="n">norm_products</span> <span class="o">=</span> <span class="n">all_permutations_operation</span><span class="p">(</span>
        <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">new_vector_set_norms</span><span class="p">,</span> <span class="n">new_vector_set_norms</span>
    <span class="p">)</span>

    <span class="c"># Measure the dot product between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_dot_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">new_vector_set_float</span><span class="p">,</span> <span class="n">new_vector_set_float</span><span class="o">.</span><span class="n">T</span>
    <span class="p">)</span>

    <span class="c"># Measure the dot product between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_dot_product_normalized</span> <span class="o">=</span> <span class="n">vector_pairs_dot_product</span> <span class="o">/</span> <span class="n">norm_products</span>

    <span class="k">return</span><span class="p">(</span><span class="n">vector_pairs_dot_product_normalized</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="dot_product_L2_normalized"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.dot_product_L2_normalized">[docs]</a><span class="k">def</span> <span class="nf">dot_product_L2_normalized</span><span class="p">(</span><span class="n">new_vector_set_1</span><span class="p">,</span> <span class="n">new_vector_set_2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the dot product between a pair of vectors from each set and</span>
<span class="sd">        divides them by the L_2 norm of the two.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_vector_set_1(numpy.ndarray):      first set of vectors.</span>
<span class="sd">            new_vector_set_2(numpy.ndarray):      second set of vectors.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                      an array with the distances</span>
<span class="sd">                                                  between each pair of vectors.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; (dot_product_L2_normalized(numpy.eye(2), numpy.eye(2)) == numpy.eye(2)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; (dot_product_L2_normalized(numpy.eye(10), numpy.eye(10)) == numpy.eye(10)).all()</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; dot_product_L2_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 1.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_L2_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 0,  1]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_L2_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[-1,  0]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[-1.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_L2_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 0, -1]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_L2_normalized(</span>
<span class="sd">            ...     numpy.array([[ 1,  0]]),</span>
<span class="sd">            ...     numpy.array([[ 1,  1]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.70710678]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_L2_normalized(</span>
<span class="sd">            ...     numpy.array([[ True,  False]]),</span>
<span class="sd">            ...     numpy.array([[ True,   True]]),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.70710678]])</span>

<span class="sd">            &gt;&gt;&gt; dot_product_L2_normalized(</span>
<span class="sd">            ...     numpy.arange(6).reshape((2,3)),</span>
<span class="sd">            ...     numpy.arange(5, 17).reshape((4,3)),</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[ 0.85280287,  0.82857143,  0.8157437 ,  0.80782729],</span>
<span class="sd">                   [ 0.9978158 ,  0.99385869,  0.99111258,  0.98921809]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_vector_set_1_float</span> <span class="o">=</span> <span class="n">new_vector_set_1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">new_vector_set_2_float</span> <span class="o">=</span> <span class="n">new_vector_set_2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="c"># Measure the angle between any two neurons</span>
    <span class="c"># (i.e. related to the angle of separation)</span>
    <span class="n">vector_pairs_cosine_angle</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">new_vector_set_1_float</span><span class="p">,</span>
                                                                 <span class="n">new_vector_set_2_float</span><span class="p">,</span>
                                                                 <span class="s">&quot;cosine&quot;</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">vector_pairs_cosine_angle</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="generate_contour"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.generate_contour">[docs]</a><span class="k">def</span> <span class="nf">generate_contour</span><span class="p">(</span><span class="n">a_image</span><span class="p">,</span> <span class="n">separation_distance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes an image and extracts labeled contours from the mask using some</span>
<span class="sd">        minimum distance from the mask edge and some margin.</span>

<span class="sd">        Args:</span>
<span class="sd">            a_image(numpy.ndarray):            takes an image.</span>

<span class="sd">            separation_distance(float):        a separation distance from the</span>
<span class="sd">                                               edge of the mask for the center</span>
<span class="sd">                                               of the contour.</span>

<span class="sd">            margin(float):                     the width of contour.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                   an array with the labeled</span>
<span class="sd">                                               contours.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.array([[ True,  True, False],</span>
<span class="sd">            ...                  [False, False, False],</span>
<span class="sd">            ...                  [ True,  True,  True]], dtype=bool)</span>
<span class="sd">            &gt;&gt;&gt; generate_contour(a)</span>
<span class="sd">            array([[ True,  True, False],</span>
<span class="sd">                   [False, False, False],</span>
<span class="sd">                   [ True,  True,  True]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; generate_contour(numpy.eye(3))</span>
<span class="sd">            array([[ 1.,  0.,  0.],</span>
<span class="sd">                   [ 0.,  1.,  0.],</span>
<span class="sd">                   [ 0.,  0.,  1.]])</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.array([</span>
<span class="sd">            ...     [False, False,  True, False, False, False,  True],</span>
<span class="sd">            ...     [ True, False, False, False,  True, False, False],</span>
<span class="sd">            ...     [ True,  True, False,  True,  True, False,  True],</span>
<span class="sd">            ...     [ True, False, False,  True,  True, False, False],</span>
<span class="sd">            ...     [ True, False, False, False, False, False, False],</span>
<span class="sd">            ...     [False,  True, False, False, False, False,  True],</span>
<span class="sd">            ...     [False,  True,  True, False, False, False, False]</span>
<span class="sd">            ... ], dtype=bool)</span>
<span class="sd">            &gt;&gt;&gt; generate_contour(a)</span>
<span class="sd">            array([[False, False,  True, False, False, False,  True],</span>
<span class="sd">                   [ True, False, False, False,  True, False, False],</span>
<span class="sd">                   [ True,  True, False,  True,  True, False,  True],</span>
<span class="sd">                   [ True, False, False,  True,  True, False, False],</span>
<span class="sd">                   [ True, False, False, False, False, False, False],</span>
<span class="sd">                   [False,  True, False, False, False, False,  True],</span>
<span class="sd">                   [False,  True,  True, False, False, False, False]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">half_thickness</span> <span class="o">=</span> <span class="n">margin</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">lower_threshold</span> <span class="o">=</span> <span class="n">separation_distance</span> <span class="o">-</span> <span class="n">half_thickness</span>
    <span class="n">upper_threshold</span> <span class="o">=</span> <span class="n">separation_distance</span> <span class="o">+</span> <span class="n">half_thickness</span>

    <span class="n">a_mask_transformed</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span>
        <span class="n">a_image</span>
    <span class="p">)</span>

    <span class="n">above_lower_threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">lower_threshold</span> <span class="o">&lt;=</span> <span class="n">a_mask_transformed</span><span class="p">)</span>
    <span class="n">below_upper_threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_mask_transformed</span> <span class="o">&lt;=</span> <span class="n">upper_threshold</span><span class="p">)</span>

    <span class="n">a_mask_transformed_thresholded</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">above_lower_threshold</span> <span class="o">&amp;</span> <span class="n">below_upper_threshold</span>
    <span class="p">)</span>

    <span class="n">a_image_contours</span> <span class="o">=</span> <span class="n">a_image</span> <span class="o">*</span> <span class="n">a_mask_transformed_thresholded</span>

    <span class="k">return</span><span class="p">(</span><span class="n">a_image_contours</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="generate_labeled_contours"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.generate_labeled_contours">[docs]</a><span class="k">def</span> <span class="nf">generate_labeled_contours</span><span class="p">(</span><span class="n">a_mask</span><span class="p">,</span> <span class="n">separation_distance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes a bool mask and extracts labeled contours from the mask using</span>
<span class="sd">        some minimum distance from the mask edge and some margin.</span>

<span class="sd">        Args:</span>
<span class="sd">            a_mask(numpy.ndarray):             takes a bool mask.</span>

<span class="sd">            separation_distance(float):        a separation distance from the</span>
<span class="sd">                                               edge of the mask for the center</span>
<span class="sd">                                               of the contour.</span>

<span class="sd">            margin(float):                     the width of contour.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                   an array with the labeled</span>
<span class="sd">                                               contours.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.array([[ True,  True, False],</span>
<span class="sd">            ...                  [False, False, False],</span>
<span class="sd">            ...                  [ True,  True,  True]], dtype=bool)</span>
<span class="sd">            &gt;&gt;&gt; generate_labeled_contours(a)</span>
<span class="sd">            array([[1, 1, 0],</span>
<span class="sd">                   [0, 0, 0],</span>
<span class="sd">                   [2, 2, 2]], dtype=int32)</span>

<span class="sd">            &gt;&gt;&gt; generate_labeled_contours(numpy.eye(3))</span>
<span class="sd">            array([[1, 0, 0],</span>
<span class="sd">                   [0, 1, 0],</span>
<span class="sd">                   [0, 0, 1]], dtype=int32)</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.array([</span>
<span class="sd">            ...     [False, False,  True, False, False, False,  True],</span>
<span class="sd">            ...     [ True, False, False, False,  True, False, False],</span>
<span class="sd">            ...     [ True,  True, False,  True,  True, False,  True],</span>
<span class="sd">            ...     [ True, False, False,  True,  True, False, False],</span>
<span class="sd">            ...     [ True, False, False, False, False, False, False],</span>
<span class="sd">            ...     [False,  True, False, False, False, False,  True],</span>
<span class="sd">            ...     [False,  True,  True, False, False, False, False]</span>
<span class="sd">            ... ], dtype=bool)</span>
<span class="sd">            &gt;&gt;&gt; generate_labeled_contours(a)</span>
<span class="sd">            array([[0, 0, 1, 0, 0, 0, 2],</span>
<span class="sd">                   [3, 0, 0, 0, 4, 0, 0],</span>
<span class="sd">                   [3, 3, 0, 4, 4, 0, 5],</span>
<span class="sd">                   [3, 0, 0, 4, 4, 0, 0],</span>
<span class="sd">                   [3, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">                   [0, 3, 0, 0, 0, 0, 6],</span>
<span class="sd">                   [0, 3, 3, 0, 0, 0, 0]], dtype=int32)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a_mask_contoured</span> <span class="o">=</span> <span class="n">generate_contour</span><span class="p">(</span>
        <span class="n">a_mask</span><span class="p">,</span> <span class="n">separation_distance</span><span class="o">=</span><span class="n">separation_distance</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="n">margin</span>
    <span class="p">)</span>

    <span class="n">a_mask_contoured_labeled</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span>
        <span class="n">a_mask_contoured</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,)</span> <span class="o">*</span> <span class="n">a_mask</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span><span class="p">(</span><span class="n">a_mask_contoured_labeled</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="get_quantiles"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.get_quantiles">[docs]</a><span class="k">def</span> <span class="nf">get_quantiles</span><span class="p">(</span><span class="n">probs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the probabilites for quantiles for given data much like</span>
<span class="sd">        MATLAB&#39;s function</span>

<span class="sd">        Args:</span>
<span class="sd">            data(numpy.ndarray):                        to find the quantiles</span>
<span class="sd">                                                        of.</span>

<span class="sd">            probs(int or float or numpy.ndarray):       either some sort of</span>
<span class="sd">                                                        integer for the number</span>
<span class="sd">                                                        of quantiles or a</span>
<span class="sd">                                                        single float specifying</span>
<span class="sd">                                                        which quantile to get</span>
<span class="sd">                                                        or an array of floats</span>
<span class="sd">                                                        specifying the division</span>
<span class="sd">                                                        for each quantile in</span>
<span class="sd">                                                        the the range (0, 1).</span>

<span class="sd">            axis(int or None):                          the axis to perform the</span>
<span class="sd">                                                        calculation on (if</span>
<span class="sd">                                                        default (None) then</span>
<span class="sd">                                                        all, otherwise only on</span>
<span class="sd">                                                        a particular axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ma.MaskedArray):                     an array with the</span>
<span class="sd">                                                        quantiles (the first</span>
<span class="sd">                                                        dimension will be the</span>
<span class="sd">                                                        same length as probs).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; get_quantiles(0)</span>
<span class="sd">            array([], dtype=float64)</span>

<span class="sd">            &gt;&gt;&gt; get_quantiles(1)</span>
<span class="sd">            array([ 0.5])</span>

<span class="sd">            &gt;&gt;&gt; get_quantiles(3)</span>
<span class="sd">            array([ 0.25,  0.5 ,  0.75])</span>

<span class="sd">            &gt;&gt;&gt; get_quantiles(0.5)</span>
<span class="sd">            array([ 0.5])</span>

<span class="sd">            &gt;&gt;&gt; get_quantiles([0.25, 0.75])</span>
<span class="sd">            array([ 0.25,  0.75])</span>

<span class="sd">            &gt;&gt;&gt; get_quantiles(numpy.array([0.25, 0.75]))</span>
<span class="sd">            array([ 0.25,  0.75])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">probs_type</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="n">probs_type</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span><span class="o">.</span><span class="n">type</span>

    <span class="n">probs_array</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">probs_type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="n">num_quantiles</span> <span class="o">=</span> <span class="n">probs</span>
        <span class="n">probs_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_quantiles</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">probs_type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="n">a_quantile</span> <span class="o">=</span> <span class="n">probs</span>
        <span class="n">probs_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a_quantile</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">probs_array</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>
        <span class="n">probs_array</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>


    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">probs_array</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">probs_array</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">():</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
        <span class="s">&quot;Cannot pass values that are not within the range (0, 1).&quot;</span>
    <span class="p">)</span>


    <span class="k">return</span><span class="p">(</span><span class="n">probs_array</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="quantile"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.quantile">[docs]</a><span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the quantiles for given data much like MATLAB&#39;s function.</span>

<span class="sd">        Args:</span>
<span class="sd">            data(numpy.ndarray):                        to find the quantiles</span>
<span class="sd">                                                        of.</span>

<span class="sd">            probs(int or float or numpy.ndarray):       either some sort of</span>
<span class="sd">                                                        integer for the number</span>
<span class="sd">                                                        of quantiles or a</span>
<span class="sd">                                                        single float specifying</span>
<span class="sd">                                                        which quantile to get</span>
<span class="sd">                                                        or an array of floats</span>
<span class="sd">                                                        specifying the division</span>
<span class="sd">                                                        for each quantile in</span>
<span class="sd">                                                        the range (0, 1).</span>

<span class="sd">            axis(int or None):                          the axis to perform the</span>
<span class="sd">                                                        calculation on (if</span>
<span class="sd">                                                        default (None) then</span>
<span class="sd">                                                        all, otherwise only on</span>
<span class="sd">                                                        a particular axis.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ma.MaskedArray):                     an array with the</span>
<span class="sd">                                                        quantiles (the first</span>
<span class="sd">                                                        dimension will be the</span>
<span class="sd">                                                        same length as probs).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; quantile(numpy.array([ 1.,  2.,  3.]), 2)</span>
<span class="sd">            masked_array(data = [ 1.5  2.5],</span>
<span class="sd">                         mask = False,</span>
<span class="sd">                   fill_value = nan)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; quantile(numpy.array([ 1.,  2.,  3.]), 3)</span>
<span class="sd">            masked_array(data = [ 1.25  2.    2.75],</span>
<span class="sd">                         mask = False,</span>
<span class="sd">                   fill_value = nan)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; quantile(</span>
<span class="sd">            ...     numpy.array([ 1.,  2.,  3.]),</span>
<span class="sd">            ...     numpy.array([ 0.25,  0.5,  0.75])</span>
<span class="sd">            ... )</span>
<span class="sd">            masked_array(data = [ 1.25  2.    2.75],</span>
<span class="sd">                         mask = False,</span>
<span class="sd">                   fill_value = nan)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; quantile(numpy.array([ 1.,  2.,  3.]), 0.5)</span>
<span class="sd">            masked_array(data = [ 2.],</span>
<span class="sd">                         mask = False,</span>
<span class="sd">                   fill_value = nan)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>

<span class="sd">            &gt;&gt;&gt; a = numpy.array([[-1.1176, -0.0679, -0.3031,  0.8261],</span>
<span class="sd">            ...                  [ 1.2607, -0.1952,  0.023 ,  1.527 ],</span>
<span class="sd">            ...                  [ 0.6601, -0.2176,  0.0513,  0.4669]])</span>
<span class="sd">            &gt;&gt;&gt; quantile(a, 2, axis = 0)</span>
<span class="sd">            masked_array(data =</span>
<span class="sd">             [[-0.22875 -0.2064  -0.14005  0.6465 ]</span>
<span class="sd">             [ 0.9604  -0.13155  0.03715  1.17655]],</span>
<span class="sd">                         mask =</span>
<span class="sd">             False,</span>
<span class="sd">                   fill_value = nan)</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">probs_array</span> <span class="o">=</span> <span class="n">get_quantiles</span><span class="p">(</span><span class="n">probs</span><span class="p">)</span>

    <span class="n">new_quantiles</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">mstats</span><span class="o">.</span><span class="n">mquantiles</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">probs_array</span><span class="p">,</span> <span class="n">alphap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">betap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_quantiles</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">new_quantiles</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">new_quantiles</span><span class="p">)</span>

    <span class="n">new_quantiles</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_quantiles</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="binomial_coefficients"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.binomial_coefficients">[docs]</a><span class="k">def</span> <span class="nf">binomial_coefficients</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a row in Pascal&#39;s triangle (binomial coefficients).</span>

<span class="sd">        Args:</span>
<span class="sd">            n(int):                 which row of Pascal&#39;s triangle to return.</span>

<span class="sd">        Returns:</span>
<span class="sd">            cs(numpy.ndarray):      a numpy array containing the row of</span>
<span class="sd">                                    Pascal&#39;s triangle.</span>


<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; binomial_coefficients(-25)</span>
<span class="sd">            array([], dtype=int64)</span>

<span class="sd">            &gt;&gt;&gt; binomial_coefficients(-1)</span>
<span class="sd">            array([], dtype=int64)</span>

<span class="sd">            &gt;&gt;&gt; binomial_coefficients(0)</span>
<span class="sd">            array([1])</span>

<span class="sd">            &gt;&gt;&gt; binomial_coefficients(1)</span>
<span class="sd">            array([1, 1])</span>

<span class="sd">            &gt;&gt;&gt; binomial_coefficients(2)</span>
<span class="sd">            array([1, 2, 1])</span>

<span class="sd">            &gt;&gt;&gt; binomial_coefficients(4)</span>
<span class="sd">            array([1, 4, 6, 4, 1])</span>

<span class="sd">            &gt;&gt;&gt; binomial_coefficients(4.0)</span>
<span class="sd">            array([1, 4, 6, 4, 1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Must be integer</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c"># Below -1 is all the same.</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c"># Get enough repeats of n to get each coefficent</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Get all relevant k&#39;s</span>
    <span class="n">ks</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c"># Get all the coefficents in order</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">misc</span><span class="o">.</span><span class="n">comb</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">ks</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
    <span class="n">cs</span> <span class="o">=</span> <span class="n">cs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="line_filter"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.line_filter">[docs]</a><span class="k">def</span> <span class="nf">line_filter</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a boolean array mask for a line. This mask has size for the</span>
<span class="sd">        length of the line and number of empty lines beside it in any</span>
<span class="sd">        orthogonal direction. The mask has dimensions equal to ndims and the</span>
<span class="sd">        line is placed along dimension ``dim``.</span>

<span class="sd">        Args:</span>
<span class="sd">            shape(tuple of ints):   the distance from the center of the filter</span>
<span class="sd">                                    to the nearest edge for each dimension.</span>

<span class="sd">            dim(int):               the dimension to put the line along.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):        a boolean array to use as the filter.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; line_filter((1,1))</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [ True,  True,  True],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; line_filter((1,1), dim = -1)</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [ True,  True,  True],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; line_filter((1,1), dim = 1)</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [ True,  True,  True],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; line_filter((2,1))</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [False, False, False],</span>
<span class="sd">                   [ True,  True,  True],</span>
<span class="sd">                   [False, False, False],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; line_filter((1, 1, 1))</span>
<span class="sd">            array([[[False, False, False],</span>
<span class="sd">                    [False, False, False],</span>
<span class="sd">                    [False, False, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[False, False, False],</span>
<span class="sd">                    [ True,  True,  True],</span>
<span class="sd">                    [False, False, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[False, False, False],</span>
<span class="sd">                    [False, False, False],</span>
<span class="sd">                    [False, False, False]]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">line</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([(</span><span class="mi">2</span><span class="o">*</span><span class="n">_</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">line_loc</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">line_loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">line</span><span class="p">[</span><span class="n">line_loc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="symmetric_line_filter"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.symmetric_line_filter">[docs]</a><span class="k">def</span> <span class="nf">symmetric_line_filter</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">ndims</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a boolean array mask for a line. This mask has size for the</span>
<span class="sd">        length of the line and number of empty lines beside it in any</span>
<span class="sd">        orthogonal direction. The mask has dimensions equal to ndims and the</span>
<span class="sd">        line is placed along dimension dim.</span>

<span class="sd">        Args:</span>
<span class="sd">            size(int):          the distance from the center of the filter to</span>
<span class="sd">                                the nearest edge.</span>

<span class="sd">            ndims(int):         the number of dimensions for the filter.</span>

<span class="sd">            dim(int):           the dimension to put the line along.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):    a boolean array to use as the filter.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; symmetric_line_filter(1)</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [ True,  True,  True],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; symmetric_line_filter(1, ndims = 2, dim = -1)</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [ True,  True,  True],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; symmetric_line_filter(1, ndims = 2, dim = 1)</span>
<span class="sd">            array([[False, False, False],</span>
<span class="sd">                   [ True,  True,  True],</span>
<span class="sd">                   [False, False, False]], dtype=bool)</span>

<span class="sd">            &gt;&gt;&gt; symmetric_line_filter(1, ndims = 3)</span>
<span class="sd">            array([[[False, False, False],</span>
<span class="sd">                    [False, False, False],</span>
<span class="sd">                    [False, False, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[False, False, False],</span>
<span class="sd">                    [ True,  True,  True],</span>
<span class="sd">                    [False, False, False]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[False, False, False],</span>
<span class="sd">                    [False, False, False],</span>
<span class="sd">                    [False, False, False]]], dtype=bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">assert</span> <span class="p">(</span><span class="o">-</span><span class="n">ndims</span> <span class="o">&lt;=</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="n">ndims</span><span class="p">)</span>

    <span class="n">line</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ndims</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">line_loc</span> <span class="o">=</span> <span class="n">ndims</span> <span class="o">*</span> <span class="p">[</span><span class="n">size</span><span class="p">]</span>
    <span class="n">line_loc</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">line</span><span class="p">[</span><span class="n">line_loc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

</div>
<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="tagging_reorder_array"><a class="viewcode-back" href="../../../nanshe.util.xnumpy.html#nanshe.util.xnumpy.tagging_reorder_array">[docs]</a><span class="k">def</span> <span class="nf">tagging_reorder_array</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span>
                          <span class="n">from_axis_order</span><span class="o">=</span><span class="s">&quot;tzyxc&quot;</span><span class="p">,</span>
                          <span class="n">to_axis_order</span><span class="o">=</span><span class="s">&quot;tzyxc&quot;</span><span class="p">,</span>
                          <span class="n">to_copy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms one axis ordering to another giving a view of the array</span>
<span class="sd">        (unless otherwise specified).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_array(numpy.ndarray):                   the array to reorder</span>

<span class="sd">            from_axis_order(str or list of str):        current labeled axis</span>
<span class="sd">                                                        order.</span>

<span class="sd">            to_axis_order(str or list of str):          desired labeled axis</span>
<span class="sd">                                                        order</span>

<span class="sd">            to_copy(bool):                              whether to return a</span>
<span class="sd">                                                        view or a copy</span>

<span class="sd">        Returns:</span>
<span class="sd">            (numpy.ndarray):                            an array with the axis</span>
<span class="sd">                                                        order specified (view).</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(numpy.ones((1,2,3,4,5))).shape</span>
<span class="sd">            (1, 2, 3, 4, 5)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     from_axis_order = &quot;tzyxc&quot;</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (1, 2, 3, 4, 5)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     to_axis_order = &quot;tzyxc&quot;</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (1, 2, 3, 4, 5)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     from_axis_order = &quot;tzyxc&quot;,</span>
<span class="sd">            ...     to_axis_order = &quot;tzyxc&quot;</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (1, 2, 3, 4, 5)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     from_axis_order = &quot;txyzc&quot;</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (1, 4, 3, 2, 5)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     from_axis_order = &quot;ctxyz&quot;</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (2, 5, 4, 3, 1)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     to_axis_order = &quot;txyzc&quot;</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (1, 4, 3, 2, 5)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     from_axis_order = [&quot;c&quot;,&quot;t&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (2, 5, 4, 3, 1)</span>

<span class="sd">            &gt;&gt;&gt; tagging_reorder_array(</span>
<span class="sd">            ...     numpy.ones((1,2,3,4,5)),</span>
<span class="sd">            ...     to_axis_order = [&quot;t&quot;,&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;c&quot;]</span>
<span class="sd">            ... ).shape</span>
<span class="sd">            (1, 4, 3, 2, 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">from_axis_order</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">from_axis_order</span><span class="p">)</span>
    <span class="n">to_axis_order</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">to_axis_order</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">from_axis_order</span> <span class="o">!=</span> <span class="n">to_axis_order</span><span class="p">):</span>
        <span class="c"># Change view to the specified one</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">taggedView</span><span class="p">(</span><span class="n">new_array</span><span class="p">,</span> <span class="n">from_axis_order</span><span class="p">)</span>
        <span class="c"># Reorder to the user specified one</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">withAxes</span><span class="p">(</span><span class="o">*</span><span class="n">to_axis_order</span><span class="p">)</span>
        <span class="c"># Dump the VIGRA array as we do not care</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">to_copy</span><span class="p">:</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_array</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../../index.html">nanshe 0.1.0a18 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2014-2015, John A. Kirkham.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>