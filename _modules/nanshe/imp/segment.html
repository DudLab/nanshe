

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nanshe.imp.segment &mdash; nanshe 0.1.0a53+27.g5dee726 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.0a53+27.g5dee726',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="../../../_static/cloud.js"></script>
    <link rel="top" title="nanshe 0.1.0a53+27.g5dee726 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body role="document">
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../../index.html">nanshe 0.1.0a53+27.g5dee726 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nanshe.imp.segment</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The ``segment`` module has components to make an image processing workflow.</span>

<span class="sd">===============================================================================</span>
<span class="sd">Overview</span>
<span class="sd">===============================================================================</span>
<span class="sd">The ``segment`` (or **segment**\ ation) module contains algorithms useful in</span>
<span class="sd">implementing ADINA ( doi:`10.1109/ISBI.2013.6556660`_ ), but could be reused in</span>
<span class="sd">other workflows. These primary sections can be grouped as follows</span>

<span class="sd">1. Preprocessing steps</span>

<span class="sd">   a. registration correction (\</span>
<span class="sd">      :py:func:`~nanshe.imp.segment.remove_zeroed_lines` )</span>
<span class="sd">   #. background estimation and subtraction (\</span>
<span class="sd">      :py:func:`~nanshe.imp.segment.estimate_f0`,\</span>
<span class="sd">      :py:func:`~nanshe.imp.segment.extract_f0` )</span>
<span class="sd">   #. wavelet transform ( :py:func:`~nanshe.imp.filters.wavelet.transform` )</span>
<span class="sd">   #. normalization ( :py:func:`~nanshe.imp.segment.normalize_data` )</span>
<span class="sd">#. Dictionary learning step (\</span>
<span class="sd">    :py:func:`~nanshe.imp.segment.generate_dictionary` )</span>
<span class="sd">#. Postprocessing</span>

<span class="sd">   a. segmentation and refinement (\</span>
<span class="sd">      :py:func:`~nanshe.imp.segment.wavelet_denoising` )</span>
<span class="sd">   #. merging ( :py:func:`~nanshe.imp.segment.merge_neuron_sets` )</span>

<span class="sd">.. _`10.1109/ISBI.2013.6556660`: http://dx.doi.org/10.1109/ISBI.2013.6556660</span>

<span class="sd">===============================================================================</span>
<span class="sd">API</span>
<span class="sd">===============================================================================</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;John Kirkham &lt;kirkhamj@janelia.hhmi.org&gt;&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;$Apr 30, 2014 17:23:37 EDT$&quot;</span>


<span class="c1"># Allows for type conversions for C/C++ functions.</span>
<span class="kn">import</span> <span class="nn">ctypes</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1"># Generally useful and fast to import so done immediately.</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c1"># For image processing.</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage</span>
<span class="kn">import</span> <span class="nn">scipy.ndimage.filters</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">scipy.spatial.distance</span>

<span class="c1"># More image processing...</span>
<span class="kn">import</span> <span class="nn">skimage</span>
<span class="kn">import</span> <span class="nn">skimage.measure</span>
<span class="kn">import</span> <span class="nn">skimage.feature</span>
<span class="kn">import</span> <span class="nn">skimage.morphology</span>
<span class="kn">import</span> <span class="nn">skimage.segmentation</span>

<span class="kn">from</span> <span class="nn">nanshe.util</span> <span class="kn">import</span> <span class="n">iters</span>

<span class="c1"># To allow for more advanced iteration patterns</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="c1"># Allows for deep and shallow copies.</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="c1"># Need for opening</span>
<span class="kn">import</span> <span class="nn">vigra</span>
<span class="kn">import</span> <span class="nn">vigra.filters</span>
<span class="kn">import</span> <span class="nn">vigra.analysis</span>

<span class="c1"># Contains an optimized linear rank order filter.</span>
<span class="kn">import</span> <span class="nn">rank_filter</span>

<span class="c1"># Need in order to have logging information no matter what.</span>
<span class="kn">from</span> <span class="nn">nanshe.util</span> <span class="kn">import</span> <span class="n">prof</span>

<span class="kn">from</span> <span class="nn">nanshe.util</span> <span class="kn">import</span> <span class="n">xnumpy</span>

<span class="c1"># Short function to process image data.</span>
<span class="kn">from</span> <span class="nn">nanshe.imp</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="kn">from</span> <span class="nn">nanshe.imp.renorm</span> <span class="kn">import</span> <span class="n">zeroed_mean_images</span><span class="p">,</span> <span class="n">renormalized_images</span>

<span class="c1"># Algorithms to register the data.</span>
<span class="kn">from</span> <span class="nn">nanshe.imp</span> <span class="kn">import</span> <span class="n">registration</span>

<span class="c1"># To remove noise from the basis images</span>
<span class="kn">from</span> <span class="nn">nanshe.imp.filters.noise</span> <span class="kn">import</span> <span class="n">estimate_noise</span><span class="p">,</span> <span class="n">significant_mask</span>

<span class="c1"># Wavelet transformation operations</span>
<span class="kn">from</span> <span class="nn">nanshe.imp.filters</span> <span class="kn">import</span> <span class="n">wavelet</span>

<span class="kn">from</span> <span class="nn">nanshe.io</span> <span class="kn">import</span> <span class="n">hdf5</span>


<span class="c1"># Get the logger</span>
<span class="n">trace_logger</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">getTraceLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">prof</span><span class="o">.</span><span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="remove_zeroed_lines"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.remove_zeroed_lines">[docs]</a><span class="k">def</span> <span class="nf">remove_zeroed_lines</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span>
                        <span class="n">erosion_shape</span><span class="p">,</span>
                        <span class="n">dilation_shape</span><span class="p">,</span>
                        <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Due to registration errors, there will sometimes be lines that are</span>
<span class="sd">        zero. To correct this, we find an interpolated value to replace the</span>
<span class="sd">        zeros with. If that fails, we copy nearby values over.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_data(numpy.ndarray):            data to remove lines from (</span>
<span class="sd">                                                first axis is time).</span>

<span class="sd">            erosion_shape(numpy.ndarray):       shape of the erosion element</span>
<span class="sd">                                                (will be filled with 1).</span>

<span class="sd">            dilation_shape(numpy.ndarray):      shape of the dilation element</span>
<span class="sd">                                                (will be filled with 1).</span>

<span class="sd">            out(numpy.ndarray):                 where the final results will be</span>
<span class="sd">                                                stored.</span>

<span class="sd">            **parameters(dict):                 essentially unused (catches</span>
<span class="sd">                                                unneeded arguments).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                      a new array with the zeroed</span>
<span class="sd">                                                lines interpolated away.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_data</span>

    <span class="c1"># Get an outline of certain regions in the image that contain zeros</span>
    <span class="n">erosion_structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">erosion_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">dilation_structure</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dilation_shape</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="n">zero_masks_eroded</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">zero_masks_dilated</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">zero_masks_outline</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">new_data_i</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">zero_mask_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_data_i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">zero_mask_i</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">masks</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span>
            <span class="n">zero_mask_i</span><span class="p">,</span> <span class="n">erosion_structure</span>
        <span class="p">)</span>

        <span class="n">zero_masks_eroded</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_mask_i</span>

        <span class="n">zero_mask_i_labeled</span><span class="p">,</span> <span class="n">zero_mask_i_num_labels</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span>
            <span class="n">zero_mask_i</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">zero_mask_i_num_labels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">zero_mask_i_labeled_j</span> <span class="o">=</span> <span class="p">(</span><span class="n">zero_mask_i_labeled</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span>

            <span class="n">zero_mask_i_labeled_j_dilated</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">masks</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span>
                <span class="n">zero_mask_i_labeled_j</span><span class="p">,</span> <span class="n">dilation_structure</span>
            <span class="p">)</span>

            <span class="n">zero_mask_i_labeled_j_outline</span> <span class="o">=</span> <span class="n">zero_mask_i_labeled_j_dilated</span> <span class="o">-</span> <span class="n">zero_mask_i_labeled_j</span>

            <span class="n">zero_masks_dilated</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">zero_mask_i_labeled_j_dilated</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">zero_masks_outline</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">zero_mask_i_labeled_j_outline</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

            <span class="k">if</span> <span class="n">zero_mask_i_labeled_j_outline</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># Get the points that correspond to those</span>
                <span class="n">zero_mask_i_labeled_j_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">zero_mask_i_labeled_j</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">zero_mask_i_labeled_j_outline_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">zero_mask_i_labeled_j_outline</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">zero_mask_i_labeled_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">griddata</span><span class="p">(</span>
                        <span class="n">zero_mask_i_labeled_j_outline_points</span><span class="p">,</span>
                        <span class="n">new_data_i</span><span class="p">[</span><span class="n">zero_mask_i_labeled_j_outline</span><span class="p">],</span>
                        <span class="n">zero_mask_i_labeled_j_points</span><span class="p">,</span>
                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span>
                    <span class="p">)</span>

                    <span class="c1"># Only need to check for nan in our case.</span>
                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">zero_mask_i_labeled_j</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
                    <span class="n">zero_mask_i_labeled_j_points_arange</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">zero_mask_i_labeled_j_points</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">zero_mask_i_labeled_j_outline_points_arange</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">zero_mask_i_labeled_j_outline_points</span><span class="p">)</span>
                    <span class="p">)</span>

                    <span class="n">zero_mask_i_labeled_j_points_arange_tile</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">expand_view</span><span class="p">(</span>
                        <span class="n">zero_mask_i_labeled_j_points_arange</span><span class="p">,</span>
                        <span class="n">reps_before</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span>
                            <span class="n">zero_mask_i_labeled_j_outline_points_arange</span>
                        <span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                    <span class="n">zero_mask_i_labeled_j_outline_points_arange_repeat</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">expand_view</span><span class="p">(</span>
                        <span class="n">zero_mask_i_labeled_j_outline_points_arange</span><span class="p">,</span>
                        <span class="n">reps_after</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span>
                            <span class="n">zero_mask_i_labeled_j_points_arange</span>
                        <span class="p">)</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

                    <span class="n">index_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span>
                        <span class="n">zero_mask_i_labeled_j_points_arange_tile</span><span class="p">,</span>
                        <span class="n">zero_mask_i_labeled_j_outline_points_arange_repeat</span>
                    <span class="p">])</span>

                    <span class="n">out_spatial_points</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">zero_mask_i_labeled_j_points</span><span class="p">[(</span><span class="n">index_product</span><span class="p">[</span><span class="mi">0</span><span class="p">],)]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>
                    <span class="n">new_data_i_spatial_points</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">zero_mask_i_labeled_j_outline_points</span><span class="p">[(</span><span class="n">index_product</span><span class="p">[</span><span class="mi">1</span><span class="p">],)]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>

                    <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">out_spatial_points</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data_i</span><span class="p">[</span><span class="n">new_data_i_spatial_points</span><span class="p">]</span>

    <span class="n">remove_zeroed_lines</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;zero_masks_eroded&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_masks_eroded</span>
    <span class="n">remove_zeroed_lines</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;zero_masks_dilated&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_masks_dilated</span>
    <span class="n">remove_zeroed_lines</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;zero_masks_outline&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_masks_outline</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="estimate_f0"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.estimate_f0">[docs]</a><span class="k">def</span> <span class="nf">estimate_f0</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span>
                <span class="n">half_window_size</span><span class="p">,</span>
                <span class="n">which_quantile</span><span class="p">,</span>
                <span class="n">temporal_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
                <span class="n">temporal_smoothing_gaussian_filter_window_size</span><span class="p">,</span>
                <span class="n">spatial_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
                <span class="n">spatial_smoothing_gaussian_filter_window_size</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimates F_0 using a rank order filter with some smoothing.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_data(numpy.ndarray):                                array of</span>
<span class="sd">                                                                    data for</span>
<span class="sd">                                                                    finding</span>
<span class="sd">                                                                    baseline (</span>
<span class="sd">                                                                    first axis</span>
<span class="sd">                                                                    is time).</span>

<span class="sd">            half_window_size(int):                                  the rank</span>
<span class="sd">                                                                    filter</span>
<span class="sd">                                                                    window size</span>
<span class="sd">                                                                    is</span>
<span class="sd">                                                                    2*half_window_size+1.</span>

<span class="sd">            which_quantile(float):                                  which</span>
<span class="sd">                                                                    quantile to</span>
<span class="sd">                                                                    return from</span>
<span class="sd">                                                                    the rank</span>
<span class="sd">                                                                    filter.</span>

<span class="sd">            temporal_smoothing_gaussian_filter_stdev(float):        stdev for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter</span>
<span class="sd">                                                                    to convolve</span>
<span class="sd">                                                                    over time.</span>

<span class="sd">            temporal_smoothing_gaussian_filter_window_size(float):  window for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter to</span>
<span class="sd">                                                                    convolve</span>
<span class="sd">                                                                    over time.</span>
<span class="sd">                                                                    (Measured</span>
<span class="sd">                                                                    in standard</span>
<span class="sd">                                                                    deviations)</span>

<span class="sd">            spatial_smoothing_gaussian_filter_stdev(float):         stdev for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter to</span>
<span class="sd">                                                                    convolve</span>
<span class="sd">                                                                    over space.</span>

<span class="sd">            spatial_smoothing_gaussian_filter_window_size(float):   window for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter</span>
<span class="sd">                                                                    to convolve</span>
<span class="sd">                                                                    over space.</span>
<span class="sd">                                                                    (Measured</span>
<span class="sd">                                                                    in standard</span>
<span class="sd">                                                                    deviations)</span>

<span class="sd">            out(numpy.ndarray):                                     where the</span>
<span class="sd">                                                                    final</span>
<span class="sd">                                                                    result</span>
<span class="sd">                                                                    will be</span>
<span class="sd">                                                                    stored.</span>

<span class="sd">            **parameters(dict):                                     essentially</span>
<span class="sd">                                                                    unused (</span>
<span class="sd">                                                                    catches</span>
<span class="sd">                                                                    unneeded</span>
<span class="sd">                                                                    arguments).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                                          the F_0</span>
<span class="sd">                                                                    estimate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Provided new_data with type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span>
            <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">. &quot;</span> <span class="o">+</span> <span class="s2">&quot;Will be cast to type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="ne">RuntimeWarning</span>
        <span class="p">)</span>

    <span class="n">converted_out</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">new_data_f0_estimation</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">new_data_f0_estimation</span> <span class="o">=</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_data</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Provided new_data with type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">. &quot;</span> <span class="o">+</span> <span class="s2">&quot;Will be cast to type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">+</span>
                <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span>
            <span class="p">)</span>

            <span class="n">converted_out</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">new_data_f0_estimation</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_data_f0_estimation</span> <span class="o">=</span> <span class="n">out</span>


    <span class="n">temporal_smoothing_gaussian_filter</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussianKernel</span><span class="p">(</span>
        <span class="n">temporal_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
        <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">temporal_smoothing_gaussian_filter_window_size</span>
    <span class="p">)</span>

    <span class="n">temporal_smoothing_gaussian_filter</span><span class="o">.</span><span class="n">setBorderTreatment</span><span class="p">(</span>
        <span class="n">vigra</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">BorderTreatmentMode</span><span class="o">.</span><span class="n">BORDER_TREATMENT_REFLECT</span><span class="p">)</span>

    <span class="n">vigra</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">convolveOneDimension</span><span class="p">(</span>
        <span class="n">new_data_f0_estimation</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
        <span class="n">temporal_smoothing_gaussian_filter</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">new_data_f0_estimation</span>
    <span class="p">)</span>


    <span class="n">which_quantile_len</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">which_quantile_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">which_quantile</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># Does not have len</span>
        <span class="n">which_quantile_len</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Only allowed to have one quantile.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">which_quantile_len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;Provided more than one quantile </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">which_quantile</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">rank_filter</span><span class="o">.</span><span class="n">lineRankOrderFilter</span><span class="p">(</span>
        <span class="n">new_data_f0_estimation</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulong</span><span class="p">(</span><span class="n">half_window_size</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="n">which_quantile</span><span class="p">,</span>
        <span class="n">ctypes</span><span class="o">.</span><span class="n">c_uint</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">new_data_f0_estimation</span>
    <span class="p">)</span>

    <span class="n">spatial_smoothing_gaussian_filter</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussianKernel</span><span class="p">(</span>
        <span class="n">spatial_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
        <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">spatial_smoothing_gaussian_filter_window_size</span>
    <span class="p">)</span>

    <span class="n">spatial_smoothing_gaussian_filter</span><span class="o">.</span><span class="n">setBorderTreatment</span><span class="p">(</span>
        <span class="n">vigra</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">BorderTreatmentMode</span><span class="o">.</span><span class="n">BORDER_TREATMENT_REFLECT</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">new_data_f0_estimation</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">vigra</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">convolveOneDimension</span><span class="p">(</span>
            <span class="n">new_data_f0_estimation</span><span class="p">,</span>
            <span class="n">d</span><span class="p">,</span>
            <span class="n">spatial_smoothing_gaussian_filter</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">new_data_f0_estimation</span>
        <span class="p">)</span>

    <span class="n">estimate_f0</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_data_f0_estimation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data_f0_estimation</span>

    <span class="k">if</span> <span class="n">converted_out</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_data_f0_estimation</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="extract_f0"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.extract_f0">[docs]</a><span class="k">def</span> <span class="nf">extract_f0</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span>
               <span class="n">half_window_size</span><span class="p">,</span>
               <span class="n">which_quantile</span><span class="p">,</span>
               <span class="n">temporal_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
               <span class="n">temporal_smoothing_gaussian_filter_window_size</span><span class="p">,</span>
               <span class="n">spatial_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
               <span class="n">spatial_smoothing_gaussian_filter_window_size</span><span class="p">,</span>
               <span class="n">bias</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">return_f0</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to find an estimate for dF/F.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_data(numpy.ndarray):                                array of</span>
<span class="sd">                                                                    data for</span>
<span class="sd">                                                                    finding</span>
<span class="sd">                                                                    baseline (</span>
<span class="sd">                                                                    first axis</span>
<span class="sd">                                                                    is time).</span>

<span class="sd">            half_window_size(int):                                  the rank</span>
<span class="sd">                                                                    filter</span>
<span class="sd">                                                                    window size</span>
<span class="sd">                                                                    is</span>
<span class="sd">                                                                    2*half_window_size+1.</span>

<span class="sd">            which_quantile(float):                                  which</span>
<span class="sd">                                                                    quantile to</span>
<span class="sd">                                                                    return from</span>
<span class="sd">                                                                    the rank</span>
<span class="sd">                                                                    filter.</span>

<span class="sd">            temporal_smoothing_gaussian_filter_stdev(float):        stdev for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter to</span>
<span class="sd">                                                                    convolve</span>
<span class="sd">                                                                    over time.</span>

<span class="sd">            temporal_smoothing_gaussian_filter_window_size(float):  window for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter to</span>
<span class="sd">                                                                    convolve</span>
<span class="sd">                                                                    over time.</span>
<span class="sd">                                                                    (Measured</span>
<span class="sd">                                                                    in standard</span>
<span class="sd">                                                                    deviations)</span>

<span class="sd">            spatial_smoothing_gaussian_filter_stdev(float):         stdev for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter to</span>
<span class="sd">                                                                    convolve</span>
<span class="sd">                                                                    over space.</span>

<span class="sd">            spatial_smoothing_gaussian_filter_window_size(float):   window for</span>
<span class="sd">                                                                    gaussian</span>
<span class="sd">                                                                    filter</span>
<span class="sd">                                                                    to convolve</span>
<span class="sd">                                                                    over space.</span>
<span class="sd">                                                                    (Measured</span>
<span class="sd">                                                                    in standard</span>
<span class="sd">                                                                    deviations)</span>

<span class="sd">            bias(float):                                            value to be</span>
<span class="sd">                                                                    added to</span>
<span class="sd">                                                                    dataset to</span>
<span class="sd">                                                                    avoid nan.</span>

<span class="sd">            out(numpy.ndarray):                                     where the</span>
<span class="sd">                                                                    final</span>
<span class="sd">                                                                    result will</span>
<span class="sd">                                                                    be stored.</span>

<span class="sd">            return_f0(bool):                                        whether to</span>
<span class="sd">                                                                    return F_0</span>
<span class="sd">                                                                    also, F_0</span>
<span class="sd">                                                                    will be</span>
<span class="sd">                                                                    returned</span>
<span class="sd">                                                                    first.</span>

<span class="sd">            **parameters(dict):                                     essentially</span>
<span class="sd">                                                                    unused (</span>
<span class="sd">                                                                    catches</span>
<span class="sd">                                                                    unneeded</span>
<span class="sd">                                                                    arguments).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple of numpy.ndarray):                               dF/F or if</span>
<span class="sd">                                                                    return_f0</span>
<span class="sd">                                                                    is True a</span>
<span class="sd">                                                                    tuple (F_0,</span>
<span class="sd">                                                                    dF/F).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Provided new_data with type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span>
            <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">. &quot;</span> <span class="o">+</span> <span class="s2">&quot;Will be cast to type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="ne">RuntimeWarning</span>
        <span class="p">)</span>

    <span class="n">new_data_df_over_f</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">new_data_df_over_f</span> <span class="o">=</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Provided new_data with type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="o">+</span>
                <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">. &quot;</span> <span class="o">+</span> <span class="s2">&quot;Will be cast to type </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">+</span>
                <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="ne">RuntimeWarning</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
            <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_data</span>

        <span class="n">new_data_df_over_f</span> <span class="o">=</span> <span class="n">out</span>

    <span class="c1"># Find the bias parameter if not provided</span>
    <span class="k">if</span> <span class="n">bias</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">bias</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">new_data</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="n">new_data_f0_estimation</span> <span class="o">=</span> <span class="n">new_data_df_over_f</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">estimate_f0</span><span class="p">(</span>
        <span class="n">new_data_f0_estimation</span><span class="p">,</span>
        <span class="n">half_window_size</span><span class="p">,</span>
        <span class="n">which_quantile</span><span class="p">,</span>
        <span class="n">temporal_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
        <span class="n">temporal_smoothing_gaussian_filter_window_size</span><span class="p">,</span>
        <span class="n">spatial_smoothing_gaussian_filter_stdev</span><span class="p">,</span>
        <span class="n">spatial_smoothing_gaussian_filter_window_size</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">new_data_f0_estimation</span><span class="p">,</span>
        <span class="o">**</span><span class="n">parameters</span>
    <span class="p">)</span>

    <span class="c1"># Compute dF/F. Add a bias to denominator to ensure there is no division</span>
    <span class="c1"># by zero.</span>
    <span class="n">new_data_df_over_f</span> <span class="o">-=</span> <span class="n">new_data_f0_estimation</span>
    <span class="n">new_data_df_over_f</span> <span class="o">/=</span> <span class="p">(</span><span class="n">new_data_f0_estimation</span> <span class="o">+</span> <span class="n">bias</span><span class="p">)</span>

    <span class="n">extract_f0</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_data_df_over_f&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data_df_over_f</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">return_f0</span><span class="p">):</span>
        <span class="k">return</span><span class="p">(</span><span class="n">new_data_f0_estimation</span><span class="p">,</span> <span class="n">new_data_df_over_f</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="n">new_data_df_over_f</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="normalize_data"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.normalize_data">[docs]</a><span class="k">def</span> <span class="nf">normalize_data</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the mean from each image and normalizes each image as if they</span>
<span class="sd">        were vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_data(numpy.ndarray):                array of data for</span>
<span class="sd">                                                    normalization (first axis</span>
<span class="sd">                                                    is time).</span>

<span class="sd">            **parameters(dict):                     contains arguments for</span>
<span class="sd">                                                    renormalized_images.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                          data that has been</span>
<span class="sd">                                                    normalized.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; a = numpy.zeros((2,2,2,))</span>
<span class="sd">            &gt;&gt;&gt; a[1,1,1] = 1</span>
<span class="sd">            &gt;&gt;&gt; a[0,0,0] = 1</span>
<span class="sd">            &gt;&gt;&gt; normalize_data(a)</span>
<span class="sd">            array([[[ 0.8660254 , -0.28867513],</span>
<span class="sd">                    [-0.28867513, -0.28867513]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[-0.28867513, -0.28867513],</span>
<span class="sd">                    [-0.28867513,  0.8660254 ]]])</span>
<span class="sd">            &gt;&gt;&gt; normalize_data(a, **{&quot;renormalized_images&quot; : { &quot;ord&quot; : 2 }})</span>
<span class="sd">            array([[[ 0.8660254 , -0.28867513],</span>
<span class="sd">                    [-0.28867513, -0.28867513]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[-0.28867513, -0.28867513],</span>
<span class="sd">                    [-0.28867513,  0.8660254 ]]])</span>
<span class="sd">            &gt;&gt;&gt; b = numpy.zeros_like(a)</span>
<span class="sd">            &gt;&gt;&gt; normalize_data(</span>
<span class="sd">            ...     a, out=b, **{&quot;renormalized_images&quot; : { &quot;ord&quot; : 2 }}</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[ 0.8660254 , -0.28867513],</span>
<span class="sd">                    [-0.28867513, -0.28867513]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[-0.28867513, -0.28867513],</span>
<span class="sd">                    [-0.28867513,  0.8660254 ]]])</span>
<span class="sd">            &gt;&gt;&gt; b</span>
<span class="sd">            array([[[ 0.8660254 , -0.28867513],</span>
<span class="sd">                    [-0.28867513, -0.28867513]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[-0.28867513, -0.28867513],</span>
<span class="sd">                    [-0.28867513,  0.8660254 ]]])</span>
<span class="sd">            &gt;&gt;&gt; normalize_data(</span>
<span class="sd">            ...     a, out=a, **{&quot;renormalized_images&quot; : { &quot;ord&quot; : 2 }}</span>
<span class="sd">            ... )</span>
<span class="sd">            array([[[ 0.8660254 , -0.28867513],</span>
<span class="sd">                    [-0.28867513, -0.28867513]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[-0.28867513, -0.28867513],</span>
<span class="sd">                    [-0.28867513,  0.8660254 ]]])</span>
<span class="sd">            &gt;&gt;&gt; a</span>
<span class="sd">            array([[[ 0.8660254 , -0.28867513],</span>
<span class="sd">                    [-0.28867513, -0.28867513]],</span>
<span class="sd">            &lt;BLANKLINE&gt;</span>
<span class="sd">                   [[-0.28867513, -0.28867513],</span>
<span class="sd">                    [-0.28867513,  0.8660254 ]]])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Make a copy of new_data or copy its contents if both arrays are not the</span>
    <span class="c1"># same.</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_data</span>

    <span class="c1"># Remove the mean of each row vector</span>
    <span class="n">zeroed_mean_images</span><span class="p">(</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">output_array</span><span class="o">=</span><span class="n">out</span>
    <span class="p">)</span>

    <span class="c1"># Renormalize each row vector using some specified normalization</span>
    <span class="n">renormalized_images</span><span class="p">(</span>
        <span class="n">out</span><span class="p">,</span>
        <span class="n">output_array</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="o">**</span><span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;renormalized_images&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="preprocess_data"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.preprocess_data">[docs]</a><span class="k">def</span> <span class="nf">preprocess_data</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs all preprocessing steps that are specified.</span>

<span class="sd">        (e.g. remove_zeroed_lines, bias, extract_f0, and wavelet.transform).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_data(numpy.ndarray):            array of data for generating a</span>
<span class="sd">                                                dictionary (first axis is</span>
<span class="sd">                                                time).</span>

<span class="sd">            out(numpy.ndarray):                 where the final result will be</span>
<span class="sd">                                                stored.</span>

<span class="sd">            **parameters(dict):                 additional parameters for each</span>
<span class="sd">                                                step of preprocessing.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict:                               the dictionary found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">id</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">id</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
        <span class="n">out</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_data</span>

    <span class="c1"># Remove lines</span>
    <span class="n">new_data_maybe_lines_removed</span> <span class="o">=</span> <span class="n">out</span>
    <span class="k">if</span> <span class="s2">&quot;remove_zeroed_lines&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="n">remove_zeroed_lines</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
        <span class="n">remove_zeroed_lines</span><span class="p">(</span>
            <span class="n">new_data_maybe_lines_removed</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">new_data_maybe_lines_removed</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;remove_zeroed_lines&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_lines_removed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data_maybe_lines_removed</span>
        <span class="k">if</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
            <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_lines_removed_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">add_singleton_op</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                <span class="n">new_data_maybe_lines_removed</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

    <span class="n">new_data_maybe_f0_result</span> <span class="o">=</span> <span class="n">new_data_maybe_lines_removed</span>
    <span class="k">if</span> <span class="s2">&quot;extract_f0&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="n">extract_f0</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
        <span class="n">extract_f0</span><span class="p">(</span>
            <span class="n">new_data_maybe_f0_result</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">new_data_maybe_f0_result</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;extract_f0&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_f0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data_maybe_f0_result</span>
        <span class="k">if</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
            <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_f0_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">add_singleton_op</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                <span class="n">new_data_maybe_f0_result</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

    <span class="n">new_data_maybe_wavelet_result</span> <span class="o">=</span> <span class="n">new_data_maybe_f0_result</span>
    <span class="k">if</span> <span class="s2">&quot;wavelet.transform&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="n">wavelet</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
        <span class="n">wavelet</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
            <span class="n">new_data_maybe_wavelet_result</span><span class="p">,</span>
            <span class="n">include_intermediates</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">include_lower_scales</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">new_data_maybe_wavelet_result</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;wavelet.transform&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_wavelet_transformed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data_maybe_wavelet_result</span>
        <span class="k">if</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
            <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_wavelet_transformed_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">add_singleton_op</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
                <span class="n">new_data_maybe_wavelet_result</span><span class="p">,</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>

    <span class="n">new_data_normalized</span> <span class="o">=</span> <span class="n">new_data_maybe_wavelet_result</span>
    <span class="n">normalize_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
    <span class="n">normalize_data</span><span class="p">(</span>
        <span class="n">new_data_normalized</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="n">new_data_normalized</span><span class="p">,</span>
        <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;normalize_data&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_normalized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data_normalized</span>
    <span class="k">if</span> <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
        <span class="n">preprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;images_normalized_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">add_singleton_op</span><span class="p">(</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
            <span class="n">new_data_normalized</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="generate_dictionary"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.generate_dictionary">[docs]</a><span class="k">def</span> <span class="nf">generate_dictionary</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span>
                        <span class="n">initial_dictionary</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">n_components</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a dictionary using the data and parameters given for trainDL.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_data(numpy.ndarray):            array of data for generating a</span>
<span class="sd">                                                dictionary (first axis is</span>
<span class="sd">                                                time).</span>

<span class="sd">            initial_dictionary(numpy.ndarray):  dictionary to start the</span>
<span class="sd">                                                algorithm with.</span>

<span class="sd">            n_components(int):                  number of components for the</span>
<span class="sd">                                                dictionary to use.</span>

<span class="sd">            **parameters(dict):                 passed directly to</span>
<span class="sd">                                                spams.trainDL.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict:                               the dictionary found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">nanshe.box</span>

    <span class="c1"># Sync the number of components with the method.</span>
    <span class="k">if</span> <span class="n">n_components</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;spams.trainDL&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="n">n_components</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;spams.trainDL&quot;</span><span class="p">][</span><span class="s2">&quot;K&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="n">n_components</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">][</span><span class="s2">&quot;n_components&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;Unknown algorithm must define `n_components`.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;spams.trainDL&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;spams.trainDL&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="n">n_components</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_components</span><span class="p">,</span>\
                <span class="s2">&quot;If `n_components` and `spams.trainDL[</span><span class="se">\&quot;</span><span class="s2">K</span><span class="se">\&quot;</span><span class="s2">]` are defined,&quot;</span> \
                <span class="s2">&quot; they should be defined the same.&quot;</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;spams.trainDL&quot;</span><span class="p">][</span><span class="s2">&quot;K&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="k">elif</span> <span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n_components&quot;</span><span class="p">,</span> <span class="n">n_components</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_components</span><span class="p">,</span>\
                <span class="s2">&quot;If `n_components` and &quot;</span> \
                <span class="s2">&quot;`sklearn.decomposition.dict_learning_online[</span><span class="se">\&quot;</span><span class="s2">n_components</span><span class="se">\&quot;</span><span class="s2">]`&quot;</span> \
                <span class="s2">&quot; are defined, they should be defined the same.&quot;</span>
            <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">][</span><span class="s2">&quot;n_components&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s2">&quot;Unknown algorithm cannot use `n_components`.&quot;</span>

    <span class="c1"># Needs to be floating point.</span>
    <span class="c1"># However, it need not be double precision as there is single precision</span>
    <span class="c1"># function signature.</span>
    <span class="n">float_dtype</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">float_ctype</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="n">float_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">float_ctype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_float</span>
    <span class="k">elif</span> <span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">:</span>
        <span class="n">float_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">float_ctype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_double</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">float_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">float_ctype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_float</span>

    <span class="c1"># Want to support NumPy types in parameters. However, SPAMS expects normal</span>
    <span class="c1"># C types. So, we convert them in advance. This was needed for the</span>
    <span class="c1"># Ilastik-based GUI.</span>
    <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;spams.trainDL&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">_v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_v</span><span class="p">)[()]</span> <span class="c1"># Convert to NumPy type</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">_v</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="n">_v</span> <span class="o">=</span> <span class="n">float_ctype</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_v</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
            <span class="n">_v</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span>

        <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;spams.trainDL&quot;</span><span class="p">][</span><span class="n">_k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_v</span>

    <span class="c1"># Requires floating point type.</span>
    <span class="n">new_data_processed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float_dtype</span><span class="p">)</span>

    <span class="c1"># Reshape data into a matrix (each image is now a column vector)</span>
    <span class="n">new_data_processed</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span><span class="n">new_data_processed</span><span class="p">)</span>
    <span class="n">new_data_processed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span><span class="n">new_data_processed</span><span class="p">)</span>

    <span class="c1"># Spams requires all matrices to be fortran.</span>
    <span class="k">if</span> <span class="s2">&quot;spams.trainDL&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="n">new_data_processed</span> <span class="o">=</span> <span class="n">new_data_processed</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">new_data_processed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span><span class="n">new_data_processed</span><span class="p">)</span>

    <span class="c1"># If there is an initial dictionary provided, go ahead and process it.</span>
    <span class="n">initial_dictionary_processed</span> <span class="o">=</span> <span class="n">initial_dictionary</span>
    <span class="k">if</span> <span class="n">initial_dictionary_processed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Go ahead and make the dictionary the same type as the input data.</span>
        <span class="c1"># TODO: Add a warning if it needs to be down cast</span>
        <span class="n">initial_dictionary_processed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">initial_dictionary_processed</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float_dtype</span>
        <span class="p">)</span>

        <span class="c1"># Reshape dictionary into a matrix (each image is now a column vector)</span>
        <span class="n">initial_dictionary_processed</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span>
            <span class="n">initial_dictionary_processed</span>
        <span class="p">)</span>
        <span class="n">initial_dictionary_processed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asmatrix</span><span class="p">(</span>
            <span class="n">initial_dictionary_processed</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;spams.trainDL&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
            <span class="n">initial_dictionary_processed</span> <span class="o">=</span> <span class="n">initial_dictionary_processed</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

            <span class="c1"># Spams requires all matrices to be fortran.</span>
            <span class="n">initial_dictionary_processed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asfortranarray</span><span class="p">(</span>
                <span class="n">initial_dictionary_processed</span>
            <span class="p">)</span>

    <span class="c1"># Simply trains the dictionary. Does not return sparse code.</span>
    <span class="c1"># Need to look into generating the sparse code given the dictionary,</span>
    <span class="c1"># spams.nmf? (may be too slow))</span>
    <span class="k">if</span> <span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="c1"># sklearn needs to be boxed so it doesn&#39;t cause us issues.</span>
        <span class="kn">import</span> <span class="nn">sklearn</span>
        <span class="kn">import</span> <span class="nn">sklearn.decomposition</span>

        <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">][</span><span class="s2">&quot;return_code&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_code&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">][</span><span class="s2">&quot;return_code&quot;</span><span class="p">],</span>\
            <span class="s2">&quot;Returning the sparse code is not supported by this function&#39;s API.&quot;</span>

        <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">][</span><span class="s2">&quot;return_inner_stats&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return_inner_stats&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">][</span><span class="s2">&quot;return_inner_stats&quot;</span><span class="p">],</span>\
            <span class="s2">&quot;Returning the internal stats is not supported by this function&#39;s API.&quot;</span>

        <span class="n">new_dictionary</span> <span class="o">=</span> <span class="n">sklearn</span><span class="o">.</span><span class="n">decomposition</span><span class="o">.</span><span class="n">dict_learning_online</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">new_data_processed</span><span class="p">,</span> <span class="n">dict_init</span><span class="o">=</span><span class="n">initial_dictionary_processed</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;sklearn.decomposition.dict_learning_online&quot;</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;spams.trainDL&quot;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="n">new_dictionary</span> <span class="o">=</span> <span class="n">nanshe</span><span class="o">.</span><span class="n">box</span><span class="o">.</span><span class="n">spams_sandbox</span><span class="o">.</span><span class="n">call_multiprocessing_array_spams_trainDL</span><span class="p">(</span>
            <span class="n">X</span><span class="o">=</span><span class="n">new_data_processed</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="n">initial_dictionary_processed</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;spams.trainDL&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Fix dictionary so that the first index will be the particular image.</span>
        <span class="n">new_dictionary</span> <span class="o">=</span> <span class="n">new_dictionary</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span>\
            <span class="s2">&quot;Must select a supported matrix factorization algorithm.&quot;</span>

    <span class="c1"># Fix the rest will be the shape of an image (same as input shape).</span>
    <span class="n">new_dictionary</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">new_dictionary</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
    <span class="n">new_dictionary</span> <span class="o">=</span> <span class="n">new_dictionary</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">new_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_dictionary</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="region_properties_scikit_image"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.region_properties_scikit_image">[docs]</a><span class="k">def</span> <span class="nf">region_properties_scikit_image</span><span class="p">(</span><span class="n">new_label_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Grabs region properties from a label image.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_label_image(numpy.ndarray):      label image used for</span>
<span class="sd">                                                 generating properties.</span>

<span class="sd">            args(list):                          additional position arguments</span>
<span class="sd">                                                 to pass</span>
<span class="sd">                                                 skimage.measure.regionprops.</span>

<span class="sd">            **parameters(dict):                  additional keyword arguments</span>
<span class="sd">                                                 to pass</span>
<span class="sd">                                                 skimage.measure.regionprops.</span>

<span class="sd">        Note:</span>
<span class="sd">            Uses all the same options in skimage.measure.regionprops. If a</span>
<span class="sd">            property is not specified, then it won&#39;t be returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                       a structured array of all the</span>
<span class="sd">                                                 properties found for each</span>
<span class="sd">                                                 label.</span>

<span class="sd">        Examples:</span>

<span class="sd">            &gt;&gt;&gt; region_properties_scikit_image(numpy.zeros((2,2), dtype=int))</span>
<span class="sd">            array([], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_scikit_image(numpy.ones((2,2), dtype=int))</span>
<span class="sd">            array([(1, 4.0, [0.5, 0.5])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_scikit_image(numpy.ones((3,3), dtype=int))</span>
<span class="sd">            array([(1, 9.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_scikit_image(numpy.eye(3, dtype=int))</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_scikit_image(</span>
<span class="sd">            ...     numpy.eye(3, dtype=int), [&quot;area&quot;, &quot;centroid&quot;]</span>
<span class="sd">            ... )</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_scikit_image(</span>
<span class="sd">            ...     numpy.eye(3, dtype=int), properties=[&quot;area&quot;, &quot;centroid&quot;]</span>
<span class="sd">            ... )</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">region_properties_type_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;convex_area&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="s2">&quot;convex_image&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span>
        <span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="s2">&quot;eccentricity&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;equivalent_diameter&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;euler_number&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="s2">&quot;filled_area&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="s2">&quot;filled_image&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span>
        <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span>
        <span class="s2">&quot;inertia_tensor&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;inertia_tensor_eigvals&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;intensity_image&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="s2">&quot;local_centroid&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;major_axis_length&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;max_intensity&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;mean_intensity&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;min_intensity&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;minor_axis_length&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;moments&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;moments_central&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;moments_hu&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;moments_normalized&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;orientation&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;solidity&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;weighted_centroid&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;weighted_local_centroid&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments_central&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments_hu&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments_normalized&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>
    <span class="p">}</span>

    <span class="n">region_properties_shape_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,),</span>
        <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">new_label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),</span>
        <span class="s2">&quot;convex_area&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;convex_image&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="s2">&quot;eccentricity&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;equivalent_diameter&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;euler_number&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;filled_area&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;filled_image&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;inertia_tensor&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="s2">&quot;inertia_tensor_eigvals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
        <span class="s2">&quot;intensity_image&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;local_centroid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
        <span class="s2">&quot;major_axis_length&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;max_intensity&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;mean_intensity&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;min_intensity&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;minor_axis_length&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;moments&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s2">&quot;moments_central&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s2">&quot;moments_hu&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">7</span><span class="p">,),</span>
        <span class="s2">&quot;moments_normalized&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s2">&quot;orientation&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;solidity&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;weighted_centroid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
        <span class="s2">&quot;weighted_local_centroid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,),</span>
        <span class="s2">&quot;weighted_moments&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s2">&quot;weighted_moments_central&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
        <span class="s2">&quot;weighted_moments_hu&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">7</span><span class="p">,),</span>
        <span class="s2">&quot;weighted_moments_normalized&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="n">region_properties_ndim_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;bbox&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;convex_area&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;convex_image&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;eccentricity&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;equivalent_diameter&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;euler_number&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;filled_area&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;filled_image&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;image&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;inertia_tensor&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;inertia_tensor_eigvals&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;intensity_image&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;local_centroid&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;major_axis_length&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;max_intensity&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;mean_intensity&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;min_intensity&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;minor_axis_length&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;moments&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;moments_central&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;moments_hu&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;moments_normalized&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;orientation&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;perimeter&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;solidity&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;weighted_centroid&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;weighted_local_centroid&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments_central&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments_hu&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;weighted_moments_normalized&quot;</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="n">array_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">region_properties_ndim_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">_v</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">]</span>
    <span class="n">fixed_shape_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">region_properties_shape_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_v</span>
    <span class="p">]</span>
    <span class="n">varied_shape_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">region_properties_shape_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">_v</span>
    <span class="p">]</span>

    <span class="n">new_label_image_props</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_label_image_props_with_arrays</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_label_image_props_with_arrays_values</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">properties</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;properties&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">properties</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">properties</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">region_properties_type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">intensity_image</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">intensity_image</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;intensity_image&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">intensity_image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;intensity_image&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;intensity_image&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Remove duplicates and make sure label is at the front.</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>
    <span class="n">allowed_properties</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">region_properties_type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">disallowed_properties</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">allowed_properties</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">):</span>
        <span class="n">disallowed_properties</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;Recieved </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">))</span> <span class="o">+</span>
            <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> properties that are not allowed, which are </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span>
            <span class="nb">repr</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">properties</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_label_image</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="c1"># This gives a list of dictionaries. However, this is not very usable.</span>
        <span class="c1"># So, we will convert this to a structured NumPy array.</span>
        <span class="c1"># In future versions, the properties argument will be removed.</span>
        <span class="c1"># It does not need to be passed to retain functionality of this</span>
        <span class="c1"># function.</span>
        <span class="n">new_label_image_props</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span>
            <span class="n">label_image</span><span class="o">=</span><span class="n">new_label_image</span><span class="p">,</span>
            <span class="n">intensity_image</span><span class="o">=</span><span class="n">intensity_image</span><span class="p">,</span>
            <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="n">new_label_image_props_with_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props</span><span class="p">)):</span>
            <span class="n">new_label_image_props_with_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>

            <span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">array_properties</span><span class="p">:</span>
                    <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">new_label_image_props</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">each_key</span><span class="p">],</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">region_properties_type_dict</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">region_properties_type_dict</span><span class="p">[</span><span class="n">each_key</span><span class="p">](</span>
                        <span class="n">new_label_image_props</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">each_key</span><span class="p">]</span>
                    <span class="p">)</span>

        <span class="c1"># Holds the values from props.</span>
        <span class="n">new_label_image_props_with_arrays_values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Holds the types from props.</span>
        <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">):</span>
            <span class="c1"># Get types for all properties as a dictionary</span>
            <span class="k">for</span> <span class="n">each_name</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="n">each_sample_value</span> <span class="o">=</span> <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span>
                    <span class="mi">0</span><span class="p">][</span><span class="n">each_name</span><span class="p">]</span>
                <span class="n">each_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">each_sample_value</span><span class="p">)</span>
                <span class="n">each_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">each_sample_value</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="p">(</span><span class="n">each_name</span> <span class="ow">in</span> <span class="n">fixed_shape_properties</span><span class="p">):</span>
                    <span class="n">each_type</span> <span class="o">=</span> <span class="n">each_sample_value</span><span class="o">.</span><span class="n">dtype</span>
                    <span class="n">each_shape</span> <span class="o">=</span> <span class="n">each_sample_value</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">each_type</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">each_type</span><span class="p">)</span>

                <span class="n">new_label_image_props_with_arrays_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">each_name</span><span class="p">,</span> <span class="n">each_type</span><span class="p">,</span> <span class="n">each_shape</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Store the values to place in NumPy structured array in order.</span>
            <span class="n">new_label_image_props_with_arrays_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">)):</span>
                <span class="c1"># Add all values in order of keys from the dictionary.</span>
                <span class="n">new_label_image_props_with_arrays_values</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">each_new_label_image_props_with_arrays_dtype</span> <span class="ow">in</span> <span class="n">new_label_image_props_with_arrays_dtype</span><span class="p">:</span>
                    <span class="n">each_name</span><span class="p">,</span> <span class="n">each_type</span><span class="p">,</span> <span class="n">each_shape</span> <span class="o">=</span> <span class="n">each_new_label_image_props_with_arrays_dtype</span>

                    <span class="k">if</span> <span class="n">each_shape</span><span class="p">:</span>
                        <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">each_name</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">each_name</span><span class="p">])</span>

                <span class="c1"># NumPy will expect a tuple for each set of values.</span>
                <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">new_label_image</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">)):</span>
        <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
            <span class="n">each_type</span> <span class="o">=</span> <span class="n">region_properties_type_dict</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span>
            <span class="n">each_shape</span> <span class="o">=</span> <span class="n">region_properties_shape_dict</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">varied_shape_properties</span><span class="p">:</span>
                <span class="n">each_type</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">object_</span>
                <span class="n">each_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

            <span class="n">new_label_image_props_with_arrays_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">each_key</span><span class="p">,</span> <span class="n">each_type</span><span class="p">,</span> <span class="n">each_shape</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
        <span class="n">new_label_image_props_with_arrays_dtype</span>
    <span class="p">)</span>

    <span class="c1"># Replace the properties with the structured array.</span>
    <span class="n">new_label_image_props_with_arrays</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">new_label_image_props_with_arrays_values</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">new_label_image_props_with_arrays_dtype</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="region_properties_vigra"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.region_properties_vigra">[docs]</a><span class="k">def</span> <span class="nf">region_properties_vigra</span><span class="p">(</span><span class="n">new_label_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Grabs region properties from a label image.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_label_image(numpy.ndarray):      label image used for</span>
<span class="sd">                                                 generating properties.</span>

<span class="sd">            args(list):                          additional position arguments</span>
<span class="sd">                                                 to pass</span>
<span class="sd">                                                 skimage.measure.regionprops.</span>

<span class="sd">            **parameters(dict):                  additional keyword arguments</span>
<span class="sd">                                                 to pass</span>
<span class="sd">                                                 skimage.measure.regionprops.</span>

<span class="sd">        Note:</span>
<span class="sd">            Uses all the same options in skimage.measure.regionprops. If a</span>
<span class="sd">            property is not specified, then it won&#39;t be returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                       a structured array of all the</span>
<span class="sd">                                                 properties found for each</span>
<span class="sd">                                                 label.</span>

<span class="sd">        Examples:</span>

<span class="sd">            &gt;&gt;&gt; region_properties_vigra(numpy.zeros((2,2), dtype=int))</span>
<span class="sd">            array([], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_vigra(numpy.ones((2,2), dtype=int))</span>
<span class="sd">            array([(1, 4.0, [0.5, 0.5])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_vigra(numpy.ones((3,3), dtype=int))</span>
<span class="sd">            array([(1, 9.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_vigra(numpy.eye(3, dtype=int))</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_vigra(</span>
<span class="sd">            ...     numpy.eye(3, dtype=int), [&quot;area&quot;, &quot;centroid&quot;]</span>
<span class="sd">            ... )</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties_vigra(</span>
<span class="sd">            ...     numpy.eye(3, dtype=int), properties=[&quot;area&quot;, &quot;centroid&quot;]</span>
<span class="sd">            ... )</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">region_properties_type_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;eccentricity&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="s2">&quot;major_axis_length&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
        <span class="s2">&quot;minor_axis_length&quot;</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">region_properties_shape_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">new_label_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">,),</span>
        <span class="s2">&quot;eccentricity&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;major_axis_length&quot;</span><span class="p">:</span> <span class="p">(),</span>
        <span class="s2">&quot;minor_axis_length&quot;</span><span class="p">:</span> <span class="p">(),</span>
    <span class="p">}</span>

    <span class="n">region_properties_ndim_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;area&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;centroid&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;eccentricity&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;major_axis_length&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="s2">&quot;minor_axis_length&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c1"># region_properties_type_dict = {</span>
    <span class="c1">#     &quot;area&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;bbox&quot;: numpy.int64,</span>
    <span class="c1">#     &quot;centroid&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;convex_area&quot;: numpy.int64,</span>
    <span class="c1">#     &quot;convex_image&quot;: numpy.bool_,</span>
    <span class="c1">#     &quot;coords&quot;: numpy.int64,</span>
    <span class="c1">#     &quot;eccentricity&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;equivalent_diameter&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;euler_number&quot;: numpy.int64,</span>
    <span class="c1">#     &quot;filled_area&quot;: numpy.int64,</span>
    <span class="c1">#     &quot;filled_image&quot;: numpy.bool_,</span>
    <span class="c1">#     &quot;image&quot;: numpy.bool_,</span>
    <span class="c1">#     &quot;inertia_tensor&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;inertia_tensor_eigvals&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;intensity_image&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;label&quot;: numpy.int64,</span>
    <span class="c1">#     &quot;local_centroid&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;major_axis_length&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;max_intensity&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;mean_intensity&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;min_intensity&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;minor_axis_length&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;moments&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;moments_central&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;moments_hu&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;moments_normalized&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;orientation&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;perimeter&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;solidity&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;weighted_centroid&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;weighted_local_centroid&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;weighted_moments&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;weighted_moments_central&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;weighted_moments_hu&quot;: numpy.float64,</span>
    <span class="c1">#     &quot;weighted_moments_normalized&quot;: numpy.float64</span>
    <span class="c1"># }</span>
    <span class="c1">#</span>
    <span class="c1"># region_properties_shape_dict = {</span>
    <span class="c1">#     &quot;area&quot;: (),</span>
    <span class="c1">#     &quot;bbox&quot;: (4,),</span>
    <span class="c1">#     &quot;centroid&quot;: (new_label_image.ndim,),</span>
    <span class="c1">#     &quot;convex_area&quot;: (),</span>
    <span class="c1">#     &quot;convex_image&quot;: (-1, -1),</span>
    <span class="c1">#     &quot;coords&quot;: (-1, 2),</span>
    <span class="c1">#     &quot;eccentricity&quot;: (),</span>
    <span class="c1">#     &quot;equivalent_diameter&quot;: (),</span>
    <span class="c1">#     &quot;euler_number&quot;: (),</span>
    <span class="c1">#     &quot;filled_area&quot;: (),</span>
    <span class="c1">#     &quot;filled_image&quot;: (-1, -1),</span>
    <span class="c1">#     &quot;image&quot;: (-1, -1),</span>
    <span class="c1">#     &quot;inertia_tensor&quot;: (2, 2),</span>
    <span class="c1">#     &quot;inertia_tensor_eigvals&quot;: (2,),</span>
    <span class="c1">#     &quot;intensity_image&quot;: (-1, -1),</span>
    <span class="c1">#     &quot;label&quot;: (),</span>
    <span class="c1">#     &quot;local_centroid&quot;: (2,),</span>
    <span class="c1">#     &quot;major_axis_length&quot;: (),</span>
    <span class="c1">#     &quot;max_intensity&quot;: (),</span>
    <span class="c1">#     &quot;mean_intensity&quot;: (),</span>
    <span class="c1">#     &quot;min_intensity&quot;: (),</span>
    <span class="c1">#     &quot;minor_axis_length&quot;: (),</span>
    <span class="c1">#     &quot;moments&quot;: (4, 4),</span>
    <span class="c1">#     &quot;moments_central&quot;: (4, 4),</span>
    <span class="c1">#     &quot;moments_hu&quot;: (7,),</span>
    <span class="c1">#     &quot;moments_normalized&quot;: (4, 4),</span>
    <span class="c1">#     &quot;orientation&quot;: (),</span>
    <span class="c1">#     &quot;perimeter&quot;: (),</span>
    <span class="c1">#     &quot;solidity&quot;: (),</span>
    <span class="c1">#     &quot;weighted_centroid&quot;: (2,),</span>
    <span class="c1">#     &quot;weighted_local_centroid&quot;: (2,),</span>
    <span class="c1">#     &quot;weighted_moments&quot;: (4, 4),</span>
    <span class="c1">#     &quot;weighted_moments_central&quot;: (4, 4),</span>
    <span class="c1">#     &quot;weighted_moments_hu&quot;: (7,),</span>
    <span class="c1">#     &quot;weighted_moments_normalized&quot;: (4, 4)</span>
    <span class="c1"># }</span>
    <span class="c1">#</span>
    <span class="c1"># region_properties_ndim_dict = {</span>
    <span class="c1">#     &quot;area&quot;: 0,</span>
    <span class="c1">#     &quot;bbox&quot;: 1,</span>
    <span class="c1">#     &quot;centroid&quot;: 1,</span>
    <span class="c1">#     &quot;convex_area&quot;: 0,</span>
    <span class="c1">#     &quot;convex_image&quot;: 2,</span>
    <span class="c1">#     &quot;coords&quot;: 2,</span>
    <span class="c1">#     &quot;eccentricity&quot;: 0,</span>
    <span class="c1">#     &quot;equivalent_diameter&quot;: 0,</span>
    <span class="c1">#     &quot;euler_number&quot;: 0,</span>
    <span class="c1">#     &quot;filled_area&quot;: 0,</span>
    <span class="c1">#     &quot;filled_image&quot;: 2,</span>
    <span class="c1">#     &quot;image&quot;: 2,</span>
    <span class="c1">#     &quot;inertia_tensor&quot;: 2,</span>
    <span class="c1">#     &quot;inertia_tensor_eigvals&quot;: 1,</span>
    <span class="c1">#     &quot;intensity_image&quot;: 2,</span>
    <span class="c1">#     &quot;label&quot;: 0,</span>
    <span class="c1">#     &quot;local_centroid&quot;: 1,</span>
    <span class="c1">#     &quot;major_axis_length&quot;: 0,</span>
    <span class="c1">#     &quot;max_intensity&quot;: 0,</span>
    <span class="c1">#     &quot;mean_intensity&quot;: 0,</span>
    <span class="c1">#     &quot;min_intensity&quot;: 0,</span>
    <span class="c1">#     &quot;minor_axis_length&quot;: 0,</span>
    <span class="c1">#     &quot;moments&quot;: 2,</span>
    <span class="c1">#     &quot;moments_central&quot;: 2,</span>
    <span class="c1">#     &quot;moments_hu&quot;: 1,</span>
    <span class="c1">#     &quot;moments_normalized&quot;: 2,</span>
    <span class="c1">#     &quot;orientation&quot;: 0,</span>
    <span class="c1">#     &quot;perimeter&quot;: 0,</span>
    <span class="c1">#     &quot;solidity&quot;: 0,</span>
    <span class="c1">#     &quot;weighted_centroid&quot;: 1,</span>
    <span class="c1">#     &quot;weighted_local_centroid&quot;: 1,</span>
    <span class="c1">#     &quot;weighted_moments&quot;: 2,</span>
    <span class="c1">#     &quot;weighted_moments_central&quot;: 2,</span>
    <span class="c1">#     &quot;weighted_moments_hu&quot;: 1,</span>
    <span class="c1">#     &quot;weighted_moments_normalized&quot;: 2</span>
    <span class="c1"># }</span>

    <span class="n">array_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">region_properties_ndim_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">_v</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">]</span>
    <span class="n">fixed_shape_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">region_properties_shape_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_v</span>
    <span class="p">]</span>
    <span class="n">varied_shape_properties</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">_k</span> <span class="k">for</span> <span class="n">_k</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">region_properties_shape_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">_v</span>
    <span class="p">]</span>

    <span class="n">new_label_image_props</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_label_image_props_with_arrays</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_label_image_props_with_arrays_values</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">properties</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;properties&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="s2">&quot;centroid&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">properties</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">properties</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)):</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">region_properties_type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">intensity_image</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">intensity_image</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="s2">&quot;intensity_image&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="n">intensity_image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;intensity_image&quot;</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;intensity_image&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Remove duplicates and make sure label is at the front.</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>
    <span class="n">allowed_properties</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">region_properties_type_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">disallowed_properties</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">allowed_properties</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">):</span>
        <span class="n">disallowed_properties</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s2">&quot;Recieved </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">))</span> <span class="o">+</span>
            <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> properties that are not allowed, which are </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span>
            <span class="nb">repr</span><span class="p">(</span><span class="n">disallowed_properties</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">properties</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">)</span>
    <span class="n">properties</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">properties</span><span class="p">)</span>


    <span class="k">class</span> <span class="nc">VigraProperties</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_image</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span> <span class="o">=</span> <span class="n">label_image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span> <span class="o">=</span> <span class="n">intensity_image</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extractRegionFeatures</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span>
                <span class="n">features</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Count&quot;</span><span class="p">,</span> <span class="s2">&quot;RegionCenter&quot;</span><span class="p">,</span> <span class="s2">&quot;RegionRadii&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;Count&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="s2">&quot;area&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;Count&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="s2">&quot;centroid&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;RegionCenter&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="s2">&quot;eccentricity&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;RegionRadii&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;RegionRadii&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                    <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="s2">&quot;major_axis_length&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;RegionRadii&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">item</span> <span class="o">==</span> <span class="s2">&quot;minor_axis_length&quot;</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;RegionRadii&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Should have already checked and removed these.</span>
                <span class="k">assert</span> <span class="bp">False</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_label_image</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="c1"># This gives a list of dictionaries. However, this is not very usable.</span>
        <span class="c1"># So, we will convert this to a structured NumPy array.</span>
        <span class="c1"># In future versions, the properties argument will be removed.</span>
        <span class="c1"># It does not need to be passed to retain functionality of this</span>
        <span class="c1"># function.</span>
        <span class="n">new_label_image_props</span> <span class="o">=</span> <span class="n">VigraProperties</span><span class="p">(</span>
            <span class="n">new_label_image</span><span class="p">,</span> <span class="n">intensity_image</span><span class="p">)</span>

        <span class="n">new_label_image_props_with_arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props</span><span class="p">)):</span>
            <span class="n">new_label_image_props_with_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">({})</span>

            <span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">array_properties</span><span class="p">:</span>
                    <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">new_label_image_props</span><span class="p">[</span><span class="n">each_key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span>
                        <span class="n">each_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_label_image_props</span><span class="p">[</span><span class="n">each_key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Holds the values from props.</span>
        <span class="n">new_label_image_props_with_arrays_values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Holds the types from props.</span>
        <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">):</span>
            <span class="c1"># Get types for all properties as a dictionary</span>
            <span class="k">for</span> <span class="n">each_name</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="n">each_sample_value</span> <span class="o">=</span> <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">each_name</span><span class="p">]</span>
                <span class="n">each_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">each_sample_value</span><span class="p">)</span>
                <span class="n">each_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">each_sample_value</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="p">(</span><span class="n">each_name</span> <span class="ow">in</span> <span class="n">fixed_shape_properties</span><span class="p">):</span>
                    <span class="n">each_type</span> <span class="o">=</span> <span class="n">each_sample_value</span><span class="o">.</span><span class="n">dtype</span>
                    <span class="n">each_shape</span> <span class="o">=</span> <span class="n">each_sample_value</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">each_type</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">each_type</span><span class="p">)</span>

                <span class="n">new_label_image_props_with_arrays_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">each_name</span><span class="p">,</span> <span class="n">each_type</span><span class="p">,</span> <span class="n">each_shape</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Store the values to place in NumPy structured array in order.</span>
            <span class="n">new_label_image_props_with_arrays_values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">)):</span>
                <span class="c1"># Add all values in order of keys from the dictionary.</span>
                <span class="n">new_label_image_props_with_arrays_values</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">each_new_label_image_props_with_arrays_dtype</span> <span class="ow">in</span> <span class="n">new_label_image_props_with_arrays_dtype</span><span class="p">:</span>
                    <span class="n">each_name</span><span class="p">,</span> <span class="n">each_type</span><span class="p">,</span> <span class="n">each_shape</span> <span class="o">=</span> <span class="n">each_new_label_image_props_with_arrays_dtype</span>

                    <span class="k">if</span> <span class="n">each_shape</span><span class="p">:</span>
                        <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">each_name</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">new_label_image_props_with_arrays</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">each_name</span><span class="p">]</span>
                        <span class="p">)</span>

                <span class="c1"># NumPy will expect a tuple for each set of values.</span>
                <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">new_label_image_props_with_arrays_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">new_label_image</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">)):</span>
        <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
            <span class="n">each_type</span> <span class="o">=</span> <span class="n">region_properties_type_dict</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span>
            <span class="n">each_shape</span> <span class="o">=</span> <span class="n">region_properties_shape_dict</span><span class="p">[</span><span class="n">each_key</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">each_key</span> <span class="ow">in</span> <span class="n">varied_shape_properties</span><span class="p">:</span>
                <span class="n">each_type</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">object_</span>
                <span class="n">each_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

            <span class="n">new_label_image_props_with_arrays_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">each_key</span><span class="p">,</span> <span class="n">each_type</span><span class="p">,</span> <span class="n">each_shape</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="n">new_label_image_props_with_arrays_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span>
        <span class="n">new_label_image_props_with_arrays_dtype</span>
    <span class="p">)</span>

    <span class="c1"># Replace the properties with the structured array.</span>
    <span class="n">new_label_image_props_with_arrays</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">new_label_image_props_with_arrays_values</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">new_label_image_props_with_arrays_dtype</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_label_image_props_with_arrays</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="region_properties"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.region_properties">[docs]</a><span class="k">def</span> <span class="nf">region_properties</span><span class="p">(</span><span class="n">new_label_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Grabs region properties from a label image.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_label_image(numpy.ndarray):      label image used for</span>
<span class="sd">                                                 generating properties.</span>

<span class="sd">            args(list):                          additional position arguments</span>
<span class="sd">                                                 to pass</span>
<span class="sd">                                                 skimage.measure.regionprops.</span>

<span class="sd">            **parameters(dict):                  additional keyword arguments</span>
<span class="sd">                                                 to pass</span>
<span class="sd">                                                 skimage.measure.regionprops.</span>

<span class="sd">        Note:</span>
<span class="sd">            Uses all the same options in skimage.measure.regionprops. If a</span>
<span class="sd">            property is not specified, then it won&#39;t be returned.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                       a structured array of all the</span>
<span class="sd">                                                 properties found for each</span>
<span class="sd">                                                 label.</span>


<span class="sd">        Examples:</span>

<span class="sd">            &gt;&gt;&gt; region_properties(</span>
<span class="sd">            ...     numpy.zeros((2,2), dtype=int)</span>
<span class="sd">            ... ) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            array([], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties(</span>
<span class="sd">            ...     numpy.ones((2,2), dtype=int)</span>
<span class="sd">            ... ) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            array([(1, 4.0, [0.5, 0.5])],</span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties(</span>
<span class="sd">            ...     numpy.ones((3,3), dtype=int)</span>
<span class="sd">            ... ) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            array([(1, 9.0, [1.0, 1.0])],</span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties(numpy.eye(3, dtype=int))</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties(</span>
<span class="sd">            ...     numpy.eye(3, dtype=int), [&quot;area&quot;, &quot;centroid&quot;]</span>
<span class="sd">            ... )</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>

<span class="sd">            &gt;&gt;&gt; region_properties(</span>
<span class="sd">            ...     numpy.eye(3, dtype=int), properties=[&quot;area&quot;, &quot;centroid&quot;]</span>
<span class="sd">            ... )</span>
<span class="sd">            array([(1, 3.0, [1.0, 1.0])], </span>
<span class="sd">                  dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">region_properties_vigra</span><span class="p">(</span><span class="n">new_label_image</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="get_neuron_dtype"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.get_neuron_dtype">[docs]</a><span class="k">def</span> <span class="nf">get_neuron_dtype</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the type based on properties of an image.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_image(numpy.ndarray):     a single sample image (only spatial</span>
<span class="sd">                                          dimension).</span>

<span class="sd">        Returns:</span>
<span class="sd">            list:                         a list that can be converted to a</span>
<span class="sd">                                          numpy.dtype using numpy.ndtype&#39;s</span>
<span class="sd">                                          constructor.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; get_neuron_dtype(</span>
<span class="sd">            ...     (3,), numpy.float64</span>
<span class="sd">            ... ) #doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS</span>
<span class="sd">            [(&#39;mask&#39;, &lt;... &#39;numpy.bool_&#39;&gt;, (3,)),</span>
<span class="sd">             (&#39;contour&#39;, &lt;... &#39;numpy.bool_&#39;&gt;, (3,)),</span>
<span class="sd">             (&#39;image&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (3,)),</span>
<span class="sd">             (&#39;area&#39;, &lt;... &#39;numpy.float64&#39;&gt;),</span>
<span class="sd">             (&#39;max_F&#39;, &lt;... &#39;numpy.float64&#39;&gt;),</span>
<span class="sd">             (&#39;gaussian_mean&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (1,)),</span>
<span class="sd">             (&#39;gaussian_cov&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (1, 1)),</span>
<span class="sd">             (&#39;centroid&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (1,))]</span>


<span class="sd">            &gt;&gt;&gt; get_neuron_dtype(</span>
<span class="sd">            ...     (2, 3), numpy.float64</span>
<span class="sd">            ... ) #doctest: +NORMALIZE_WHITESPACE, +ELLIPSIS</span>
<span class="sd">            [(&#39;mask&#39;, &lt;... &#39;numpy.bool_&#39;&gt;, (2, 3)),</span>
<span class="sd">             (&#39;contour&#39;, &lt;... &#39;numpy.bool_&#39;&gt;, (2, 3)),</span>
<span class="sd">             (&#39;image&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (2, 3)),</span>
<span class="sd">             (&#39;area&#39;, &lt;... &#39;numpy.float64&#39;&gt;),</span>
<span class="sd">             (&#39;max_F&#39;, &lt;... &#39;numpy.float64&#39;&gt;),</span>
<span class="sd">             (&#39;gaussian_mean&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (2,)),</span>
<span class="sd">             (&#39;gaussian_cov&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (2, 2)),</span>
<span class="sd">             (&#39;centroid&#39;, &lt;... &#39;numpy.float64&#39;&gt;, (2,))]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">dtype_type</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span>

    <span class="n">neurons_dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;mask&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool8</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span>
                     <span class="p">(</span><span class="s2">&quot;contour&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bool8</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span>
                     <span class="p">(</span><span class="s2">&quot;image&quot;</span><span class="p">,</span> <span class="n">dtype_type</span><span class="p">,</span> <span class="n">shape</span><span class="p">),</span>
                     <span class="p">(</span><span class="s2">&quot;area&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                     <span class="p">(</span><span class="s2">&quot;max_F&quot;</span><span class="p">,</span> <span class="n">dtype_type</span><span class="p">),</span>
                     <span class="p">(</span><span class="s2">&quot;gaussian_mean&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="n">ndim</span><span class="p">,)),</span>
                     <span class="p">(</span><span class="s2">&quot;gaussian_cov&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,)),</span>
                     <span class="p">(</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="p">(</span><span class="n">ndim</span><span class="p">,))]</span>

    <span class="k">return</span><span class="p">(</span><span class="n">neurons_dtype</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="get_empty_neuron"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.get_empty_neuron">[docs]</a><span class="k">def</span> <span class="nf">get_empty_neuron</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a numpy structured array using the type from get_neuron_dtype that</span>
<span class="sd">        has no contents.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_image(numpy.ndarray):     an empty numpy structured array with</span>
<span class="sd">                                          all types needed for a neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                a numpy structured array with no</span>
<span class="sd">                                          contents and type from</span>
<span class="sd">                                          get_neuron_dtype.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; get_empty_neuron(</span>
<span class="sd">            ...     (3,), numpy.float64</span>
<span class="sd">            ... ) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            array([], dtype=[(&#39;mask&#39;, &#39;?&#39;, (3,)),</span>
<span class="sd">                             (&#39;contour&#39;, &#39;?&#39;, (3,)),</span>
<span class="sd">                             (&#39;image&#39;, &#39;&lt;f8&#39;, (3,)),</span>
<span class="sd">                             (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                             (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                             (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (1,)),</span>
<span class="sd">                             (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (1, 1)),</span>
<span class="sd">                             (&#39;centroid&#39;, &#39;&lt;f8&#39;, (1,))])</span>

<span class="sd">            &gt;&gt;&gt; get_empty_neuron(</span>
<span class="sd">            ...     (2, 3), numpy.float64</span>
<span class="sd">            ... ) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            array([], dtype=[(&#39;mask&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="sd">                             (&#39;contour&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="sd">                             (&#39;image&#39;, &#39;&lt;f8&#39;, (2, 3)),</span>
<span class="sd">                             (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                             (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                             (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (2,)),</span>
<span class="sd">                             (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (2, 2)),</span>
<span class="sd">                             (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">neurons_dtype</span> <span class="o">=</span> <span class="n">get_neuron_dtype</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">neurons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">neurons_dtype</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="get_one_neuron"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.get_one_neuron">[docs]</a><span class="k">def</span> <span class="nf">get_one_neuron</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a numpy structured array using the type from get_neuron_dtype that</span>
<span class="sd">        has one neuron with all zeros.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_image(numpy.ndarray):     an empty numpy structured array with</span>
<span class="sd">                                          all types needed for a neuron.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                a numpy structured array with one</span>
<span class="sd">                                          neuron using type from</span>
<span class="sd">                                          get_neuron_dtype.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; get_one_neuron(</span>
<span class="sd">            ...     (3,), numpy.float64</span>
<span class="sd">            ... ) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            array([ ([False, False, False],</span>
<span class="sd">                     [False, False, False],</span>
<span class="sd">                     [0.0, 0.0, 0.0],</span>
<span class="sd">                     0.0,</span>
<span class="sd">                     0.0,</span>
<span class="sd">                     [0.0],</span>
<span class="sd">                     [[0.0]],</span>
<span class="sd">                     [0.0])],</span>
<span class="sd">                   dtype=[(&#39;mask&#39;, &#39;?&#39;, (3,)),</span>
<span class="sd">                          (&#39;contour&#39;, &#39;?&#39;, (3,)),</span>
<span class="sd">                          (&#39;image&#39;, &#39;&lt;f8&#39;, (3,)),</span>
<span class="sd">                          (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                          (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                          (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (1,)),</span>
<span class="sd">                          (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (1, 1)),</span>
<span class="sd">                          (&#39;centroid&#39;, &#39;&lt;f8&#39;, (1,))])</span>

<span class="sd">            &gt;&gt;&gt; get_one_neuron(</span>
<span class="sd">            ...     (2, 3), numpy.float64</span>
<span class="sd">            ... ) #doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">            array([ ([[False, False, False],</span>
<span class="sd">                      [False, False, False]],</span>
<span class="sd">                     [[False, False, False],</span>
<span class="sd">                      [False, False, False]],</span>
<span class="sd">                     [[0.0, 0.0, 0.0],</span>
<span class="sd">                      [0.0, 0.0, 0.0]],</span>
<span class="sd">                     0.0,</span>
<span class="sd">                     0.0,</span>
<span class="sd">                     [0.0, 0.0],</span>
<span class="sd">                    [[0.0, 0.0],</span>
<span class="sd">                     [0.0, 0.0]],</span>
<span class="sd">                    [0.0, 0.0])],</span>
<span class="sd">                   dtype=[(&#39;mask&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="sd">                          (&#39;contour&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="sd">                          (&#39;image&#39;, &#39;&lt;f8&#39;, (2, 3)),</span>
<span class="sd">                          (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                          (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="sd">                          (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (2,)),</span>
<span class="sd">                          (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (2, 2)),</span>
<span class="sd">                          (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">neurons_dtype</span> <span class="o">=</span> <span class="n">get_neuron_dtype</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">neurons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">neurons_dtype</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="generate_local_maxima_vigra"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.generate_local_maxima_vigra">[docs]</a><span class="k">def</span> <span class="nf">generate_local_maxima_vigra</span><span class="p">(</span><span class="n">new_intensity_image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a mask the same size as the intensity image with local maxima</span>
<span class="sd">        as True and background False. Uses vigra&#39;s</span>
<span class="sd">        vigra.analysis.extendedLocalMaxima for 2D and</span>
<span class="sd">        vigra&#39;s vigra.analysis.extendedLocalMaxima3D for 3D.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_intensity_image(numpy.ndarray):     The image to find local</span>
<span class="sd">                                                    maxima for (ideally, all</span>
<span class="sd">                                                    axes are spatial; however,</span>
<span class="sd">                                                    it will treat all axes the</span>
<span class="sd">                                                    same).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                          A mask of the local maxima.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">local_maxima_mask</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">local_maxima_mask</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extendedLocalMaxima</span><span class="p">(</span>
            <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">local_maxima_mask</span> <span class="o">=</span> <span class="n">vigra</span><span class="o">.</span><span class="n">analysis</span><span class="o">.</span><span class="n">extendedLocalMaxima3D</span><span class="p">(</span>
            <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span>

    <span class="k">return</span><span class="p">(</span><span class="n">local_maxima_mask</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="generate_local_maxima_scikit_image"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.generate_local_maxima_scikit_image">[docs]</a><span class="k">def</span> <span class="nf">generate_local_maxima_scikit_image</span><span class="p">(</span><span class="n">new_intensity_image</span><span class="p">,</span>
                                       <span class="n">local_max_neighborhood_size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a mask the same size as the intensity image with local maxima</span>
<span class="sd">        as True and background False. Uses scikit image&#39;s</span>
<span class="sd">        skimage.feature.peak_local_max.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_intensity_image(numpy.ndarray):     The image to find local</span>
<span class="sd">                                                    maxima for (ideally, all</span>
<span class="sd">                                                    axes are spatial; however,</span>
<span class="sd">                                                    it will treat all axes the</span>
<span class="sd">                                                    same).</span>

<span class="sd">            local_max_neighborhood_size(int):       Size of the neighborhood to</span>
<span class="sd">                                                    check for a local maxima.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                          A mask of the local maxima.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">local_maxima_neighborhood</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">local_max_neighborhood_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">ndim</span>
    <span class="p">)</span>
    <span class="n">local_maxima_mask</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">feature</span><span class="o">.</span><span class="n">peak_local_max</span><span class="p">(</span>
        <span class="n">new_intensity_image</span><span class="p">,</span>
        <span class="n">footprint</span><span class="o">=</span><span class="n">local_maxima_neighborhood</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="p">(</span><span class="n">new_intensity_image</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">indices</span><span class="o">=</span><span class="bp">False</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">local_maxima_mask</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="generate_local_maxima"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.generate_local_maxima">[docs]</a><span class="k">def</span> <span class="nf">generate_local_maxima</span><span class="p">(</span><span class="n">new_intensity_image</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a mask the same size as the intensity image with local maxima</span>
<span class="sd">        as True and background False.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_intensity_image(numpy.ndarray):     The image to find local</span>
<span class="sd">                                                    maxima for (ideally, all</span>
<span class="sd">                                                    axes are spatial; however,</span>
<span class="sd">                                                    it will treat all axes the</span>
<span class="sd">                                                    same).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                          A mask of the local maxima.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span><span class="p">(</span><span class="n">generate_local_maxima_vigra</span><span class="p">(</span><span class="n">new_intensity_image</span><span class="p">))</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="extended_region_local_maxima_properties"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.extended_region_local_maxima_properties">[docs]</a><span class="k">def</span> <span class="nf">extended_region_local_maxima_properties</span><span class="p">(</span>
        <span class="n">new_intensity_image</span><span class="p">,</span>
        <span class="n">new_label_image</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates local maxima along with other properties for each labeled</span>
<span class="sd">        region (therefore at least one entry per label). Gets a label image if</span>
<span class="sd">        not provided by using the threshold (if not provided is zero).</span>

<span class="sd">        Note:</span>
<span class="sd">            This is similar to region_properties. It differs in that it keeps</span>
<span class="sd">            track of all local maxima. So, it is no longer one-to-one in</span>
<span class="sd">            labels, but is one-to-one in local maxima.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_intensity_image(numpy.ndarray):     The intensity image to find</span>
<span class="sd">                                                    local maxima for (ideally,</span>
<span class="sd">                                                    all axes are spatial;</span>
<span class="sd">                                                    however, it will treat all</span>
<span class="sd">                                                    axes the same).</span>

<span class="sd">            new_label_image(numpy.ndarray):         The label image to find</span>
<span class="sd">                                                    local maxima for (ideally,</span>
<span class="sd">                                                    all axes are spatial;</span>
<span class="sd">                                                    however, it will treat all</span>
<span class="sd">                                                    axes the same).</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                          A mask of the local maxima.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Remove the background</span>
    <span class="n">new_image_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_label_image</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">new_intensity_image_masked</span> <span class="o">=</span> <span class="p">(</span><span class="o">~</span><span class="n">new_image_mask</span> <span class="o">*</span> <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">min</span><span class="p">())</span> <span class="o">+</span> \
                                 <span class="p">(</span><span class="n">new_image_mask</span> <span class="o">*</span> <span class="n">new_intensity_image</span><span class="p">)</span>

    <span class="c1"># Get a mask of the local maxima</span>
    <span class="c1"># that only includes local maxima not in the background</span>
    <span class="n">local_maxima_mask</span> <span class="o">=</span> <span class="n">generate_local_maxima</span><span class="p">(</span><span class="n">new_intensity_image_masked</span><span class="p">)</span>

    <span class="c1"># Count the local maxima and give them different labels</span>
    <span class="n">local_maxima_labeled</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span>
        <span class="n">local_maxima_mask</span>
    <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Generate the properties of the labeled regions</span>
    <span class="n">labeled_props</span> <span class="o">=</span> <span class="n">region_properties</span><span class="p">(</span><span class="n">new_label_image</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Generate the properties of the local maxima</span>
    <span class="n">local_maxima_props</span> <span class="o">=</span> <span class="n">region_properties</span><span class="p">(</span>
        <span class="n">local_maxima_labeled</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="s2">&quot;centroid&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># We want to have a few more type present in our NumPy structured array.</span>
    <span class="c1"># To do this, we collect the existing types into a list and</span>
    <span class="c1"># add our new types onto the end. Finally,</span>
    <span class="c1"># we make the new structured array type from the list we have.</span>
    <span class="n">props_dtype</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Place on the label props dtype first</span>
    <span class="n">labeled_props_dtype</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">numpy_structured_array_dtype_list</span><span class="p">(</span>
        <span class="n">labeled_props</span>
    <span class="p">)</span>
    <span class="n">props_dtype</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">labeled_props_dtype</span><span class="p">)</span>

    <span class="c1"># Then add new fields.</span>
    <span class="n">props_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;local_max&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">props_dtype</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;intensity&quot;</span><span class="p">,</span> <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

    <span class="c1"># Makes a new properties array that contains enough entries to hold the</span>
    <span class="c1"># old one and has all the types we desire.</span>
    <span class="n">new_local_maxima_props</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="n">local_maxima_props</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">props_dtype</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Take the centroids and old labels as the label and local max</span>
    <span class="n">new_local_maxima_props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_maxima_props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
    <span class="n">new_local_maxima_props</span><span class="p">[</span><span class="s2">&quot;local_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_maxima_props</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">round</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># Replace the old structured array with the enlarged version.</span>
    <span class="n">local_maxima_props</span> <span class="o">=</span> <span class="n">new_local_maxima_props</span>

    <span class="c1"># Stores the intensity at the local max for easy retrieval</span>
    <span class="c1"># Replace the labels by using the values from the label image</span>
    <span class="k">if</span> <span class="n">local_maxima_props</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">local_maxima_props_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">local_maxima_props</span><span class="p">[</span><span class="s2">&quot;local_max&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">local_maxima_props</span><span class="p">[</span><span class="s2">&quot;intensity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_intensity_image</span><span class="p">[</span><span class="n">local_maxima_props_indices</span><span class="p">]</span>
        <span class="n">local_maxima_props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_label_image</span><span class="p">[</span><span class="n">local_maxima_props_indices</span><span class="p">]</span>

    <span class="c1"># Now, we want to merge the other properties in with our local maxima</span>
    <span class="c1"># But, we will skip it if there are no local maxima.</span>
    <span class="k">if</span> <span class="n">local_maxima_props</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">each_i</span><span class="p">,</span> <span class="n">each_label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labeled_props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]):</span>
            <span class="n">each_label_props_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">local_maxima_props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">each_label</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">each_new_prop_name</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">__</span> <span class="ow">in</span> <span class="n">labeled_props_dtype</span><span class="p">:</span>
                <span class="n">local_maxima_props</span><span class="p">[</span><span class="n">each_new_prop_name</span><span class="p">][</span><span class="n">each_label_props_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">labeled_props</span><span class="p">[</span><span class="n">each_new_prop_name</span><span class="p">][</span><span class="n">each_i</span><span class="p">]</span>

    <span class="k">return</span><span class="p">(</span><span class="n">local_maxima_props</span><span class="p">)</span></div>


<span class="nd">@prof.log_class</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.class_static_array_debug_recorder</span>
<div class="viewcode-block" id="ExtendedRegionProps"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.ExtendedRegionProps">[docs]</a><span class="k">class</span> <span class="nc">ExtendedRegionProps</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Using the results of extended_region_local_maxima_properties with given</span>
<span class="sd">        intensity and label images, the ExtendedRegionProps attempts to make it</span>
<span class="sd">        easy to get information about local maxima in the image. Further, it</span>
<span class="sd">        provides methods to allow removal of local maxima. When removing local</span>
<span class="sd">        maxima, it will updated the given label image to reflect labels that</span>
<span class="sd">        have been removed completely and will automatically renumber the label</span>
<span class="sd">        image (as some functions expect a label image with sequential</span>
<span class="sd">        numbering, no missing label number). This provides a simple way to</span>
<span class="sd">        maintain a label image, whose local maxima one is more interested in</span>
<span class="sd">        directly manipulating.</span>

<span class="sd">        Note:</span>
<span class="sd">            Adding local maxima is not allowed for and wouldn&#39;t make sense</span>
<span class="sd">            given its dependency on the intensity image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">new_intensity_image</span><span class="p">,</span>
                 <span class="n">new_label_image</span><span class="p">,</span>
                 <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Construct an ExtendedRegionProps instance.</span>

<span class="sd">            This uses extended_region_local_maxima_properties to determine</span>
<span class="sd">            local maxima and properties for the labeled region. After doing</span>
<span class="sd">            this, it is possible to remove local maxima and update the label</span>
<span class="sd">            image to reflect this change.</span>

<span class="sd">            Args:</span>
<span class="sd">                new_intensity_image(numpy.ndarray):     The intensity image to</span>
<span class="sd">                                                        find local maxima for</span>
<span class="sd">                                                        (ideally, all axes are</span>
<span class="sd">                                                        spatial; however, it</span>
<span class="sd">                                                        will treat all axes</span>
<span class="sd">                                                        the same).</span>

<span class="sd">                new_label_image(numpy.ndarray):         The label image to find</span>
<span class="sd">                                                        local maxima for (</span>
<span class="sd">                                                        ideally, all axes are</span>
<span class="sd">                                                        spatial; however, it</span>
<span class="sd">                                                        will treat all axes the</span>
<span class="sd">                                                        same).</span>

<span class="sd">                properties(list):                       used to generate</span>
<span class="sd">                                                        initial properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Copied to ensure purity. Would not want to change outside values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span> <span class="o">=</span> <span class="n">new_intensity_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span> <span class="o">=</span> <span class="n">new_label_image</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">image_mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_image</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finding the local maxima and properties...&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">extended_region_local_maxima_properties</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="p">,</span>
            <span class="n">properties</span><span class="o">=</span><span class="n">properties</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Found the local maxima and properties.&quot;</span><span class="p">)</span>

        <span class="c1"># Remove maxima in the background</span>
        <span class="n">background_maxima_mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">background_maxima_mask</span><span class="p">)):</span>
            <span class="c1"># There shouldn&#39;t be any maximums in the background. This should</span>
            <span class="c1"># never happen.</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">background_maxima_mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span>
                <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> maximum(s) found in the background (label 0).&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Remove the 0 labels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="n">background_maxima_mask</span><span class="p">]</span>

        <span class="k">del</span> <span class="n">background_maxima_mask</span>

        <span class="c1"># Stores the number of times a particular label maxima appears.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="o">.</span><span class="n">max</span><span class="p">(),),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)])</span>
        <span class="c1"># Get all the labels used in the label image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Get the count of those labels (excluding zero as it is background)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># All labels should have a local maximum. If they don&#39;t, this could</span>
            <span class="c1"># be a problem.</span>

            <span class="n">failed_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">failed_labels_list</span> <span class="o">=</span> <span class="n">failed_labels</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">failed_label_msg</span> <span class="o">=</span> <span class="s2">&quot;Label(s) not found in local maxima.&quot;</span> <span class="o">+</span> \
                               <span class="s2">&quot; For labels = &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">failed_labels_list</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">failed_label_msg</span><span class="p">)</span>

            <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;intensity_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
            <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;label_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;props&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span>

            <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span>
            <span class="k">if</span> <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
                <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;masks&quot;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">xnumpy</span><span class="o">.</span><span class="n">all_permutations_equal</span><span class="p">(</span>
                            <span class="n">failed_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span>
                    <span class="p">)</span>
            <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;masks_labels&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">failed_labels</span>

            <span class="c1"># Renumber labels.</span>
            <span class="c1"># This way there are no labels without local maxima.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">renumber_labels</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Refinined properties for local maxima.&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="ExtendedRegionProps.get_local_max_index_array"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.ExtendedRegionProps.get_local_max_index_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_max_index_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Gets a numpy style index array from the local maxima present.</span>

<span class="sd">            Returns:</span>
<span class="sd">                tuple:      a numpy styled index array, which can be used on</span>
<span class="sd">                            the intensity image, or label image.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;local_max&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">))</span></div>


<div class="viewcode-block" id="ExtendedRegionProps.get_local_max_mask"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.ExtendedRegionProps.get_local_max_mask">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_max_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Gets a bool numpy array that is True at the locations of the local</span>
<span class="sd">            maxima.</span>

<span class="sd">            Returns:</span>
<span class="sd">                numpy.ndarray:      a bool numpy array that is True where a</span>
<span class="sd">                                    local max is and False everywhere else.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Returns a label image containing each local max and its label.</span>
        <span class="n">new_local_max_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="c1"># Set the given local maxima to be the same as their labels</span>
        <span class="n">new_local_max_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_local_max_index_array</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span><span class="p">(</span><span class="n">new_local_max_mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="ExtendedRegionProps.get_local_max_label_image"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.ExtendedRegionProps.get_local_max_label_image">[docs]</a>    <span class="k">def</span> <span class="nf">get_local_max_label_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Gets an int numpy array that contains the labels of the local</span>
<span class="sd">            maxima.</span>

<span class="sd">            Returns:</span>
<span class="sd">                numpy.ndarray:      an int numpy array that contains the labels</span>
<span class="sd">                                    of the local maxima and is zero in the</span>
<span class="sd">                                    background.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Returns a label image containing each local max and its labels.</span>
        <span class="n">new_local_max_label_image</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>

        <span class="c1"># Set the given local maxima to be the same as their labels</span>
        <span class="n">new_local_max_label_image</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_local_max_index_array</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>

        <span class="k">return</span><span class="p">(</span><span class="n">new_local_max_label_image</span><span class="p">)</span></div>


<div class="viewcode-block" id="ExtendedRegionProps.remove_prop_mask"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.ExtendedRegionProps.remove_prop_mask">[docs]</a>    <span class="k">def</span> <span class="nf">remove_prop_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_prop_indices_mask</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Removes the local maxima by the mask over their indices (only False</span>
<span class="sd">            elements will be kept).</span>

<span class="sd">            Note:</span>
<span class="sd">                If a label is removed completely, the label image, intensity</span>
<span class="sd">                image, and image mask will be updated. Also, the count (of</span>
<span class="sd">                local maxima per label) will be updated, regardless.</span>

<span class="sd">            Args:</span>
<span class="sd">                remove_prop_indices_mask(numpy.ndarray):     A mask of the</span>
<span class="sd">                                                             indices to drop</span>
<span class="sd">                                                             (True for the ones</span>
<span class="sd">                                                             to remove, and</span>
<span class="sd">                                                             False for the ones</span>
<span class="sd">                                                             to keep).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the labels to remove</span>
        <span class="n">remove_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">remove_prop_indices_mask</span><span class="p">]</span>
        <span class="c1"># Get how many of each label to remove</span>
        <span class="n">label_count_to_remove</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="n">remove_labels</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Take a subset of the label props that does not include the removal</span>
        <span class="c1"># mask (copying may not be necessary as the mask may be as effective).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="o">~</span><span class="n">remove_prop_indices_mask</span><span class="p">]</span>
        <span class="c1"># Reduce the count by the number of each label</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">-=</span> <span class="n">label_count_to_remove</span>

        <span class="c1"># Mask over self.count to find labels that do not have local maxima</span>
        <span class="n">inactive_label_count_mask</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Are there labels that do not exist now? If so, we will dump them.</span>
        <span class="k">if</span> <span class="n">inactive_label_count_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># Find the labels to remove from the label image and mask and</span>
            <span class="c1"># remove them</span>
            <span class="n">labels_to_remove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">inactive_label_count_mask</span><span class="p">]</span>
            <span class="n">labels_to_remove_mask</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="p">,</span> <span class="n">labels_to_remove</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="n">labels_to_remove_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_mask</span><span class="p">[</span><span class="n">labels_to_remove_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intensity_image</span><span class="p">[</span><span class="n">labels_to_remove_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Renumber all labels sequentially starting with the label image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">renumber_labels</span><span class="p">()</span></div>


<div class="viewcode-block" id="ExtendedRegionProps.remove_prop_indices"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.ExtendedRegionProps.remove_prop_indices">[docs]</a>    <span class="k">def</span> <span class="nf">remove_prop_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Removes the local maxima of the indices listed (like</span>
<span class="sd">            remove_prop_mask except with indices).</span>

<span class="sd">            Note:</span>
<span class="sd">                If a label is removed completely, the label image, intensity</span>
<span class="sd">                image, and image mask will be updated. Also, the count (of</span>
<span class="sd">                local maxima per label) will be updated, regardless.</span>

<span class="sd">            Args:</span>
<span class="sd">                *i(int):     A mask of the indices to drop (True for the ones</span>
<span class="sd">                             to remove, and False for the ones to keep).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># A mask of the indices to remove</span>
        <span class="n">remove_prop_indices_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">remove_prop_indices_mask</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_prop_mask</span><span class="p">(</span><span class="n">remove_prop_indices_mask</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExtendedRegionProps.renumber_labels"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.ExtendedRegionProps.renumber_labels">[docs]</a>    <span class="k">def</span> <span class="nf">renumber_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            An internal method to be called after a label is completely removed</span>
<span class="sd">            from the local maxima.</span>

<span class="sd">            Ensures all labels are in sequential order in the label image,</span>
<span class="sd">            count, and that all local maxima have their labels updated.</span>


<span class="sd">            Note:</span>
<span class="sd">                Calling this externally will not make a difference as long as</span>
<span class="sd">                removal has occurred through the usual mechanisms.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Renumber all labels sequentially starting with the label image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span><span class="p">[:],</span> <span class="n">forward_label_mapping</span><span class="p">,</span> <span class="n">reverse_label_mapping</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">segmentation</span><span class="o">.</span><span class="n">relabel_sequential</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label_image</span>
        <span class="p">)</span>

        <span class="c1"># Remove zero from the mappings as it is background and remains the</span>
        <span class="c1"># same</span>
        <span class="n">forward_label_mapping</span> <span class="o">=</span> <span class="n">forward_label_mapping</span><span class="p">[</span><span class="n">forward_label_mapping</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">reverse_label_mapping</span> <span class="o">=</span> <span class="n">reverse_label_mapping</span><span class="p">[</span><span class="n">reverse_label_mapping</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Find which of the old labels appear in self.props[&quot;label&quot;] (skip 0)</span>
        <span class="n">props_reverse_mapped</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">all_permutations_equal</span><span class="p">(</span>
            <span class="n">reverse_label_mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Get the new labels by noting they must range from 0 to the length of</span>
        <span class="c1"># reverse_label_mapping. Skip zero as it is not necessary to check</span>
        <span class="c1"># for it.</span>
        <span class="n">new_labels</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">reverse_label_mapping</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Expand new_labels into a view of the same size as</span>
        <span class="c1"># props_reverse_mapped</span>
        <span class="n">new_labels_expanded</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">expand_view</span><span class="p">(</span>
            <span class="n">new_labels</span><span class="p">,</span> <span class="n">reps_after</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="c1"># Replace the labels with the matches and combine them</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">props_reverse_mapped</span> <span class="o">*</span> <span class="n">new_labels_expanded</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Get a mask over the labels to find what is contained</span>
        <span class="n">new_count_mask</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="n">reverse_label_mapping</span>
        <span class="p">)</span>
        <span class="c1"># Move the values of the count into the proper lower labels and zero</span>
        <span class="c1"># everything else</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][:</span><span class="nb">len</span><span class="p">(</span><span class="n">reverse_label_mapping</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="n">new_count_mask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">reverse_label_mapping</span><span class="p">):]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># (copying may not be necessary as the slice may be as effective)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">reverse_label_mapping</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="remove_low_intensity_local_maxima"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.remove_low_intensity_local_maxima">[docs]</a><span class="k">def</span> <span class="nf">remove_low_intensity_local_maxima</span><span class="p">(</span><span class="n">local_maxima</span><span class="p">,</span>
                                      <span class="n">percentage_pixels_below_max</span><span class="p">,</span>
                                      <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the local maxima for regions, which have too many pixels that</span>
<span class="sd">        are below the intensity of their local maxima.</span>

<span class="sd">        Args:</span>
<span class="sd">            local_maxima(ExtendedRegionProps):      The local maxima to refine</span>

<span class="sd">            percentage_pixels_below_max(float):     The percentage of pixels</span>
<span class="sd">                                                    out of a region that are</span>
<span class="sd">                                                    below the local maxima of</span>
<span class="sd">                                                    the region</span>

<span class="sd">            **parameters(dict):                     essentially unused (catches</span>
<span class="sd">                                                    unneeded arguments).</span>

<span class="sd">        Returns:</span>
<span class="sd">            ExtendedRegionProps:                    a new instance with the</span>
<span class="sd">                                                    local maxima removed</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Deleting local maxima that does not exceed the 90th percentile of the</span>
    <span class="c1"># pixel intensities</span>
    <span class="n">low_intensities__local_maxima_label_mask__to_remove</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">)):</span>
        <span class="c1"># Get the region with the label matching the maximum</span>
        <span class="n">each_region_image_wavelet_mask</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">local_maxima</span><span class="o">.</span><span class="n">label_image</span> <span class="o">==</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">each_region_image_wavelet</span> <span class="o">=</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">intensity_image</span><span class="p">[</span><span class="n">each_region_image_wavelet_mask</span><span class="p">]</span>

        <span class="c1"># Get the number of pixels in that region</span>
        <span class="n">each_region_image_wavelet_num_pixels</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="n">each_region_image_wavelet</span><span class="o">.</span><span class="n">size</span>
        <span class="p">)</span>

        <span class="c1"># Get the value of the max for that region</span>
        <span class="n">each_region_image_wavelet_local_max_value</span> <span class="o">=</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;intensity&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Get a mask of the pixels below that max for that region</span>
        <span class="n">each_region_image_wavelet_num_pixels_below_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span>
            <span class="p">(</span><span class="n">each_region_image_wavelet</span> <span class="o">&lt;</span> <span class="n">each_region_image_wavelet_local_max_value</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="p">)</span>

        <span class="c1"># Get a ratio of the number of pixels below that max for that region</span>
        <span class="n">each_region_image_wavelet_ratio_pixels</span> <span class="o">=</span> <span class="n">each_region_image_wavelet_num_pixels_below_max</span> <span class="o">/</span> \
            <span class="n">each_region_image_wavelet_num_pixels</span>

        <span class="c1"># If the ratio clears our threshold, keep this label. Otherwise,</span>
        <span class="c1"># eliminate it.</span>
        <span class="n">low_intensities__local_maxima_label_mask__to_remove</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">each_region_image_wavelet_ratio_pixels</span> <span class="o">&lt;</span> <span class="n">percentage_pixels_below_max</span>
        <span class="p">)</span>

    <span class="n">new_local_maxima</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">local_maxima</span><span class="p">)</span>

    <span class="n">new_local_maxima</span><span class="o">.</span><span class="n">remove_prop_mask</span><span class="p">(</span>
        <span class="n">low_intensities__local_maxima_label_mask__to_remove</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removed low intensity maxima that are too close.&quot;</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_local_maxima</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<div class="viewcode-block" id="remove_too_close_local_maxima"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.remove_too_close_local_maxima">[docs]</a><span class="k">def</span> <span class="nf">remove_too_close_local_maxima</span><span class="p">(</span><span class="n">local_maxima</span><span class="p">,</span>
                                  <span class="n">min_local_max_distance</span><span class="p">,</span>
                                  <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes local maxima that are too close to each other.</span>

<span class="sd">        Args:</span>
<span class="sd">            local_maxima(ExtendedRegionProps):      The local maxima to refine</span>

<span class="sd">            min_local_max_distance(float):          The minimum allowed</span>
<span class="sd">                                                    distance between local</span>
<span class="sd">                                                    maxima</span>

<span class="sd">            **parameters(dict):                     essentially unused (catches</span>
<span class="sd">                                                    unneeded arguments).</span>

<span class="sd">        Returns:</span>
<span class="sd">            ExtendedRegionProps:                    a new instance with the</span>
<span class="sd">                                                    local maxima removed</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Deleting close local maxima below 16 pixels</span>
    <span class="n">too_close__local_maxima_label_mask__to_remove</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Find the distance between every local max (efficiently)</span>
    <span class="n">local_maxima_pairs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="n">local_maxima_distances</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span>
        <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;local_max&quot;</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="s2">&quot;euclidean&quot;</span><span class="p">)</span>

    <span class="n">too_close_local_maxima_labels_mask</span> <span class="o">=</span> <span class="n">local_maxima_distances</span> <span class="o">&lt;</span> <span class="n">min_local_max_distance</span>
    <span class="n">too_close_local_maxima_pairs</span> <span class="o">=</span> <span class="n">local_maxima_pairs</span><span class="p">[</span>
        <span class="n">too_close_local_maxima_labels_mask</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">each_too_close_local_maxima_pairs</span> <span class="ow">in</span> <span class="n">too_close_local_maxima_pairs</span><span class="p">:</span>
        <span class="n">first_props_index</span><span class="p">,</span> <span class="n">second_props_index</span> <span class="o">=</span> <span class="n">each_too_close_local_maxima_pairs</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">first_props_index</span><span class="p">]</span> <span class="o">==</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">second_props_index</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;intensity&quot;</span><span class="p">][</span><span class="n">first_props_index</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;intensity&quot;</span><span class="p">][</span><span class="n">second_props_index</span><span class="p">]:</span>
                <span class="n">too_close__local_maxima_label_mask__to_remove</span><span class="p">[</span><span class="n">first_props_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">too_close__local_maxima_label_mask__to_remove</span><span class="p">[</span><span class="n">second_props_index</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="n">new_local_maxima</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">local_maxima</span><span class="p">)</span>

    <span class="n">new_local_maxima</span><span class="o">.</span><span class="n">remove_prop_mask</span><span class="p">(</span><span class="n">too_close__local_maxima_label_mask__to_remove</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removed local maxima that are too close.&quot;</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_local_maxima</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="wavelet_thresholding"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.wavelet_thresholding">[docs]</a><span class="k">def</span> <span class="nf">wavelet_thresholding</span><span class="p">(</span><span class="n">new_image</span><span class="p">,</span>
                         <span class="n">significance_threshold</span><span class="p">,</span>
                         <span class="n">wavelet_scale</span><span class="p">,</span>
                         <span class="n">noise_threshold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds a thresholding using a noise estimate and the wavelet transform.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_image(numpy.ndarray):                   image to threshold.</span>

<span class="sd">            significance_threshold(float):              threshold above which</span>
<span class="sd">                                                        everything is</span>
<span class="sd">                                                        considered significant</span>
<span class="sd">                                                        for the purpose of</span>
<span class="sd">                                                        noise estimation.</span>

<span class="sd">            wavelet_scale(int):                         the scale of wavelet</span>
<span class="sd">                                                        transform to use.</span>

<span class="sd">            noise_threshold(float):                     a ratio to which the</span>
<span class="sd">                                                        noise estimate scales</span>
<span class="sd">                                                        (e.g. 1.0 means the</span>
<span class="sd">                                                        noise computed is the</span>
<span class="sd">                                                        noise used).</span>

<span class="sd">        Returns:</span>
<span class="sd">            tuple of numpy.ndarray:                     a wavelet transformed</span>
<span class="sd">                                                        array and a mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_wavelet_transformed_image</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">new_wavelet_transformed_image_significant_mask</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># Contains a bool array with significant values True and noise False.</span>
    <span class="n">new_image_noise_estimate</span> <span class="o">=</span> <span class="n">estimate_noise</span><span class="p">(</span>
        <span class="n">new_image</span><span class="p">,</span>
        <span class="n">significance_threshold</span><span class="o">=</span><span class="n">significance_threshold</span>
    <span class="p">)</span>

    <span class="c1"># Dictionary with wavelet transform applied. Wavelet transform is the</span>
    <span class="c1"># first index.</span>
    <span class="n">new_wavelet_transformed_image</span> <span class="o">=</span> <span class="n">wavelet</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span>
        <span class="n">new_image</span><span class="p">,</span>
        <span class="n">include_intermediates</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="n">include_lower_scales</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">scale</span><span class="o">=</span><span class="n">wavelet_scale</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">wavelet_thresholding</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_wavelet_transformed_image</span><span class="p">)):</span>
            <span class="n">wavelet_thresholding</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_wavelet_transformed_image&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">new_wavelet_transformed_image</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">None</span><span class="p">]</span>

    <span class="c1"># Contains a bool array with significant values True and noise False for</span>
    <span class="c1"># all wavelet transforms.</span>
    <span class="n">new_wavelet_transformed_image_significant_mask</span> <span class="o">=</span> <span class="n">significant_mask</span><span class="p">(</span>
        <span class="n">new_wavelet_transformed_image</span><span class="p">,</span>
        <span class="n">noise_estimate</span><span class="o">=</span><span class="n">new_image_noise_estimate</span><span class="p">,</span>
        <span class="n">noise_threshold</span><span class="o">=</span><span class="n">noise_threshold</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span>
        <span class="n">new_wavelet_transformed_image</span><span class="p">,</span>
        <span class="n">new_wavelet_transformed_image_significant_mask</span>
    <span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="match_regions_properties"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.match_regions_properties">[docs]</a><span class="k">def</span> <span class="nf">match_regions_properties</span><span class="p">(</span><span class="n">props</span><span class="p">,</span> <span class="n">constraints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a mask selecting the regions with matching properties.</span>

<span class="sd">        Args:</span>
<span class="sd">            props(numpy.ndarray):           properties of each labeled region.</span>

<span class="sd">            constraints(dict):              dictionary containing each property</span>
<span class="sd">                                            with optional ``min`` and ``max``</span>
<span class="sd">                                            for each value.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                  mask with each region property that</span>
<span class="sd">                                            matches marked as ``True`` and the</span>
<span class="sd">                                            rest marked as ``False``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">within_bound</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">props</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

    <span class="c1"># Go through each property and make sure they are within the bounds</span>
    <span class="k">for</span> <span class="n">each_prop</span><span class="p">,</span> <span class="n">each_prop_constraints</span> <span class="ow">in</span> <span class="n">constraints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># If there is a lower bound, checks to see which are above it.</span>
        <span class="n">is_lower_bounded_maybe</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="s2">&quot;min&quot;</span> <span class="ow">in</span> <span class="n">each_prop_constraints</span><span class="p">:</span>
            <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">each_prop_constraints</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span>
            <span class="n">is_lower_bounded_maybe</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">lower_bound</span> <span class="o">&lt;=</span> <span class="n">props</span><span class="p">[</span><span class="n">each_prop</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_lower_bounded_maybe</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                <span class="n">props</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
            <span class="p">)</span>

        <span class="c1"># If there is an upper bound, checks to see which are below it.</span>
        <span class="n">is_upper_bounded_maybe</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="s2">&quot;max&quot;</span> <span class="ow">in</span> <span class="n">each_prop_constraints</span><span class="p">:</span>
            <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">each_prop_constraints</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span>
            <span class="n">is_upper_bounded_maybe</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">props</span><span class="p">[</span><span class="n">each_prop</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">upper_bound</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_upper_bounded_maybe</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                <span class="n">props</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
            <span class="p">)</span>

        <span class="c1"># See whether both or neither bound is satisfied.</span>
        <span class="n">is_within_bound</span> <span class="o">=</span> <span class="n">is_lower_bounded_maybe</span> <span class="o">&amp;</span> <span class="n">is_upper_bounded_maybe</span>

        <span class="c1"># Collect the unbounded ones</span>
        <span class="n">within_bound</span> <span class="o">&amp;=</span> <span class="n">is_within_bound</span>

    <span class="k">return</span><span class="p">(</span><span class="n">within_bound</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="wavelet_denoising"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.wavelet_denoising">[docs]</a><span class="k">def</span> <span class="nf">wavelet_denoising</span><span class="p">(</span><span class="n">new_image</span><span class="p">,</span>
                      <span class="n">accepted_region_shape_constraints</span><span class="p">,</span>
                      <span class="n">accepted_neuron_shape_constraints</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs wavelet denoising on the given dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_image(numpy.ndarray):                   array of data for</span>
<span class="sd">                                                        generating a dictionary</span>
<span class="sd">                                                        (first axis is time).</span>

<span class="sd">            accepted_region_shape_constraints(dict):    a dictionary containing</span>
<span class="sd">                                                        properties (that could</span>
<span class="sd">                                                        be passed to</span>
<span class="sd">                                                        region_properties)</span>
<span class="sd">                                                        under this should be a</span>
<span class="sd">                                                        dictionary that</span>
<span class="sd">                                                        contains the keys min</span>
<span class="sd">                                                        and/or max with a value</span>
<span class="sd">                                                        for each.</span>

<span class="sd">            accepted_neuron_shape_constraints(dict):    a dictionary containing</span>
<span class="sd">                                                        properties (that could</span>
<span class="sd">                                                        be passed to</span>
<span class="sd">                                                        region_properties)</span>
<span class="sd">                                                        under this should be a</span>
<span class="sd">                                                        dictionary that</span>
<span class="sd">                                                        contains the keys min</span>
<span class="sd">                                                        and/or max with a value</span>
<span class="sd">                                                        for each.</span>

<span class="sd">            **parameters(dict):                         additional parameters</span>
<span class="sd">                                                        for various other</span>
<span class="sd">                                                        function calls.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                              a structured array of</span>
<span class="sd">                                                        candidate neurons.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">neurons</span> <span class="o">=</span> <span class="n">get_empty_neuron</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">new_image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">new_wavelet_image_denoised_segmentation</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Started wavelet denoising.&quot;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Removing noise...&quot;</span><span class="p">)</span>

    <span class="c1"># Contains a bool array with significant values True and noise False.</span>
    <span class="n">new_wavelet_transformed_image</span><span class="p">,</span> <span class="n">new_wavelet_transformed_image_significant_mask</span> <span class="o">=</span> <span class="n">wavelet_thresholding</span><span class="p">(</span>
        <span class="n">new_image</span><span class="p">,</span>
        <span class="n">significance_threshold</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;estimate_noise&quot;</span><span class="p">][</span><span class="s2">&quot;significance_threshold&quot;</span><span class="p">],</span>
        <span class="n">wavelet_scale</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;wavelet.transform&quot;</span><span class="p">][</span><span class="s2">&quot;scale&quot;</span><span class="p">],</span>
        <span class="n">noise_threshold</span><span class="o">=</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;significant_mask&quot;</span><span class="p">][</span><span class="s2">&quot;noise_threshold&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">new_wavelet_image_mask</span> <span class="o">=</span> <span class="n">new_wavelet_transformed_image_significant_mask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Creates a new dictionary without the noise</span>
    <span class="n">new_wavelet_image_denoised</span> <span class="o">=</span> <span class="n">new_wavelet_transformed_image</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">new_wavelet_image_denoised</span> <span class="o">*=</span> <span class="n">new_wavelet_image_mask</span>

    <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_wavelet_image_denoised&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_wavelet_image_denoised</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Noise removed.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">new_wavelet_image_denoised</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Frame has content other than noise.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finding the label image...&quot;</span><span class="p">)</span>

        <span class="c1"># For holding the label image</span>
        <span class="n">new_wavelet_image_denoised_labeled</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">new_wavelet_image_denoised</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Found the label image.&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determining the properties of the label image...&quot;</span><span class="p">)</span>

        <span class="c1"># For holding the label image properties</span>
        <span class="n">new_wavelet_image_denoised_labeled_props</span> <span class="o">=</span> <span class="n">region_properties</span><span class="p">(</span>
            <span class="n">new_wavelet_image_denoised_labeled</span><span class="p">,</span>
            <span class="n">properties</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">accepted_region_shape_constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Determined the properties of the label image.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Finding regions that fail to meet some shape constraints...&quot;</span>
        <span class="p">)</span>

        <span class="n">within_bound</span> <span class="o">=</span> <span class="n">match_regions_properties</span><span class="p">(</span>
            <span class="n">new_wavelet_image_denoised_labeled_props</span><span class="p">,</span>
            <span class="n">accepted_region_shape_constraints</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Found regions that fail to meet some shape constraints.&quot;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Reducing wavelet transform on regions outside of constraints...&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Get labels of the unbounded ones</span>
        <span class="n">labels_not_within_bound</span> <span class="o">=</span> <span class="n">new_wavelet_image_denoised_labeled_props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="o">~</span><span class="n">within_bound</span><span class="p">]</span>

        <span class="c1"># Iterate over the unbounded ones to fix any errors.</span>
        <span class="k">for</span> <span class="n">each_labels_not_within_bound</span> <span class="ow">in</span> <span class="n">labels_not_within_bound</span><span class="p">:</span>
            <span class="c1"># Get a mask for the current label</span>
            <span class="n">current_label_mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">new_wavelet_image_denoised_labeled</span> <span class="o">==</span> <span class="n">each_labels_not_within_bound</span>
            <span class="p">)</span>

            <span class="c1"># Get a lower wavelet mask</span>
            <span class="n">lower_wavelet_mask</span> <span class="o">=</span> <span class="n">new_wavelet_transformed_image_significant_mask</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

            <span class="c1"># Replacement mask</span>
            <span class="n">replacement_mask</span> <span class="o">=</span> <span class="n">current_label_mask</span> <span class="o">&amp;</span> <span class="n">lower_wavelet_mask</span>

            <span class="c1"># Zero everything that is not in the replacement region and then</span>
            <span class="c1"># use the lower transformed wavelet.</span>
            <span class="n">new_wavelet_image_denoised_replacement</span> <span class="o">=</span> <span class="n">new_wavelet_transformed_image</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">replacement_mask</span>

            <span class="c1"># Overwrite the area in our old labeled mask to match this lower</span>
            <span class="c1"># wavelet transform</span>
            <span class="n">new_wavelet_image_mask</span><span class="p">[</span><span class="n">current_label_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">lower_wavelet_mask</span><span class="p">[</span><span class="n">current_label_mask</span><span class="p">]</span>

            <span class="c1"># However, overwrite the previously labeled area completely (will</span>
            <span class="c1"># push more things into the background)</span>
            <span class="n">new_wavelet_image_denoised</span><span class="p">[</span><span class="n">current_label_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_wavelet_image_denoised_replacement</span><span class="p">[</span><span class="n">current_label_mask</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Reduced wavelet transform on regions outside of constraints...&quot;</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finding new label image...&quot;</span><span class="p">)</span>

        <span class="n">new_wavelet_image_denoised_label_image</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span>
            <span class="n">new_wavelet_image_denoised</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Found new label image.&quot;</span><span class="p">)</span>

        <span class="c1">#ExtendedRegionProps.recorders.array_debug_recorder = hdf5.record.HDF5EnumeratedArrayRecorder(</span>
        <span class="c1">#    wavelet_denoising.recorders.array_debug_recorder.hdf5_handle</span>
        <span class="c1">#)</span>
        <span class="n">ExtendedRegionProps</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
        <span class="n">local_maxima</span> <span class="o">=</span> <span class="n">ExtendedRegionProps</span><span class="p">(</span>
            <span class="n">new_wavelet_image_denoised</span><span class="p">,</span> <span class="n">new_wavelet_image_denoised_label_image</span>
        <span class="p">)</span>

        <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;local_maxima_label_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;local_maxima_label_image_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_labeled_contours</span><span class="p">(</span>
                <span class="n">local_maxima</span><span class="o">.</span><span class="n">label_image</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">)[</span><span class="bp">None</span><span class="p">]</span>

        <span class="n">local_maxima</span> <span class="o">=</span> <span class="n">remove_low_intensity_local_maxima</span><span class="p">(</span>
            <span class="n">local_maxima</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;remove_low_intensity_local_maxima&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;local_maxima_label_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;local_maxima_label_image_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_labeled_contours</span><span class="p">(</span>
                    <span class="n">local_maxima</span><span class="o">.</span><span class="n">label_image</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">)[</span><span class="bp">None</span><span class="p">]</span>

        <span class="n">local_maxima</span> <span class="o">=</span> <span class="n">remove_too_close_local_maxima</span><span class="p">(</span>
            <span class="n">local_maxima</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;remove_too_close_local_maxima&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;local_maxima_label_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;local_maxima_label_image_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_labeled_contours</span><span class="p">(</span>
                <span class="n">local_maxima</span><span class="o">.</span><span class="n">label_image</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">)[</span><span class="bp">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Entering watershed segmentation.&quot;</span><span class="p">)</span>

            <span class="c1"># Perform the watershed segmentation.</span>

            <span class="c1"># First perform disc opening on the image.</span>
            <span class="c1"># (Actually, we don&#39;t do this according to Ferran.)</span>
            <span class="c1">#new_wavelet_image_denoised_opened = vigra.filters.discOpening(</span>
            <span class="c1">#    new_wavelet_image_denoised.astype(numpy.float32), radius=1</span>
            <span class="c1">#)</span>

            <span class="c1"># We could look for seeds using local maxima.</span>
            <span class="c1"># However, we already know what these should be as these are the</span>
            <span class="c1"># local maxima we have found.</span>
            <span class="n">new_wavelet_image_denoised_maxima</span> <span class="o">=</span> <span class="n">local_maxima</span><span class="o">.</span><span class="n">get_local_max_label_image</span><span class="p">()</span>

            <span class="c1"># Segment with watershed on minimum image</span>
            <span class="c1"># Use seeds from local maxima as local minima</span>
            <span class="c1"># Also, include mask</span>
            <span class="n">new_wavelet_image_denoised_segmentation</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">watershed</span><span class="p">(</span>
                <span class="n">local_maxima</span><span class="o">.</span><span class="n">intensity_image</span><span class="p">,</span>
                <span class="n">new_wavelet_image_denoised_maxima</span><span class="p">,</span>
                <span class="n">mask</span><span class="o">=</span><span class="p">(</span><span class="n">local_maxima</span><span class="o">.</span><span class="n">intensity_image</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_segmentation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_wavelet_image_denoised_segmentation</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_segmentation_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_labeled_contours</span><span class="p">(</span>
                        <span class="n">new_wavelet_image_denoised_segmentation</span>
                <span class="p">)[</span><span class="bp">None</span><span class="p">]</span>

            <span class="n">watershed_local_maxima</span> <span class="o">=</span> <span class="n">ExtendedRegionProps</span><span class="p">(</span>
                <span class="n">local_maxima</span><span class="o">.</span><span class="n">intensity_image</span><span class="p">,</span>
                <span class="n">new_wavelet_image_denoised_segmentation</span><span class="p">,</span>
                <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">accepted_neuron_shape_constraints</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="p">)</span>

            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_label_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_label_image_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_labeled_contours</span><span class="p">(</span>
                    <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">label_image</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">)[</span><span class="bp">None</span><span class="p">]</span>

            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_props&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span>
            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">count</span>

            <span class="c1"># Remove duplicates</span>
            <span class="n">new_watershed_local_maxima_count_duplicates_mask</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;count&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
            <span class="p">)</span>
            <span class="n">new_watershed_local_maxima_count_duplicate_labels</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">count</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">][</span><span class="n">new_watershed_local_maxima_count_duplicates_mask</span><span class="p">]</span>
            <span class="n">new_watershed_local_maxima_props_duplicates_mask</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span>
                <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span> <span class="n">new_watershed_local_maxima_count_duplicate_labels</span>
            <span class="p">)</span>
            <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">remove_prop_mask</span><span class="p">(</span>
                <span class="n">new_watershed_local_maxima_props_duplicates_mask</span>
            <span class="p">)</span>

            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_label_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_label_image_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_labeled_contours</span><span class="p">(</span>
                <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">label_image</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="p">)[</span><span class="bp">None</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_props&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span>
            <span class="k">if</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">count</span>

            <span class="n">within_bound</span> <span class="o">=</span> <span class="n">match_regions_properties</span><span class="p">(</span>
                <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">,</span>
                <span class="n">accepted_neuron_shape_constraints</span>
            <span class="p">)</span>

            <span class="c1"># Get labels outside of bounds and remove them</span>
            <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">remove_prop_mask</span><span class="p">(</span><span class="o">~</span><span class="n">within_bound</span><span class="p">)</span>

            <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_label_image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">label_image</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_label_image_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_labeled_contours</span><span class="p">(</span>
                        <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">label_image</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">)[</span><span class="bp">None</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_props&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span>
            <span class="k">if</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;watershed_local_maxima_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">count</span>

            <span class="k">if</span> <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">neurons</span> <span class="o">=</span> <span class="n">extract_neurons</span><span class="p">(</span>
                        <span class="n">new_image</span><span class="p">,</span>
                        <span class="n">xnumpy</span><span class="o">.</span><span class="n">all_permutations_equal</span><span class="p">(</span>
                            <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">],</span>
                            <span class="n">watershed_local_maxima</span><span class="o">.</span><span class="n">label_image</span>
                        <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Extracted neurons. Found &quot;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; neurons.&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="s2">&quot;Extracted a neuron. Found &quot;</span> <span class="o">+</span>
                        <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot; neuron.&quot;</span>
                    <span class="p">)</span>

                <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neurons</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Exiting watershed segmentation.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No local maxima left that are acceptable neurons.&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Frame is only noise.&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Finished making neurons for the current frame.&quot;</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="extract_neurons"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.extract_neurons">[docs]</a><span class="k">def</span> <span class="nf">extract_neurons</span><span class="p">(</span><span class="n">new_image</span><span class="p">,</span> <span class="n">neuron_masks</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts neurons from an image using a stack of masks.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_image(numpy.ndarray):           spatial coordinates only (no</span>
<span class="sd">                                                time).</span>

<span class="sd">            neuron_masks(numpy.ndarray):        first index of denotes which</span>
<span class="sd">                                                mask and all others are spatial</span>
<span class="sd">                                                indices.</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                      a stack of neurons in the same</span>
<span class="sd">                                                order as the masks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">neurons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">neuron_masks</span><span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">get_neuron_dtype</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">new_image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_masks</span>
    <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_image</span> <span class="o">*</span> <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span>
    <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span><span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;max_F&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span><span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neurons</span><span class="p">)):</span>
        <span class="n">neuron_mask_i_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>

        <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;contour&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_contour_fast</span><span class="p">(</span>
                <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;gaussian_mean&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_mask_i_points</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;gaussian_cov&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">neuron_mask_i_points</span><span class="p">)</span>

    <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neurons</span><span class="p">[</span><span class="s2">&quot;gaussian_mean&quot;</span><span class="p">]</span>

    <span class="k">return</span><span class="p">(</span><span class="n">neurons</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="fuse_neurons"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.fuse_neurons">[docs]</a><span class="k">def</span> <span class="nf">fuse_neurons</span><span class="p">(</span><span class="n">neuron_1</span><span class="p">,</span>
                 <span class="n">neuron_2</span><span class="p">,</span>
                 <span class="n">fraction_mean_neuron_max_threshold</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges the two neurons into one neuron, which is returned.</span>

<span class="sd">        Note:</span>
<span class="sd">            The first neuron (neuron_1) is preferred in tie-breaking</span>
<span class="sd">            situations.</span>

<span class="sd">        Args:</span>
<span class="sd">            neuron_1(numpy.ndarray):            numpy structured array (dtype</span>
<span class="sd">                                                get_neuron_dtype) containing</span>
<span class="sd">                                                the first neuron.</span>

<span class="sd">            neuron_2(numpy.ndarray):            numpy structured array (dtype</span>
<span class="sd">                                                get_neuron_dtype) containing</span>
<span class="sd">                                                the second neuron.</span>

<span class="sd">            **parameters(dict):                 dictionary of parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                      a new neuron that is the result</span>
<span class="sd">                                                of fusing the two.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">fuse_neurons</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
        <span class="n">fuse_neurons</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;neuron_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_1</span>
        <span class="n">fuse_neurons</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;neuron_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">neuron_2</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">neuron_1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">neuron_2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">())</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">neuron_1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">neuron_2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">neuron_1</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span>

    <span class="n">mean_neuron</span> <span class="o">=</span> <span class="p">(</span><span class="n">neuron_1</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">neuron_2</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">mean_neuron_mask</span> <span class="o">=</span> <span class="n">mean_neuron</span> <span class="o">&gt;</span> <span class="p">(</span>
        <span class="n">fraction_mean_neuron_max_threshold</span> <span class="o">*</span> <span class="n">mean_neuron</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

    <span class="c1"># Gaussian mixture model ??? Skipped this.</span>

    <span class="c1"># Creates a NumPy structure array to store</span>
    <span class="n">new_neuron</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">neuron_1</span><span class="p">)</span>

    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_neuron_mask</span>

    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;contour&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">generate_contour_fast</span><span class="p">(</span><span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">])</span>

    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean_neuron</span> <span class="o">*</span> <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span>

    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;area&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;max_F&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="n">new_neuron_mask_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;gaussian_mean&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_mask_points</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;gaussian_cov&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">new_neuron_mask_points</span><span class="p">)</span>

    <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;centroid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron</span><span class="p">[</span><span class="s2">&quot;gaussian_mean&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fuse_neurons</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
        <span class="n">fuse_neurons</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_neuron</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="merge_neuron_sets"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.merge_neuron_sets">[docs]</a><span class="k">def</span> <span class="nf">merge_neuron_sets</span><span class="p">(</span><span class="n">new_neuron_set_1</span><span class="p">,</span>
                      <span class="n">new_neuron_set_2</span><span class="p">,</span>
                      <span class="n">alignment_min_threshold</span><span class="p">,</span>
                      <span class="n">overlap_min_threshold</span><span class="p">,</span>
                      <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>

    <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">merge_neuron_sets</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
    <span class="k">return</span><span class="p">(</span><span class="n">merge_neuron_sets_repeatedly</span><span class="p">(</span>
        <span class="n">new_neuron_set_1</span><span class="p">,</span>
        <span class="n">new_neuron_set_2</span><span class="p">,</span>
        <span class="n">alignment_min_threshold</span><span class="p">,</span>
        <span class="n">overlap_min_threshold</span><span class="p">,</span>
        <span class="o">**</span><span class="n">parameters</span>
    <span class="p">))</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="merge_neuron_sets_once"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.merge_neuron_sets_once">[docs]</a><span class="k">def</span> <span class="nf">merge_neuron_sets_once</span><span class="p">(</span><span class="n">new_neuron_set_1</span><span class="p">,</span>
                           <span class="n">new_neuron_set_2</span><span class="p">,</span>
                           <span class="n">alignment_min_threshold</span><span class="p">,</span>
                           <span class="n">overlap_min_threshold</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges the two sets of neurons into one. Appends neurons that cannot be</span>
<span class="sd">        merged with the existing set.</span>

<span class="sd">        In the functions that follow, it helps to think of each neuron as a</span>
<span class="sd">        vector (instead of as an image). So, dot products for vectors are</span>
<span class="sd">        important.</span>

<span class="sd">        Note:</span>
<span class="sd">            The first neuron set (new_neuron_set_1) is preferred and treated as</span>
<span class="sd">            the set to merge into. However, this function will not change the</span>
<span class="sd">            original argument.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_neuron_set_1(numpy.ndarray):            numpy structured array</span>
<span class="sd">                                                        (dtype get_neuron_dtype)</span>
<span class="sd">                                                        containing the first</span>
<span class="sd">                                                        neuron set (preferred</span>
<span class="sd">                                                        for tie breaking).</span>

<span class="sd">            new_neuron_set_2(numpy.ndarray):            numpy structured array</span>
<span class="sd">                                                        (dtype get_neuron_dtype)</span>
<span class="sd">                                                        containing the second</span>
<span class="sd">                                                        neuron set.</span>

<span class="sd">            alignment_min_threshold(float):             The minimum required</span>
<span class="sd">                                                        cosine of the angle</span>
<span class="sd">                                                        between two neurons for</span>
<span class="sd">                                                        them to be treated as</span>
<span class="sd">                                                        candidates for merging</span>
<span class="sd">                                                        (uses the function</span>
<span class="sd">                                                        expanded_numpy.dot_product_normalized</span>
<span class="sd">                                                        with ord = 2).</span>

<span class="sd">            overlap_min_threshold(numpy.ndarray):       The minimum required</span>
<span class="sd">                                                        dot product (divided by</span>
<span class="sd">                                                        the L1 norm of one of</span>
<span class="sd">                                                        the neurons) for them</span>
<span class="sd">                                                        to be treated as</span>
<span class="sd">                                                        candidates for merging</span>
<span class="sd">                                                        (uses the function</span>
<span class="sd">                                                        expanded_numpy.dot_product_partially_normalized).</span>

<span class="sd">            **parameters(dict):                         dictionary of</span>
<span class="sd">                                                        parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                              a numpy structured</span>
<span class="sd">                                                        array that contains the</span>
<span class="sd">                                                        result of merging the</span>
<span class="sd">                                                        two sets (or appending</span>
<span class="sd">                                                        for neurons that could</span>
<span class="sd">                                                        not be merged).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">new_neuron_set_1</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_1</span>

    <span class="k">if</span> <span class="n">new_neuron_set_2</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_2</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">new_neuron_set_1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">new_neuron_set_2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Have 2 sets of neurons to merge.&quot;</span><span class="p">)</span>

        <span class="n">new_neuron_set</span> <span class="o">=</span> <span class="n">new_neuron_set_1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_neuron_set_1_flattened</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span>
            <span class="n">new_neuron_set_1</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_2_flattened</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span>
            <span class="n">new_neuron_set_2</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">new_neuron_set_1_flattened_mask</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span>
            <span class="n">new_neuron_set_1</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_2_flattened_mask</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span>
            <span class="n">new_neuron_set_2</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Measure the normalized dot product between any two neurons (i.e.</span>
        <span class="c1"># related to the angle of separation)</span>
        <span class="n">new_neuron_set_angle</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">dot_product_normalized</span><span class="p">(</span>
            <span class="n">new_neuron_set_1_flattened</span><span class="p">,</span>
            <span class="n">new_neuron_set_2_flattened</span><span class="p">,</span>
            <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle</span>

        <span class="c1"># Measure the distance between the two masks</span>
        <span class="c1"># (note distance relative to the total mask content of each mask individually)</span>
        <span class="n">new_neuron_set_masks_overlaid_1</span><span class="p">,</span> <span class="n">new_neuron_set_masks_overlaid_2</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">dot_product_partially_normalized</span><span class="p">(</span>
            <span class="n">new_neuron_set_1_flattened_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="n">new_neuron_set_2_flattened_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2</span>

        <span class="c1"># Now that the three measures for the correlation method</span>
        <span class="c1"># have been found, we want to know, which are the best correlated</span>
        <span class="c1"># neurons between the two sets using these measures. This done to find</span>
        <span class="c1"># the neuron in new_neuron_set_1 that best matches each neuron in</span>
        <span class="c1"># new_neuron_set_2.</span>
        <span class="n">new_neuron_set_angle_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_angle</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_all_optimal_i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_all_optimal_i</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_all_optimal_i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_all_optimal_i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span>

        <span class="c1"># Get all the j indices</span>
        <span class="n">new_neuron_set_all_j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">))</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_j&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j</span>

        <span class="c1"># Get the maximum corresponding to the best matched pairs from before</span>
        <span class="n">new_neuron_set_angle_maxes</span> <span class="o">=</span> <span class="n">new_neuron_set_angle</span><span class="p">[(</span><span class="n">new_neuron_set_angle_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j</span><span class="p">,)]</span>
        <span class="n">new_neuron_set_masks_overlaid_1_maxes</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1</span><span class="p">[(</span><span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j</span><span class="p">,)]</span>
        <span class="n">new_neuron_set_masks_overlaid_2_maxes</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2</span><span class="p">[(</span><span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j</span><span class="p">,)]</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_maxes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_maxes</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_maxes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_maxes</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_maxes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_maxes</span>

        <span class="c1"># Store a list of the optimal neurons in the existing set to fuse with</span>
        <span class="c1"># (by default set all values to -1)</span>
        <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="c1"># Create the masks to use for getting the proper indices</span>
        <span class="n">new_neuron_set_angle_maxes_significant</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_maxes_significant_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_maxes_significant</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_maxes_significant_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_maxes_significant_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span>

        <span class="c1"># Get masks that indicate which measurements have the best matching</span>
        <span class="c1"># neuron</span>
        <span class="n">new_neuron_set_angle_maxes_significant</span><span class="p">[</span><span class="n">new_neuron_set_angle_maxes</span> <span class="o">&gt;</span> <span class="n">alignment_min_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span><span class="p">[</span>
            <span class="o">~</span><span class="n">new_neuron_set_angle_maxes_significant</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">new_neuron_set_masks_overlaid_2_maxes</span> <span class="o">&gt;</span> <span class="n">overlap_min_threshold</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span><span class="p">[</span>
            <span class="o">~</span><span class="n">new_neuron_set_angle_maxes_significant</span> <span class="o">&amp;</span>
            <span class="o">~</span><span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">new_neuron_set_masks_overlaid_1_maxes</span> <span class="o">&gt;</span> <span class="n">overlap_min_threshold</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_maxes_significant_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_maxes_significant</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_maxes_significant_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_maxes_significant_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span>

        <span class="c1"># Using the masks construct the best match neuron index for each case</span>
        <span class="c1"># After doing these three, new_neuron_set_all_optimal_i will contain either</span>
        <span class="c1"># the index of the neuron to fuse with in new_neuron_set for each</span>
        <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_angle_maxes_significant</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_angle_maxes_significant</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>


        <span class="c1"># Separate all the best matches that were found from those that were not.</span>
        <span class="c1"># Also, remove the -1 as they have served their purpose.</span>
        <span class="n">new_neuron_set_all_optimal_i_found</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_all_j_fuse</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j</span><span class="p">[</span><span class="n">new_neuron_set_all_optimal_i_found</span><span class="p">]</span>
        <span class="n">new_neuron_set_all_j_append</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j</span><span class="p">[</span><span class="o">~</span><span class="n">new_neuron_set_all_optimal_i_found</span><span class="p">]</span>
        <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_all_optimal_i_found</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_found&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i_found</span>

        <span class="k">if</span> <span class="n">new_neuron_set_all_j_fuse</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_j_fuse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j_fuse</span>

        <span class="k">if</span> <span class="n">new_neuron_set_all_j_append</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_j_append&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j_append</span>

        <span class="k">if</span> <span class="n">new_neuron_set_all_optimal_i</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_4&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="c1"># Fuse all the neurons that can be from new_neuron_set_2 to the</span>
        <span class="c1"># new_neuron_set (composed of new_neuron_set_1)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span>
                <span class="n">new_neuron_set_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j_fuse</span>
        <span class="p">):</span>
            <span class="c1">#fuse_neurons.recorders.array_debug_recorder = hdf5.record.HDF5EnumeratedArrayRecorder(</span>
            <span class="c1">#    merge_neuron_sets_once.recorders.array_debug_recorder.hdf5_handle</span>
            <span class="c1">#)</span>
            <span class="n">fuse_neurons</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>

            <span class="n">new_neuron_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fuse_neurons</span><span class="p">(</span>
                <span class="n">new_neuron_set_1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">new_neuron_set_2</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;fuse_neurons&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Fused </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_all_j_fuse</span><span class="p">))</span> <span class="o">+</span>
            <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> neurons to the existing set.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Tack on the ones that must be appended</span>
        <span class="n">new_neuron_set</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">new_neuron_set</span><span class="p">,</span> <span class="n">new_neuron_set_2</span><span class="p">[</span><span class="n">new_neuron_set_all_j_append</span><span class="p">]]</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Added </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_all_j_append</span><span class="p">))</span> <span class="o">+</span>
            <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> new neurons to the existing set.&quot;</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_1</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Have 1 set of neurons to merge. Only the first set has neurons.&quot;</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set</span> <span class="o">=</span> <span class="n">new_neuron_set_1</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Have 1 set of neurons to merge. Only the second set has neurons.&quot;</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set</span> <span class="o">=</span> <span class="n">new_neuron_set_2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Have 0 sets of neurons to merge.&quot;</span><span class="p">)</span>
        <span class="n">new_neuron_set</span> <span class="o">=</span> <span class="n">new_neuron_set_1</span>

    <span class="k">if</span> <span class="n">new_neuron_set</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">merge_neuron_sets_once</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_merged_neurons_set&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="merge_neuron_sets_repeatedly"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.merge_neuron_sets_repeatedly">[docs]</a><span class="k">def</span> <span class="nf">merge_neuron_sets_repeatedly</span><span class="p">(</span><span class="n">new_neuron_set_1</span><span class="p">,</span>
                                 <span class="n">new_neuron_set_2</span><span class="p">,</span>
                                 <span class="n">alignment_min_threshold</span><span class="p">,</span>
                                 <span class="n">overlap_min_threshold</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges the two sets of neurons into one. Appends neurons that cannot be</span>
<span class="sd">        merged with the existing set.</span>

<span class="sd">        In the functions that follow, it helps to think of each neuron as a</span>
<span class="sd">        vector (instead of as an image). So, dot products for vectors are</span>
<span class="sd">        important.</span>

<span class="sd">        Note:</span>
<span class="sd">            The first neuron set (new_neuron_set_1) is preferred and treated as</span>
<span class="sd">            the set to merge into. However, this function will not change the</span>
<span class="sd">            original argument.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_neuron_set_1(numpy.ndarray):            numpy structured array</span>
<span class="sd">                                                        (dtype get_neuron_dtype)</span>
<span class="sd">                                                        containing the first</span>
<span class="sd">                                                        neuron set (preferred</span>
<span class="sd">                                                        for tie breaking).</span>

<span class="sd">            new_neuron_set_2(numpy.ndarray):            numpy structured array</span>
<span class="sd">                                                        (dtype get_neuron_dtype)</span>
<span class="sd">                                                        containing the second</span>
<span class="sd">                                                        neuron set.</span>

<span class="sd">            alignment_min_threshold(float):             The minimum required</span>
<span class="sd">                                                        cosine of the angle</span>
<span class="sd">                                                        between two neurons for</span>
<span class="sd">                                                        them to be treated as</span>
<span class="sd">                                                        candidates for merging</span>
<span class="sd">                                                        (uses the function</span>
<span class="sd">                                                        expanded_numpy.dot_product_normalized</span>
<span class="sd">                                                        with ord = 2).</span>

<span class="sd">            overlap_min_threshold(numpy.ndarray):       The minimum required</span>
<span class="sd">                                                        dot product (divided by</span>
<span class="sd">                                                        the L1 norm of one of</span>
<span class="sd">                                                        the neurons) for them</span>
<span class="sd">                                                        to be treated as</span>
<span class="sd">                                                        candidates for merging</span>
<span class="sd">                                                        (uses the function</span>
<span class="sd">                                                        expanded_numpy.dot_product_partially_normalized).</span>

<span class="sd">            **parameters(dict):                         dictionary of parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                              a numpy structured</span>
<span class="sd">                                                        array that contains the</span>
<span class="sd">                                                        result of merging the</span>
<span class="sd">                                                        two sets (or appending</span>
<span class="sd">                                                        for neurons that could</span>
<span class="sd">                                                        not be merged).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">new_neuron_set_1</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_1</span>

    <span class="k">if</span> <span class="n">new_neuron_set_2</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_2</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">new_neuron_set_1</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">new_neuron_set_2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">new_neuron_set</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">new_neuron_set_1</span><span class="p">,</span> <span class="n">new_neuron_set_2</span><span class="p">])</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Have 2 sets of neurons to merge.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_1</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_2</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Have 1 set of neurons to merge. Only the first set has neurons.&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Have 0 sets of neurons to merge.&quot;</span><span class="p">)</span>

    <span class="n">original_new_neuron_set_size</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">new_neuron_set</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> \
            <span class="p">(</span><span class="n">original_new_neuron_set_size</span> <span class="o">!=</span> <span class="n">new_neuron_set</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">original_new_neuron_set_size</span> <span class="o">=</span> <span class="n">new_neuron_set</span><span class="o">.</span><span class="n">size</span>

        <span class="n">new_neuron_set_flattened_image</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span>
            <span class="n">new_neuron_set</span><span class="p">[</span><span class="s2">&quot;image&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">new_neuron_set_flattened_mask</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span>
            <span class="n">new_neuron_set</span><span class="p">[</span><span class="s2">&quot;mask&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Measure the normalized dot product between any two neurons (i.e.</span>
        <span class="c1"># related to the angle of separation)</span>
        <span class="n">new_neuron_set_angle</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">pair_dot_product_normalized</span><span class="p">(</span>
            <span class="n">new_neuron_set_flattened_image</span><span class="p">,</span>
            <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_angle</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">new_neuron_set_angle</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle</span>

        <span class="c1"># Measure the distance between the two masks</span>
        <span class="c1"># (note distance relative to the total mask content of each mask</span>
        <span class="c1"># individually)</span>
        <span class="n">new_neuron_set_masks_overlaid</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">pair_dot_product_partially_normalized</span><span class="p">(</span>
            <span class="n">new_neuron_set_flattened_mask</span><span class="p">,</span>
            <span class="nb">ord</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">float_type</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">new_neuron_set_masks_overlaid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">new_neuron_set_masks_overlaid_1</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid</span>
        <span class="n">new_neuron_set_masks_overlaid_2</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid</span><span class="o">.</span><span class="n">T</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2</span>

        <span class="c1"># Now that the three measures for the correlation method have been</span>
        <span class="c1"># found, we want to know, which are the best correlated neurons between</span>
        <span class="c1"># the two sets using these measures. This done to find the neuron in</span>
        <span class="c1"># new_neuron_set_1 that best matches each neuron in new_neuron_set_2.</span>
        <span class="n">new_neuron_set_angle_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_angle</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_all_optimal_i&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_all_optimal_i</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_all_optimal_i&quot;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_all_optimal_i&quot;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span>

        <span class="c1"># Get all the j indices</span>
        <span class="n">new_neuron_set_all_j</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">))</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_j&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j</span>

        <span class="c1"># Get the maximum corresponding to the best matched pairs from before</span>
        <span class="n">new_neuron_set_angle_maxes</span> <span class="o">=</span> <span class="n">new_neuron_set_angle</span><span class="p">[</span>
            <span class="p">(</span><span class="n">new_neuron_set_angle_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j</span><span class="p">,)</span>
        <span class="p">]</span>
        <span class="n">new_neuron_set_masks_overlaid_1_maxes</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1</span><span class="p">[</span>
            <span class="p">(</span><span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j</span><span class="p">,)</span>
        <span class="p">]</span>
        <span class="n">new_neuron_set_masks_overlaid_2_maxes</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2</span><span class="p">[</span>
            <span class="p">(</span><span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j</span><span class="p">,)</span>
        <span class="p">]</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_maxes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_maxes</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_maxes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_maxes</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_maxes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_maxes</span>

        <span class="c1"># Store a list of the optimal neurons in the existing set to fuse with</span>
        <span class="c1"># (by default set all values to -1)</span>
        <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="c1"># Create the masks to use for getting the proper indices</span>
        <span class="n">new_neuron_set_angle_maxes_significant</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span>
        <span class="p">)</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_maxes_significant_0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_maxes_significant</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_maxes_significant_0&quot;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_maxes_significant_0&quot;</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span>

        <span class="n">already_matched</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Get masks that indicate which measurements have the best matching</span>
        <span class="c1"># neuron</span>
        <span class="n">new_neuron_set_angle_maxes_significant</span><span class="p">[</span><span class="n">new_neuron_set_angle_maxes</span> <span class="o">&gt;</span> <span class="n">alignment_min_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">already_matched</span> <span class="o">|=</span> <span class="n">new_neuron_set_angle_maxes_significant</span>
        <span class="n">already_matched</span><span class="p">[</span>
            <span class="n">new_neuron_set_angle_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_angle_maxes_significant</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">|=</span> <span class="bp">True</span>

        <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span><span class="p">[</span>
            <span class="o">~</span><span class="n">already_matched</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">new_neuron_set_masks_overlaid_1_maxes</span> <span class="o">&gt;</span> <span class="n">overlap_min_threshold</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">already_matched</span> <span class="o">|=</span> <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span>
        <span class="n">already_matched</span><span class="p">[</span>
            <span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">|=</span> <span class="bp">True</span>

        <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span><span class="p">[</span>
            <span class="o">~</span><span class="n">already_matched</span> <span class="o">&amp;</span>
            <span class="p">(</span><span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span> <span class="o">&gt;</span> <span class="n">overlap_min_threshold</span><span class="p">)</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_angle_maxes_significant_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_maxes_significant</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_1_maxes_significant_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_masks_overlaid_2_maxes_significant_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span>

        <span class="c1"># Using the masks construct the best match neuron index for each case.</span>
        <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_angle_maxes_significant</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_angle_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_angle_maxes_significant</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_1_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_1_maxes_significant</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_masks_overlaid_2_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_masks_overlaid_2_maxes_significant</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>


        <span class="c1"># Separate all the best matches that were found from those that were</span>
        <span class="c1"># not. Also, remove the -1 as they have served their purpose.</span>
        <span class="n">new_neuron_set_all_optimal_i_found</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="n">new_neuron_set_all_j_fuse</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j</span><span class="p">[</span><span class="n">new_neuron_set_all_optimal_i_found</span><span class="p">]</span>
        <span class="n">new_neuron_set_all_j_append</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j</span><span class="p">[</span><span class="o">~</span><span class="n">new_neuron_set_all_optimal_i_found</span><span class="p">]</span>
        <span class="n">new_neuron_set_all_optimal_i</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span><span class="p">[</span><span class="n">new_neuron_set_all_optimal_i_found</span><span class="p">]</span>

        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_found&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i_found</span>

        <span class="k">if</span> <span class="n">new_neuron_set_all_j_fuse</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_j_fuse&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j_fuse</span>

        <span class="k">if</span> <span class="n">new_neuron_set_all_j_append</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_j_append&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_j_append</span>

        <span class="k">if</span> <span class="n">new_neuron_set_all_optimal_i</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neuron_set_all_optimal_i_3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set_all_optimal_i</span>

        <span class="n">new_neuron_set_kept</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Fuse all the neurons that can be from new_neuron_set_2 to the</span>
        <span class="c1"># new_neuron_set (composed of new_neuron_set_1)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">izip</span><span class="p">(</span>
                <span class="n">new_neuron_set_all_optimal_i</span><span class="p">,</span> <span class="n">new_neuron_set_all_j_fuse</span>
        <span class="p">):</span>
            <span class="c1">#fuse_neurons.recorders.array_debug_recorder = hdf5.record.HDF5EnumeratedArrayRecorder(</span>
            <span class="c1">#    merge_neuron_sets_repeatedly.recorders.array_debug_recorder.hdf5_handle</span>
            <span class="c1">#)</span>
            <span class="n">fuse_neurons</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>

            <span class="n">new_neuron_set</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fuse_neurons</span><span class="p">(</span>
                <span class="n">new_neuron_set</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">new_neuron_set</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
                <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;fuse_neurons&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="n">new_neuron_set_kept</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">new_neuron_set</span> <span class="o">=</span> <span class="n">new_neuron_set</span><span class="p">[</span><span class="n">new_neuron_set_kept</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Fused </span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_neuron_set_all_j_fuse</span><span class="p">))</span> <span class="o">+</span>
            <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2"> neurons to the existing set.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">new_neuron_set</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">merge_neuron_sets_repeatedly</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_merged_neurons_set&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neuron_set</span>

    <span class="k">return</span><span class="p">(</span><span class="n">new_neuron_set</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="expand_rois"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.expand_rois">[docs]</a><span class="k">def</span> <span class="nf">expand_rois</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">roi_masks</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="c1"># Find time traces: spatial mean of activity for each ROI</span>
    <span class="c1"># Normalize time traces: subtract mean from each time trace and</span>
    <span class="c1"># normalize each relative to L_2</span>
    <span class="c1"># Compute correlation: Multiply the time traces for each ROI</span>
    <span class="c1"># by the raw data to get an array with the dimensions of</span>
    <span class="c1"># the number of ROIs plus the dimensions of the raw data</span>

    <span class="c1"># Normalize the data</span>
    <span class="n">new_data_normalized</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span>
        <span class="n">new_data</span><span class="p">,</span>
        <span class="o">**</span><span class="p">{</span><span class="s2">&quot;renormalized_images&quot;</span> <span class="p">:</span> <span class="p">{</span><span class="s2">&quot;ord&quot;</span> <span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
    <span class="p">)</span>

    <span class="c1"># Compute the area of each ROI in order to</span>
    <span class="c1"># properly compute the average activity of each ROI.</span>
    <span class="n">roi_areas</span> <span class="o">=</span> <span class="n">roi_masks</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">roi_masks</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>

    <span class="c1"># Add fake dimensions so that both arrays have dimensions number of ROIs</span>
    <span class="c1"># and then tyx or tzyx.</span>
    <span class="n">new_data_normalized_expanded</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">expand_view</span><span class="p">(</span>
        <span class="n">new_data_normalized</span><span class="p">,</span> <span class="n">reps_before</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">roi_masks</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">roi_masks_expanded</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">expand_view</span><span class="p">(</span>
        <span class="n">roi_masks</span><span class="p">,</span> <span class="n">reps_before</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data_normalized</span><span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Added time afterwards for dividing time traces.</span>
    <span class="n">roi_areas_expanded</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">expand_view</span><span class="p">(</span>
        <span class="n">roi_areas</span><span class="p">,</span> <span class="n">reps_after</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data_normalized</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Compute the time traces such that they are the average activity inside</span>
    <span class="c1"># the ROI</span>
    <span class="n">time_traces</span> <span class="o">=</span> <span class="n">new_data_normalized_expanded</span> <span class="o">*</span> <span class="n">roi_masks_expanded</span>
    <span class="n">time_traces</span> <span class="o">=</span> <span class="n">time_traces</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
        <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">iters</span><span class="o">.</span><span class="n">irange</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">new_data_normalized_expanded</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">time_traces</span> <span class="o">/=</span> <span class="n">roi_areas_expanded</span>

    <span class="c1"># Normalize the time traces</span>
    <span class="n">normalized_time_traces</span> <span class="o">=</span> <span class="n">normalize_data</span><span class="p">(</span>
        <span class="n">time_traces</span><span class="p">,</span>
        <span class="o">**</span><span class="p">{</span><span class="s2">&quot;renormalized_images&quot;</span> <span class="p">:</span> <span class="p">{</span><span class="s2">&quot;ord&quot;</span> <span class="p">:</span> <span class="mi">2</span><span class="p">}}</span>
    <span class="p">)</span>

    <span class="c1"># Convert to matrix.</span>
    <span class="n">new_data_normalized_matrix</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">array_to_matrix</span><span class="p">(</span><span class="n">new_data_normalized</span><span class="p">)</span>

    <span class="c1"># Compute the correlation map</span>
    <span class="n">correlation_map</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
        <span class="n">normalized_time_traces</span><span class="p">,</span> <span class="n">new_data_normalized_matrix</span>
    <span class="p">)</span>
    <span class="n">correlation_map</span> <span class="o">=</span> <span class="n">correlation_map</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">roi_masks</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_data_normalized</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">correlation_map</span><span class="p">)</span></div>


<span class="nd">@prof.log_call</span><span class="p">(</span><span class="n">trace_logger</span><span class="p">)</span>
<span class="nd">@hdf5.record.static_array_debug_recorder</span>
<div class="viewcode-block" id="postprocess_data"><a class="viewcode-back" href="../../../nanshe.imp.segment.html#nanshe.imp.segment.postprocess_data">[docs]</a><span class="k">def</span> <span class="nf">postprocess_data</span><span class="p">(</span><span class="n">new_dictionary</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates neurons from the dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_dictionary(numpy.ndarray):        dictionary of basis images to</span>
<span class="sd">                                                  analyze for neurons.</span>

<span class="sd">            **parameters(dict):                   dictionary of parameters</span>

<span class="sd">        Returns:</span>
<span class="sd">            numpy.ndarray:                        structured array with</span>
<span class="sd">                                                  relevant information for each</span>
<span class="sd">                                                  neuron found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">new_neurons_set</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="c1"># TODO: Remove this as it is already accomplished using the HDF5EnumeratedArrayRecorder.</span>
    <span class="c1"># Puts each dictionary basis debug log into a separate group depending on</span>
    <span class="c1"># which basis image it was a part of.</span>
    <span class="k">def</span> <span class="nf">array_debug_recorder_enumerator</span><span class="p">(</span><span class="n">new_list</span><span class="p">):</span>
        <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;neuron_sets&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">neuron_sets_array_debug_recorder</span> <span class="o">=</span> <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;neuron_sets&quot;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_str</span><span class="p">,</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">iters</span><span class="o">.</span><span class="n">filled_stringify_enumerate</span><span class="p">(</span><span class="n">new_list</span><span class="p">):</span>
            <span class="n">neuron_sets_array_debug_recorder</span><span class="p">[</span><span class="n">i_str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">yield</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">each</span><span class="p">,</span> <span class="n">neuron_sets_array_debug_recorder</span><span class="p">[</span><span class="n">i_str</span><span class="p">]))</span>

    <span class="c1"># Get all neurons for all images</span>
    <span class="n">new_neurons_set</span> <span class="o">=</span> <span class="n">get_empty_neuron</span><span class="p">(</span>
        <span class="n">shape</span><span class="o">=</span><span class="n">new_dictionary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_dictionary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
    <span class="p">)</span>
    <span class="n">unmerged_neuron_set</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
        <span class="n">unmerged_neuron_set</span> <span class="o">=</span> <span class="n">get_empty_neuron</span><span class="p">(</span>
            <span class="n">shape</span><span class="o">=</span><span class="n">new_dictionary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_dictionary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">each_new_dictionary_image</span><span class="p">,</span> <span class="n">each_array_debug_recorder</span> <span class="ow">in</span> <span class="n">array_debug_recorder_enumerator</span><span class="p">(</span><span class="n">new_dictionary</span><span class="p">):</span>
        <span class="n">wavelet_denoising</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
        <span class="n">each_new_neuron_set</span> <span class="o">=</span> <span class="n">wavelet_denoising</span><span class="p">(</span>
            <span class="n">each_new_dictionary_image</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;wavelet_denoising&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Denoised a set of neurons from frame &quot;</span> <span class="o">+</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_dictionary</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
            <span class="n">unmerged_neuron_set</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">unmerged_neuron_set</span><span class="p">,</span> <span class="n">each_new_neuron_set</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">merge_neuron_sets</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span> <span class="o">=</span> <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span>
        <span class="n">new_neurons_set</span> <span class="o">=</span> <span class="n">merge_neuron_sets</span><span class="p">(</span>
            <span class="n">new_neurons_set</span><span class="p">,</span>
            <span class="n">each_new_neuron_set</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters</span><span class="p">[</span><span class="s2">&quot;merge_neuron_sets&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Merged a set of neurons from frame &quot;</span> <span class="o">+</span>
            <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_dictionary</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">unmerged_neuron_set</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;unmerged_neuron_set&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unmerged_neuron_set</span>

            <span class="n">unmerged_neuron_set_contours</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">enumerate_masks_max</span><span class="p">(</span><span class="n">unmerged_neuron_set</span><span class="p">[</span><span class="s2">&quot;contour&quot;</span><span class="p">])</span>

            <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;unmerged_neuron_set_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unmerged_neuron_set_contours</span>

        <span class="k">if</span> <span class="n">new_neurons_set</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neurons_set&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neurons_set</span>

            <span class="n">new_neurons_set_contours</span> <span class="o">=</span> <span class="n">xnumpy</span><span class="o">.</span><span class="n">enumerate_masks_max</span><span class="p">(</span><span class="n">new_neurons_set</span><span class="p">[</span><span class="s2">&quot;contour&quot;</span><span class="p">])</span>

            <span class="n">postprocess_data</span><span class="o">.</span><span class="n">recorders</span><span class="o">.</span><span class="n">array_debug_recorder</span><span class="p">[</span><span class="s2">&quot;new_neurons_set_contours&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_neurons_set_contours</span>


    <span class="k">return</span><span class="p">(</span><span class="n">new_neurons_set</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../../index.html">nanshe 0.1.0a53+27.g5dee726 documentation</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2014-2015, John A. Kirkham.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.5.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>