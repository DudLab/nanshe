

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>nanshe.imp.segment module &mdash; nanshe 0.1.0a11+2.g09f3ce6 documentation</title>
    
    <link rel="stylesheet" href="_static/cloud.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noticia+Text|Open+Sans|Droid+Sans+Mono" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.0a11+2.g09f3ce6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/jquery.cookie.js"></script>
    <script type="text/javascript" src="_static/cloud.js"></script>
    <link rel="top" title="nanshe 0.1.0a11+2.g09f3ce6 documentation" href="index.html" />
    <link rel="next" title="nanshe.io package" href="nanshe.io.html" />
    <link rel="prev" title="nanshe.imp.renorm module" href="nanshe.imp.renorm.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head>
  <body role="document">
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="nanshe.io.html" title="nanshe.io package"
             accesskey="N">next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="nanshe.imp.renorm.html" title="nanshe.imp.renorm module"
             accesskey="P">previous</a> &nbsp; &nbsp;</li>
    <li><a href="index.html">nanshe 0.1.0a11+2.g09f3ce6 documentation</a> &raquo;</li>
 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-nanshe.imp.segment">
<span id="nanshe-imp-segment-module"></span><h1>nanshe.imp.segment module<a class="headerlink" href="#module-nanshe.imp.segment" title="Permalink to this headline">¶</a></h1>
<p>The <code class="docutils literal"><span class="pre">segment</span></code> module has components to make an image processing workflow.</p>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">segment</span></code> (or <strong>segment</strong>ation) module contains algorithms useful in
implementing ADINA ( doi:<a class="reference external" href="http://dx.doi.org/10.1109/ISBI.2013.6556660">10.1109/ISBI.2013.6556660</a> ), but could be reused in
other workflows. These primary sections can be grouped as follows</p>
<ol class="arabic simple">
<li>Preprocessing steps<ol class="loweralpha">
<li>registration correction (      <a class="reference internal" href="#nanshe.imp.segment.remove_zeroed_lines" title="nanshe.imp.segment.remove_zeroed_lines"><code class="xref py py-func docutils literal"><span class="pre">remove_zeroed_lines()</span></code></a> )</li>
<li>background estimation and subtraction (      <a class="reference internal" href="#nanshe.imp.segment.estimate_f0" title="nanshe.imp.segment.estimate_f0"><code class="xref py py-func docutils literal"><span class="pre">estimate_f0()</span></code></a>,      <a class="reference internal" href="#nanshe.imp.segment.extract_f0" title="nanshe.imp.segment.extract_f0"><code class="xref py py-func docutils literal"><span class="pre">extract_f0()</span></code></a> )</li>
<li>wavelet transform ( <a class="reference internal" href="nanshe.imp.filters.wavelet.html#nanshe.imp.filters.wavelet.transform" title="nanshe.imp.filters.wavelet.transform"><code class="xref py py-func docutils literal"><span class="pre">transform()</span></code></a> )</li>
<li>normalization ( <a class="reference internal" href="#nanshe.imp.segment.normalize_data" title="nanshe.imp.segment.normalize_data"><code class="xref py py-func docutils literal"><span class="pre">normalize_data()</span></code></a> )</li>
</ol>
</li>
<li>Dictionary learning step (    <a class="reference internal" href="#nanshe.imp.segment.generate_dictionary" title="nanshe.imp.segment.generate_dictionary"><code class="xref py py-func docutils literal"><span class="pre">generate_dictionary()</span></code></a> )</li>
<li>Postprocessing<ol class="loweralpha">
<li>segmentation and refinement (      <a class="reference internal" href="#nanshe.imp.segment.wavelet_denoising" title="nanshe.imp.segment.wavelet_denoising"><code class="xref py py-func docutils literal"><span class="pre">wavelet_denoising()</span></code></a> )</li>
<li>merging ( <a class="reference internal" href="#nanshe.imp.segment.merge_neuron_sets" title="nanshe.imp.segment.merge_neuron_sets"><code class="xref py py-func docutils literal"><span class="pre">merge_neuron_sets()</span></code></a> )</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="api">
<h2>API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="nanshe.imp.segment.ExtendedRegionProps">
<em class="property">class </em><code class="descclassname">nanshe.imp.segment.</code><code class="descname">ExtendedRegionProps</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#ExtendedRegionProps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Using the results of extended_region_local_maxima_properties with given
intensity and label images, the ExtendedRegionProps attempts to make it
easy to get information about local maxima in the image. Further, it
provides methods to allow removal of local maxima. When removing local
maxima, it will updated the given label image to reflect labels that
have been removed completely and will automatically renumber the label
image (as some functions expect a label image with sequential
numbering, no missing label number). This provides a simple way to
maintain a label image, whose local maxima one is more interested in
directly manipulating.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Adding local maxima is not allowed for and wouldn&#8217;t make sense
given its dependency on the intensity image.</p>
</div>
<dl class="method">
<dt id="nanshe.imp.segment.ExtendedRegionProps.get_local_max_index_array">
<code class="descname">get_local_max_index_array</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#ExtendedRegionProps.get_local_max_index_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps.get_local_max_index_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a numpy style index array from the local maxima present.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a numpy styled index array, which can be used on
the intensity image, or label image.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">tuple</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nanshe.imp.segment.ExtendedRegionProps.get_local_max_label_image">
<code class="descname">get_local_max_label_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#ExtendedRegionProps.get_local_max_label_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps.get_local_max_label_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets an int numpy array that contains the labels of the local
maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">an int numpy array that contains the labels
of the local maxima and is zero in the
background.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nanshe.imp.segment.ExtendedRegionProps.get_local_max_mask">
<code class="descname">get_local_max_mask</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#ExtendedRegionProps.get_local_max_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps.get_local_max_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a bool numpy array that is True at the locations of the local
maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a bool numpy array that is True where a
local max is and False everywhere else.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="nanshe.imp.segment.ExtendedRegionProps.recorders">
<code class="descname">recorders</code><em class="property"> = &lt;nanshe.io.hdf5.record.ClassSubgroupingRecorders object&gt;</em><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps.recorders" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="nanshe.imp.segment.ExtendedRegionProps.remove_prop_indices">
<code class="descname">remove_prop_indices</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#ExtendedRegionProps.remove_prop_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps.remove_prop_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the local maxima of the indices listed (like
remove_prop_mask except with indices).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a label is removed completely, the label image, intensity
image, and image mask will be updated. Also, the count (of
local maxima per label) will be updated, regardless.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>*i</strong> (<em>int</em>) &#8211; A mask of the indices to drop (True for the ones
to remove, and False for the ones to keep).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nanshe.imp.segment.ExtendedRegionProps.remove_prop_mask">
<code class="descname">remove_prop_mask</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#ExtendedRegionProps.remove_prop_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps.remove_prop_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the local maxima by the mask over their indices (only False
elements will be kept).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a label is removed completely, the label image, intensity
image, and image mask will be updated. Also, the count (of
local maxima per label) will be updated, regardless.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>remove_prop_indices_mask</strong> (<em>numpy.ndarray</em>) &#8211; A mask of the
indices to drop
(True for the ones
to remove, and
False for the ones
to keep).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="nanshe.imp.segment.ExtendedRegionProps.renumber_labels">
<code class="descname">renumber_labels</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#ExtendedRegionProps.renumber_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.ExtendedRegionProps.renumber_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>An internal method to be called after a label is completely removed
from the local maxima.</p>
<p>Ensures all labels are in sequential order in the label image,
count, and that all local maxima have their labels updated.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Calling this externally will not make a difference as long as
removal has occurred through the usual mechanisms.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.estimate_f0">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">estimate_f0</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#estimate_f0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.estimate_f0" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates F_0 using a rank order filter with some smoothing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_data</strong> (<em>numpy.ndarray</em>) &#8211; array of
data for
finding
baseline (
first axis
is time).</li>
<li><strong>half_window_size</strong> (<em>int</em>) &#8211; the rank
filter
window size
is
2*half_window_size+1.</li>
<li><strong>which_quantile</strong> (<em>float</em>) &#8211; which
quantile to
return from
the rank
filter.</li>
<li><strong>temporal_smoothing_gaussian_filter_stdev</strong> (<em>float</em>) &#8211; stdev for
gaussian
filter
to convolve
over time.</li>
<li><strong>temporal_smoothing_gaussian_filter_window_size</strong> (<em>float</em>) &#8211; window for
gaussian
filter to
convolve
over time.
(Measured
in standard
deviations)</li>
<li><strong>spatial_smoothing_gaussian_filter_stdev</strong> (<em>float</em>) &#8211; stdev for
gaussian
filter to
convolve
over space.</li>
<li><strong>spatial_smoothing_gaussian_filter_window_size</strong> (<em>float</em>) &#8211; window for
gaussian
filter
to convolve
over space.
(Measured
in standard
deviations)</li>
<li><strong>out</strong> (<em>numpy.ndarray</em>) &#8211; where the
final
result
will be
stored.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; essentially
unused (
catches
unneeded
arguments).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the F_0
estimate.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.expand_rois">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">expand_rois</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#expand_rois"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.expand_rois" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.extended_region_local_maxima_properties">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">extended_region_local_maxima_properties</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#extended_region_local_maxima_properties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.extended_region_local_maxima_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates local maxima along with other properties for each labeled
region (therefore at least one entry per label). Gets a label image if
not provided by using the threshold (if not provided is zero).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is similar to region_properties. It differs in that it keeps
track of all local maxima. So, it is no longer one-to-one in
labels, but is one-to-one in local maxima.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_intensity_image</strong> (<em>numpy.ndarray</em>) &#8211; The intensity image to find
local maxima for (ideally,
all axes are spatial;
however, it will treat all
axes the same).</li>
<li><strong>new_label_image</strong> (<em>numpy.ndarray</em>) &#8211; The label image to find
local maxima for (ideally,
all axes are spatial;
however, it will treat all
axes the same).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A mask of the local maxima.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.extract_f0">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">extract_f0</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#extract_f0"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.extract_f0" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to find an estimate for dF/F.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_data</strong> (<em>numpy.ndarray</em>) &#8211; array of
data for
finding
baseline (
first axis
is time).</li>
<li><strong>half_window_size</strong> (<em>int</em>) &#8211; the rank
filter
window size
is
2*half_window_size+1.</li>
<li><strong>which_quantile</strong> (<em>float</em>) &#8211; which
quantile to
return from
the rank
filter.</li>
<li><strong>temporal_smoothing_gaussian_filter_stdev</strong> (<em>float</em>) &#8211; stdev for
gaussian
filter to
convolve
over time.</li>
<li><strong>temporal_smoothing_gaussian_filter_window_size</strong> (<em>float</em>) &#8211; window for
gaussian
filter to
convolve
over time.
(Measured
in standard
deviations)</li>
<li><strong>spatial_smoothing_gaussian_filter_stdev</strong> (<em>float</em>) &#8211; stdev for
gaussian
filter to
convolve
over space.</li>
<li><strong>spatial_smoothing_gaussian_filter_window_size</strong> (<em>float</em>) &#8211; window for
gaussian
filter
to convolve
over space.
(Measured
in standard
deviations)</li>
<li><strong>bias</strong> (<em>float</em>) &#8211; value to be
added to
dataset to
avoid nan.</li>
<li><strong>out</strong> (<em>numpy.ndarray</em>) &#8211; where the
final
result will
be stored.</li>
<li><strong>return_f0</strong> (<em>bool</em>) &#8211; whether to
return F_0
also, F_0
will be
returned
first.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; essentially
unused (
catches
unneeded
arguments).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dF/F or if
return_f0
is True a
tuple (F_0,
dF/F).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(tuple of numpy.ndarray)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.extract_neurons">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">extract_neurons</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#extract_neurons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.extract_neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts neurons from an image using a stack of masks.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_image</strong> (<em>numpy.ndarray</em>) &#8211; spatial coordinates only (no
time).</li>
<li><strong>neuron_masks</strong> (<em>numpy.ndarray</em>) &#8211; first index of denotes which
mask and all others are spatial
indices.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a stack of neurons in the same
order as the masks.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.fuse_neurons">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">fuse_neurons</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#fuse_neurons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.fuse_neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges the two neurons into one neuron, which is returned.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The first neuron (neuron_1) is preferred in tie-breaking
situations.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>neuron_1</strong> (<em>numpy.ndarray</em>) &#8211; numpy structured array (dtype
get_neuron_dtype) containing
the first neuron.</li>
<li><strong>neuron_2</strong> (<em>numpy.ndarray</em>) &#8211; numpy structured array (dtype
get_neuron_dtype) containing
the second neuron.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; dictionary of parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a new neuron that is the result
of fusing the two.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.generate_dictionary">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">generate_dictionary</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#generate_dictionary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.generate_dictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a dictionary using the data and parameters given for trainDL.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_data</strong> (<em>numpy.ndarray</em>) &#8211; array of data for generating a
dictionary (first axis is
time).</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; passed directly to
spams.trainDL.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the dictionary found.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.generate_local_maxima">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">generate_local_maxima</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#generate_local_maxima"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.generate_local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mask the same size as the intensity image with local maxima
as True and background False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_intensity_image</strong> (<em>numpy.ndarray</em>) &#8211; The image to find local
maxima for (ideally, all
axes are spatial; however,
it will treat all axes the
same).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A mask of the local maxima.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.generate_local_maxima_scikit_image">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">generate_local_maxima_scikit_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#generate_local_maxima_scikit_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.generate_local_maxima_scikit_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mask the same size as the intensity image with local maxima
as True and background False. Uses scikit image&#8217;s
skimage.feature.peak_local_max.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_intensity_image</strong> (<em>numpy.ndarray</em>) &#8211; The image to find local
maxima for (ideally, all
axes are spatial; however,
it will treat all axes the
same).</li>
<li><strong>local_max_neighborhood_size</strong> (<em>int</em>) &#8211; Size of the neighborhood to
check for a local maxima.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A mask of the local maxima.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.generate_local_maxima_vigra">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">generate_local_maxima_vigra</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#generate_local_maxima_vigra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.generate_local_maxima_vigra" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a mask the same size as the intensity image with local maxima
as True and background False. Uses vigra&#8217;s
vigra.analysis.extendedLocalMaxima for 2D and
vigra&#8217;s vigra.analysis.extendedLocalMaxima3D for 3D.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_intensity_image</strong> (<em>numpy.ndarray</em>) &#8211; The image to find local
maxima for (ideally, all
axes are spatial; however,
it will treat all axes the
same).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A mask of the local maxima.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.get_empty_neuron">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">get_empty_neuron</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#get_empty_neuron"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.get_empty_neuron" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a numpy structured array using the type from get_neuron_dtype that
has no contents.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_image</strong> (<em>numpy.ndarray</em>) &#8211; an empty numpy structured array with
all types needed for a neuron.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a numpy structured array with no
contents and type from
get_neuron_dtype.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">get_empty_neuron</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">array([], dtype=[(&#39;mask&#39;, &#39;?&#39;, (3,)),</span>
<span class="go">                 (&#39;contour&#39;, &#39;?&#39;, (3,)),</span>
<span class="go">                 (&#39;image&#39;, &#39;&lt;f8&#39;, (3,)),</span>
<span class="go">                 (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                 (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                 (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (1,)),</span>
<span class="go">                 (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (1, 1)),</span>
<span class="go">                 (&#39;centroid&#39;, &#39;&lt;f8&#39;, (1,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">get_empty_neuron</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">array([], dtype=[(&#39;mask&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="go">                 (&#39;contour&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="go">                 (&#39;image&#39;, &#39;&lt;f8&#39;, (2, 3)),</span>
<span class="go">                 (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                 (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                 (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (2,)),</span>
<span class="go">                 (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (2, 2)),</span>
<span class="go">                 (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.get_neuron_dtype">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">get_neuron_dtype</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#get_neuron_dtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.get_neuron_dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the type based on properties of an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_image</strong> (<em>numpy.ndarray</em>) &#8211; a single sample image (only spatial
dimension).</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a list that can be converted to a
numpy.dtype using numpy.ndtype&#8217;s
constructor.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">get_neuron_dtype</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">[(&#39;mask&#39;, &lt;type &#39;numpy.bool_&#39;&gt;, (3,)),</span>
<span class="go"> (&#39;contour&#39;, &lt;type &#39;numpy.bool_&#39;&gt;, (3,)),</span>
<span class="go"> (&#39;image&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (3,)),</span>
<span class="go"> (&#39;area&#39;, &lt;type &#39;numpy.float64&#39;&gt;),</span>
<span class="go"> (&#39;max_F&#39;, &lt;type &#39;numpy.float64&#39;&gt;),</span>
<span class="go"> (&#39;gaussian_mean&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (1,)),</span>
<span class="go"> (&#39;gaussian_cov&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (1, 1)),</span>
<span class="go"> (&#39;centroid&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (1,))]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">get_neuron_dtype</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">[(&#39;mask&#39;, &lt;type &#39;numpy.bool_&#39;&gt;, (2, 3)),</span>
<span class="go"> (&#39;contour&#39;, &lt;type &#39;numpy.bool_&#39;&gt;, (2, 3)),</span>
<span class="go"> (&#39;image&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (2, 3)),</span>
<span class="go"> (&#39;area&#39;, &lt;type &#39;numpy.float64&#39;&gt;),</span>
<span class="go"> (&#39;max_F&#39;, &lt;type &#39;numpy.float64&#39;&gt;),</span>
<span class="go"> (&#39;gaussian_mean&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (2,)),</span>
<span class="go"> (&#39;gaussian_cov&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (2, 2)),</span>
<span class="go"> (&#39;centroid&#39;, &lt;type &#39;numpy.float64&#39;&gt;, (2,))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.get_one_neuron">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">get_one_neuron</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#get_one_neuron"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.get_one_neuron" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a numpy structured array using the type from get_neuron_dtype that
has one neuron with all zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>new_image</strong> (<em>numpy.ndarray</em>) &#8211; an empty numpy structured array with
all types needed for a neuron.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a numpy structured array with one
neuron using type from
get_neuron_dtype.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">get_one_neuron</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">array([ ([False, False, False],</span>
<span class="go">         [False, False, False],</span>
<span class="go">         [0.0, 0.0, 0.0],</span>
<span class="go">         0.0,</span>
<span class="go">         0.0,</span>
<span class="go">         [0.0],</span>
<span class="go">         [[0.0]],</span>
<span class="go">         [0.0])],</span>
<span class="go">       dtype=[(&#39;mask&#39;, &#39;?&#39;, (3,)),</span>
<span class="go">              (&#39;contour&#39;, &#39;?&#39;, (3,)),</span>
<span class="go">              (&#39;image&#39;, &#39;&lt;f8&#39;, (3,)),</span>
<span class="go">              (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">              (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">              (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (1,)),</span>
<span class="go">              (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (1, 1)),</span>
<span class="go">              (&#39;centroid&#39;, &#39;&lt;f8&#39;, (1,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">get_one_neuron</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">array([ ([[False, False, False],</span>
<span class="go">          [False, False, False]],</span>
<span class="go">         [[False, False, False],</span>
<span class="go">          [False, False, False]],</span>
<span class="go">         [[0.0, 0.0, 0.0],</span>
<span class="go">          [0.0, 0.0, 0.0]],</span>
<span class="go">         0.0,</span>
<span class="go">         0.0,</span>
<span class="go">         [0.0, 0.0],</span>
<span class="go">        [[0.0, 0.0],</span>
<span class="go">         [0.0, 0.0]],</span>
<span class="go">        [0.0, 0.0])],</span>
<span class="go">       dtype=[(&#39;mask&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="go">              (&#39;contour&#39;, &#39;?&#39;, (2, 3)),</span>
<span class="go">              (&#39;image&#39;, &#39;&lt;f8&#39;, (2, 3)),</span>
<span class="go">              (&#39;area&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">              (&#39;max_F&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">              (&#39;gaussian_mean&#39;, &#39;&lt;f8&#39;, (2,)),</span>
<span class="go">              (&#39;gaussian_cov&#39;, &#39;&lt;f8&#39;, (2, 2)),</span>
<span class="go">              (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.merge_neuron_sets">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">merge_neuron_sets</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#merge_neuron_sets"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.merge_neuron_sets" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.merge_neuron_sets_once">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">merge_neuron_sets_once</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#merge_neuron_sets_once"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.merge_neuron_sets_once" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges the two sets of neurons into one. Appends neurons that cannot be
merged with the existing set.</p>
<p>In the functions that follow, it helps to think of each neuron as a
vector (instead of as an image). So, dot products for vectors are
important.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The first neuron set (new_neuron_set_1) is preferred and treated as
the set to merge into. However, this function will not change the
original argument.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_neuron_set_1</strong> (<em>numpy.ndarray</em>) &#8211; numpy structured array
(dtype get_neuron_dtype)
containing the first
neuron set (preferred
for tie breaking).</li>
<li><strong>new_neuron_set_2</strong> (<em>numpy.ndarray</em>) &#8211; numpy structured array
(dtype get_neuron_dtype)
containing the second
neuron set.</li>
<li><strong>alignment_min_threshold</strong> (<em>float</em>) &#8211; The minimum required
cosine of the angle
between two neurons for
them to be treated as
candidates for merging
(uses the function
expanded_numpy.dot_product_normalized
with ord = 2).</li>
<li><strong>overlap_min_threshold</strong> (<em>numpy.ndarray</em>) &#8211; The minimum required
dot product (divided by
the L1 norm of one of
the neurons) for them
to be treated as
candidates for merging
(uses the function
expanded_numpy.dot_product_partially_normalized).</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; dictionary of
parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a numpy structured
array that contains the
result of merging the
two sets (or appending
for neurons that could
not be merged).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.merge_neuron_sets_repeatedly">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">merge_neuron_sets_repeatedly</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#merge_neuron_sets_repeatedly"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.merge_neuron_sets_repeatedly" title="Permalink to this definition">¶</a></dt>
<dd><p>Merges the two sets of neurons into one. Appends neurons that cannot be
merged with the existing set.</p>
<p>In the functions that follow, it helps to think of each neuron as a
vector (instead of as an image). So, dot products for vectors are
important.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The first neuron set (new_neuron_set_1) is preferred and treated as
the set to merge into. However, this function will not change the
original argument.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_neuron_set_1</strong> (<em>numpy.ndarray</em>) &#8211; numpy structured array
(dtype get_neuron_dtype)
containing the first
neuron set (preferred
for tie breaking).</li>
<li><strong>new_neuron_set_2</strong> (<em>numpy.ndarray</em>) &#8211; numpy structured array
(dtype get_neuron_dtype)
containing the second
neuron set.</li>
<li><strong>alignment_min_threshold</strong> (<em>float</em>) &#8211; The minimum required
cosine of the angle
between two neurons for
them to be treated as
candidates for merging
(uses the function
expanded_numpy.dot_product_normalized
with ord = 2).</li>
<li><strong>overlap_min_threshold</strong> (<em>numpy.ndarray</em>) &#8211; The minimum required
dot product (divided by
the L1 norm of one of
the neurons) for them
to be treated as
candidates for merging
(uses the function
expanded_numpy.dot_product_partially_normalized).</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; dictionary of parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a numpy structured
array that contains the
result of merging the
two sets (or appending
for neurons that could
not be merged).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.normalize_data">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">normalize_data</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#normalize_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.normalize_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the mean from each image and normalizes each image as if they
were vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_data</strong> (<em>numpy.ndarray</em>) &#8211; array of data for
normalization (first axis
is time).</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; contains arguments for
renormalized_images.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">data that has been
normalized.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_data</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s">&quot;renormalized_images&quot;</span> <span class="p">:</span> <span class="p">{</span> <span class="s">&quot;ord&quot;</span> <span class="p">:</span> <span class="mi">2</span> <span class="p">}})</span>
<span class="go">array([[[ 0.8660254 , -0.28867513],</span>
<span class="go">        [-0.28867513, -0.28867513]],</span>

<span class="go">       [[-0.28867513, -0.28867513],</span>
<span class="go">        [-0.28867513,  0.8660254 ]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_data</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s">&quot;renormalized_images&quot;</span> <span class="p">:</span> <span class="p">{</span> <span class="s">&quot;ord&quot;</span> <span class="p">:</span> <span class="mi">2</span> <span class="p">}}</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([[[ 0.8660254 , -0.28867513],</span>
<span class="go">        [-0.28867513, -0.28867513]],</span>

<span class="go">       [[-0.28867513, -0.28867513],</span>
<span class="go">        [-0.28867513,  0.8660254 ]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[[ 0.8660254 , -0.28867513],</span>
<span class="go">        [-0.28867513, -0.28867513]],</span>

<span class="go">       [[-0.28867513, -0.28867513],</span>
<span class="go">        [-0.28867513,  0.8660254 ]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalize_data</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s">&quot;renormalized_images&quot;</span> <span class="p">:</span> <span class="p">{</span> <span class="s">&quot;ord&quot;</span> <span class="p">:</span> <span class="mi">2</span> <span class="p">}}</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([[[ 0.8660254 , -0.28867513],</span>
<span class="go">        [-0.28867513, -0.28867513]],</span>

<span class="go">       [[-0.28867513, -0.28867513],</span>
<span class="go">        [-0.28867513,  0.8660254 ]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[[ 0.8660254 , -0.28867513],</span>
<span class="go">        [-0.28867513, -0.28867513]],</span>

<span class="go">       [[-0.28867513, -0.28867513],</span>
<span class="go">        [-0.28867513,  0.8660254 ]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.postprocess_data">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">postprocess_data</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#postprocess_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.postprocess_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates neurons from the dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_dictionary</strong> (<em>numpy.ndarray</em>) &#8211; dictionary of basis images to
analyze for neurons.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; dictionary of parameters</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">structured array with
relevant information for each
neuron found.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.preprocess_data">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">preprocess_data</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#preprocess_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.preprocess_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs all preprocessing steps that are specified.</p>
<p>(e.g. remove_zeroed_lines, bias, extract_f0, and wavelet.transform).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_data</strong> (<em>numpy.ndarray</em>) &#8211; array of data for generating a
dictionary (first axis is
time).</li>
<li><strong>out</strong> (<em>numpy.ndarray</em>) &#8211; where the final result will be
stored.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; additional parameters for each
step of preprocessing.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">the dictionary found.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">dict</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.region_properties">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">region_properties</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#region_properties"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.region_properties" title="Permalink to this definition">¶</a></dt>
<dd><p>Grabs region properties from a label image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_label_image</strong> (<em>numpy.ndarray</em>) &#8211; label image used for
generating properties.</li>
<li><strong>args</strong> (<em>list</em>) &#8211; additional position arguments
to pass
skimage.measure.regionprops.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; additional keyword arguments
to pass
skimage.measure.regionprops.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Uses all the same options in skimage.measure.regionprops. If a
property is not specified, then it won&#8217;t be returned.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a structured array of all the
properties found for each
label.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">array([],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">array([(1, 4.0, [0.5, 0.5])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span> 
<span class="go">array([(1, 9.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">[</span><span class="s">&quot;area&quot;</span><span class="p">,</span> <span class="s">&quot;centroid&quot;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;area&quot;</span><span class="p">,</span> <span class="s">&quot;centroid&quot;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.region_properties_scikit_image">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">region_properties_scikit_image</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#region_properties_scikit_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.region_properties_scikit_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Grabs region properties from a label image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_label_image</strong> (<em>numpy.ndarray</em>) &#8211; label image used for
generating properties.</li>
<li><strong>args</strong> (<em>list</em>) &#8211; additional position arguments
to pass
skimage.measure.regionprops.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; additional keyword arguments
to pass
skimage.measure.regionprops.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Uses all the same options in skimage.measure.regionprops. If a
property is not specified, then it won&#8217;t be returned.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a structured array of all the
properties found for each
label.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_scikit_image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_scikit_image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([(1, 4.0, [0.5, 0.5])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_scikit_image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([(1, 9.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_scikit_image</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_scikit_image</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">[</span><span class="s">&quot;area&quot;</span><span class="p">,</span> <span class="s">&quot;centroid&quot;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_scikit_image</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;area&quot;</span><span class="p">,</span> <span class="s">&quot;centroid&quot;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.region_properties_vigra">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">region_properties_vigra</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#region_properties_vigra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.region_properties_vigra" title="Permalink to this definition">¶</a></dt>
<dd><p>Grabs region properties from a label image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>new_label_image</strong> (<em>numpy.ndarray</em>) &#8211; label image used for
generating properties.</li>
<li><strong>args</strong> (<em>list</em>) &#8211; additional position arguments
to pass
skimage.measure.regionprops.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; additional keyword arguments
to pass
skimage.measure.regionprops.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Uses all the same options in skimage.measure.regionprops. If a
property is not specified, then it won&#8217;t be returned.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a structured array of all the
properties found for each
label.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">numpy.ndarray</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_vigra</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_vigra</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([(1, 4.0, [0.5, 0.5])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_vigra</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([(1, 9.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_vigra</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">))</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_vigra</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="p">[</span><span class="s">&quot;area&quot;</span><span class="p">,</span> <span class="s">&quot;centroid&quot;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">region_properties_vigra</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;area&quot;</span><span class="p">,</span> <span class="s">&quot;centroid&quot;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">array([(1, 3.0, [1.0, 1.0])],</span>
<span class="go">      dtype=[(&#39;label&#39;, &#39;&lt;i8&#39;), (&#39;area&#39;, &#39;&lt;f8&#39;), (&#39;centroid&#39;, &#39;&lt;f8&#39;, (2,))])</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.remove_low_intensity_local_maxima">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">remove_low_intensity_local_maxima</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#remove_low_intensity_local_maxima"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.remove_low_intensity_local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the local maxima for regions, which have too many pixels that
are below the intensity of their local maxima.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>local_maxima</strong> (<a class="reference internal" href="#nanshe.imp.segment.ExtendedRegionProps" title="nanshe.imp.segment.ExtendedRegionProps"><em>ExtendedRegionProps</em></a>) &#8211; The local maxima to refine</li>
<li><strong>percentage_pixels_below_max</strong> (<em>float</em>) &#8211; The percentage of pixels
out of a region that are
below the local maxima of
the region</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; essentially unused (catches
unneeded arguments).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a new instance with the
local maxima removed</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#nanshe.imp.segment.ExtendedRegionProps" title="nanshe.imp.segment.ExtendedRegionProps">ExtendedRegionProps</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.remove_too_close_local_maxima">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">remove_too_close_local_maxima</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#remove_too_close_local_maxima"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.remove_too_close_local_maxima" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes local maxima that are too close to each other.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>local_maxima</strong> (<a class="reference internal" href="#nanshe.imp.segment.ExtendedRegionProps" title="nanshe.imp.segment.ExtendedRegionProps"><em>ExtendedRegionProps</em></a>) &#8211; The local maxima to refine</li>
<li><strong>min_local_max_distance</strong> (<em>float</em>) &#8211; The minimum allowed
distance between local
maxima</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; essentially unused (catches
unneeded arguments).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a new instance with the
local maxima removed</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#nanshe.imp.segment.ExtendedRegionProps" title="nanshe.imp.segment.ExtendedRegionProps">ExtendedRegionProps</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.remove_zeroed_lines">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">remove_zeroed_lines</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#remove_zeroed_lines"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.remove_zeroed_lines" title="Permalink to this definition">¶</a></dt>
<dd><p>Due to registration errors, there will sometimes be lines that are
zero. To correct this, we find an interpolated value to replace the
zeros with. If that fails, we copy nearby values over.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_data</strong> (<em>numpy.ndarray</em>) &#8211; data to remove lines from (
first axis is time).</li>
<li><strong>erosion_shape</strong> (<em>numpy.ndarray</em>) &#8211; shape of the erosion element
(will be filled with 1).</li>
<li><strong>dilation_shape</strong> (<em>numpy.ndarray</em>) &#8211; shape of the dilation element
(will be filled with 1).</li>
<li><strong>out</strong> (<em>numpy.ndarray</em>) &#8211; where the final results will be
stored.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; essentially unused (catches
unneeded arguments).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a new array with the zeroed
lines interpolated away.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="nanshe.imp.segment.wavelet_denoising">
<code class="descclassname">nanshe.imp.segment.</code><code class="descname">wavelet_denoising</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nanshe/imp/segment.html#wavelet_denoising"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nanshe.imp.segment.wavelet_denoising" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs wavelet denoising on the given dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>new_image</strong> (<em>numpy.ndarray</em>) &#8211; array of data for
generating a dictionary
(first axis is time).</li>
<li><strong>accepted_region_shape_constraints</strong> (<em>dict</em>) &#8211; a dictionary containing
properties (that could
be passed to
region_properties)
under this should be a
dictionary that
contains the keys min
and/or max with a value
for each.</li>
<li><strong>accepted_neuron_shape_constraints</strong> (<em>dict</em>) &#8211; a dictionary containing
properties (that could
be passed to
region_properties)
under this should be a
dictionary that
contains the keys min
and/or max with a value
for each.</li>
<li><strong>**parameters</strong> (<em>dict</em>) &#8211; additional parameters
for various other
function calls.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">a structured array of
candidate neurons.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">numpy.ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="sphinxlocaltoc">
    <h3><a href="index.html">Page contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">nanshe.imp.segment module</a><ul>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#api">API</a></li>
</ul>
</li>
</ul>

  </div>
  <div class="sphinxprev">
    <h4>Previous page</h4>
    <p class="topless"><a href="nanshe.imp.renorm.html"
                          title="Previous page">&larr; nanshe.imp.renorm module</a></p>
  </div>
  <div class="sphinxnext">
    <h4>Next page</h4>
    <p class="topless"><a href="nanshe.io.html"
                          title="Next page">&rarr; nanshe.io package</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/nanshe.imp.segment.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="nanshe.io.html" title="nanshe.io package"
             >next</a> &nbsp; &nbsp;</li>
        <li class="right" >
          <a href="nanshe.imp.renorm.html" title="nanshe.imp.renorm module"
             >previous</a> &nbsp; &nbsp;</li>
    <li><a href="index.html">nanshe 0.1.0a11+2.g09f3ce6 documentation</a> &raquo;</li>
 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2014-2015, John A. Kirkham.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>